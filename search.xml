<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2020/07/07/2020-07-07/"/>
      <url>/2020/07/07/2020-07-07/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解JVM-一"><a href="#深入理解JVM-一" class="headerlink" title="深入理解JVM(一)"></a>深入理解JVM(一)</h1><h2 id="Java从编码到执行"><a href="#Java从编码到执行" class="headerlink" title="Java从编码到执行"></a>Java从编码到执行</h2><p><img src="/2020/07/07/2020-07-07/java%E4%BB%8E%E7%BC%96%E8%AF%91%E5%88%B0%E6%89%A7%E8%A1%8C.jpg" alt></p><p>从一个 .java文件到执行, 首先需要经过javac编译成.class文件, 然后使用java执行这个class文件.</p><p>在java命令开始后, .class文件会被classLoader加载到内存中, 同时classLoader也会加载一些使用到的java类库.</p><p>.class文件进入内存之后会被字节码解释器和JIT即时编译器转换为对应平台的本地机器指令.再通过执行引擎执行.</p><h2 id="JVM是跨语言的平台"><a href="#JVM是跨语言的平台" class="headerlink" title="JVM是跨语言的平台"></a>JVM是跨语言的平台</h2><p>我们都说Java是跨平台的语言, 其实JVM也是跨语言的平台.</p><p>不仅java可以跑在虚拟机中, 有很多其他语言比如 kotlin, scala, jython等也可以直接跑在JVM上.</p><p>而JVM又屏蔽了各种操作系统之间的差异.</p><h2 id="JVM与class文件格式"><a href="#JVM与class文件格式" class="headerlink" title="JVM与class文件格式"></a>JVM与class文件格式</h2><h3 id="JVM与java无关"><a href="#JVM与java无关" class="headerlink" title="JVM与java无关"></a>JVM与java无关</h3><p><img src="/2020/07/07/2020-07-07/jvm%E4%B8%8Ejava%E6%97%A0%E5%85%B3.jpg" alt></p><p>任何语言, 只要能编译成class, 符合class规范, 就可以运行在jvm上.</p><h3 id="JVM是一种规范"><a href="#JVM是一种规范" class="headerlink" title="JVM是一种规范"></a>JVM是一种规范</h3><p>JVM是虚拟出来的一台计算机, 有自己的指令集,自己的内存管理.</p><h2 id="常见的JVM实现"><a href="#常见的JVM实现" class="headerlink" title="常见的JVM实现"></a>常见的JVM实现</h2><ul><li>Hotspot<ul><li>oracle官方, 一般常用的JVM</li><li>java -version</li></ul></li><li>Jrockit<ul><li>BEA, 曾经号称世界上最快的JVM</li><li>被oracle收购, 合并到hotspot</li></ul></li><li>J9 - IBM</li><li>Microsoft VM</li><li>TaobaoVM<ul><li>hotspot深度定制版</li></ul></li><li>LiquidVM<ul><li>直接针对硬件</li></ul></li><li>azul zing<ul><li>最新垃圾回收的业界标杆</li><li><a href="http://www.azul.com" target="_blank" rel="noopener">www.azul.com</a></li></ul></li></ul><h2 id="Class-File-Format"><a href="#Class-File-Format" class="headerlink" title="Class File Format"></a>Class File Format</h2><h3 id="Class文件内容"><a href="#Class文件内容" class="headerlink" title="Class文件内容"></a>Class文件内容</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>就是这么一个简单的类, 在编译完之后生成的class文件</p><p><img src="/2020/07/07/2020-07-07/class%E6%96%87%E4%BB%B6.jpg" alt></p><p>前4个字节 cafebabe 是class文件的开头, 称为magic number 魔数.</p><p>5-6个字节 0000 是minor version, 7-8个字节是major version java8的版本是52.</p><p>使用Bytecode viewer或者idea安装jclasslib Bytecode viewer可以开启class文件的分析结果页面.</p><p><img src="/2020/07/07/2020-07-07/class%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C.jpg" alt></p><p>可以看到, 上面的minor version, major version和一些其他信息都显示在上面了.</p><h4 id="General-Information"><a href="#General-Information" class="headerlink" title="General Information"></a>General Information</h4><p>Constant pool count: 常量池大小 (常量池的计数是从1开始的, 0预留为了不指向常量池的情况)</p><p>Access flags: 用于识别一些类或者接口层次的访问信息</p><p>This class: 当前类的信息 (放在常量池2的位置)</p><p>Super class: 父类信息 (放在常量池3的位置)</p><p>Interfaces count: 实现的接口数</p><p>Fields count: 类中的字段数</p><p>Methods count: 类中的方法数</p><p>Attributes count: 类中的属性数</p><h4 id="ConstantPool"><a href="#ConstantPool" class="headerlink" title="ConstantPool"></a>ConstantPool</h4><p><img src="/2020/07/07/2020-07-07/constantpool.jpg" alt></p><p>常量池, 常量池中有几种:</p><ul><li>CONSTANT_Utf8_info<ul><li>tag:1 – 占用空间一个字节</li><li>length: UTF-8字符串占用的字节数</li><li>bytes: 长度位length的字符串</li></ul></li><li>CONSTANT_Integer_info<ul><li>tag:3</li><li>bytes:4个字节 ​, Big-Endian(高位在前) 存储的int值</li></ul></li><li>CONSTANT_Float_info<ul><li>tag:4</li><li>4个字节Big-Endian的float值</li></ul></li><li>CONSTANT_Long_info<ul><li>tag:5</li><li>8个字节Big-Endian的long值</li></ul></li><li>CONSTANT_Double_info<ul><li>tag:6</li><li>8个字节Big-Endian的double值</li></ul></li><li>CONSTANT_Class_info<ul><li>tag:7</li><li>index:2字节 指向类的全限定名称的索引</li></ul></li><li>CONSTANT_String_info<ul><li>tag:8</li><li>2字节, 指向字符串字面量的索引</li></ul></li><li>CONSTANT_Fieldref_info<ul><li>tag:9</li><li>index:2字节 指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项</li><li>index:2字节 指向字段描述符CONSTANT_NameAndType的索引项</li></ul></li><li>CONSTANT_Methodref_info<ul><li>tag:10</li><li>index:2字节 指向声明方法的类或者接口描述符CONSTANT_Class_info的索引项</li><li>index:2字节 指向字段描述符CONSTANT_NameAndType的索引项</li></ul></li><li>CONSTANT_InterfaceMethodref_info<ul><li>tag:11</li><li>index:2字节 指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项</li><li>index:2字节 指向字段描述符CONSTANT_NameAndType的索引项</li></ul></li><li>CONSTANT_NameAndType_info<ul><li>tag:12</li><li>index:2字节 指向该字段或方法名称常量项的索引</li><li>index:2字节 指向该字段或方法描述符常量项的索引</li></ul></li><li>CONSTANT_MethodHandle_info<ul><li>tag:15</li><li>reference_kind:1字节 1-9之间的值, 决定了方法句柄的类型. 方法句柄类型的值表示方法句柄的字节码行为.</li><li>reference_index:2字节 对常量池的有效索引.</li></ul></li><li>CONSTANT_MethodType_info<ul><li>tag:16</li><li>descriptor_index:2字节 指向Utf8_info结构表示的方法描述符</li></ul></li><li>CONSTANT_InvokeDynamic_info<ul><li>tag:18</li><li>bootstrap_method_att_index:2字节 当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</li><li>name_and_type_index:2字节 指向NameAndTyoe_info表示的方法名和方法描述符</li></ul></li></ul><p>其他还有一些方法, 字段.</p><h2 id="类加载和初始化"><a href="#类加载和初始化" class="headerlink" title="类加载和初始化"></a>类加载和初始化</h2><p>加载的过程分为三大步, 第二步又分为三小步</p><ol><li>Loading</li><li>Linking<ol><li>Verification</li><li>Preparation</li><li>Resolution</li></ol></li><li>Initializing</li></ol><h3 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h3><p>把class装到内存中去</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>JVM中所有的类都是通过类加载器加载到内存的.</p><p>当一个class文件被load到内存中后, 实际上有两块内容.</p><p>一部分是class文件的二进制在内存中, 另一部分是class对象.</p><p>以后我们创建类的对象都是访问class对象, 通过class对象来访问class文件.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 由引导类加载器加载</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 由扩展类加载器加载</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sun<span class="token punctuation">.</span>net<span class="token punctuation">.</span>spi<span class="token punctuation">.</span>nameservice<span class="token punctuation">.</span>dns<span class="token punctuation">.</span>DNSNameService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 由应用类加载器加载</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Test01<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 类加载器也是一个类, 也是由类加载器加载的.</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Test01<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以直接使用 class.getClassLoader() 来获取加载这个类的加载器.</p><p>类加载器是分为不同的层次, 不同的类加载器加载不同的class.</p><p>最顶层叫Bootstrap, 引导类加载器, 负责加载jdk中最核心的类, 比如 lib/rt.jar charset.jar, 是用C++实现的.</p><p>再往下是Extension, 扩展类加载器, 负责加载扩展jar包, jre/lib/ext/下的内容. 或者由 -Djava.ext.dirs指定的.</p><p>再下面是App, 应用类加载器, 负责加载classpath中的内容.</p><p>一般情况下就是上面这三种类加载器.</p><p>还可以有自定义类加载器, 可以自己是实现类加载器.</p><p><strong>类加载过程</strong></p><p>一个class要被load到内存的时候, 如果是由自定义类加载器加载的话, 自定义加载器先查一下是否已经加载了进来. 如果已经加载了这个类就不再加载.</p><p>如果在自己的缓存中没有找到, 并不会直接将类加载到内存, 而是向他的父加载器发出请求, 查询这个类有没有加载, 如果还是没有, 继续向上.</p><p>如果一直到Bootstrap都没找到, 就确认是没有加载进内存, 开始实际加载.</p><p>Bootstrap在他的加载路径上找不到这个类, 由他的子加载器加载, 扩展类加载器也找不到, 继续向下加载. </p><p>直到加载请求传到相应的类加载器, 这个class文件才会被加载到内存.</p><p>如果一直到最后都没有加载到这个class, 就会抛出 ClassNotFoundException.</p><p>这就是<code>双亲委派机制</code></p><p>这样做的目的是为了安全考虑.</p><p>如果我们自己写了一个 <code>java.lang.String</code>类, 并且成功的被加载进去了. 那我们有可能在这个类中做一些危险操作.</p><p>因此拿到一个class的时候先向上问问这个class是否已经被加载过了.</p><p><strong>父加载器不是类加载器的加载器</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Test02<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Test02<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Test02<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Test02<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出:</p><pre><code>sun.misc.Launcher$AppClassLoader@18b4aac2nullsun.misc.Launcher$ExtClassLoader@76ed5528null</code></pre><p>我们自己写的类是由AppClassLoader加载的,  AppClassLoader的父加载器是ExtClassLoader.</p><p>而AppClassLoader是由Bootstrap加载的.</p><h4 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h4><p>在刚刚的打印中, AppClassLoader和ExtClassLoader都是sun.misc.Launcher内的一个内部类.</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Bootstrap</span><span class="token keyword">private</span> <span class="token keyword">static</span> String bootClassPath <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"sun.boot.class.path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ext</span>String var0 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"java.ext.dirs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//App</span><span class="token keyword">final</span> String var1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"java.class.path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以打印出这些来看看到底哪个加载器加载了哪些jar包</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String pathBoot <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"sun.boot.class.path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pathBoot<span class="token punctuation">)</span><span class="token punctuation">;</span>    String pathExt <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"java.ext.dirs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pathExt<span class="token punctuation">)</span><span class="token punctuation">;</span>    String pathApp <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"java.class.path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pathApp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ClassLoader.java</span><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>    <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 加锁, 以防加载一半又加载一遍</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先查看是否已经加载进来了</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果没有被加载进来, 开始加载</span>            <span class="token keyword">long</span> t0 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 调用parent加载</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 经过上面父加载器去加载之后, 查询是否已经被加载</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果还没被加载, 说明父加载器没找到</span>                <span class="token keyword">long</span> t1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 调用findClass方法</span>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// this is the defining class loader; record the stats</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ClassLoader.java</span><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ClassLoader中直接抛出一个异常, 留给子类重写</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>因此如果自定义类加载器, 继承ClassLoader, 并且重写findClass方法, 在这个方法中, 读取class文件, 并调用defindClass方法转成class对象.</p><h4 id="lazyloading"><a href="#lazyloading" class="headerlink" title="lazyloading"></a>lazyloading</h4><p>java的懒加载, 严格讲应该叫 lazyInitializing</p><p>JVM规范并没有规定何时加载</p><p>但是严格规定了什么时候必须初始化</p><ul><li>new getstatic putstatic invokestatic指令, 访问final变量除外</li><li>java.lang.reflect对类进行反射调用时</li><li>初始化子类的时候, 父类首先初始化</li><li>虚拟机启动时,被执行的主类必须初始化</li><li>动态语言支持java.lang.inoke.MethodHandle解析的结果为REF_getstatic REF_putstatic REF_invokestatic的方法句柄时, 该类必须初始化</li></ul><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>默认是混合模式</p><ul><li><p>解释器</p><ul><li>bytecode intepreter</li></ul></li><li><p>JIT</p><ul><li>Just In-Time compiler</li></ul></li><li><p>混合模式</p><ul><li>混合使用解释器+热点代码编译</li><li>起始阶段采用解释执行</li><li>热点代码检测<ul><li>多次被调用的方法 (方法计数器: 检测方法执行频率)</li><li>多次被调用的循环 (循环计数器: 检测循环执行频率)</li><li>进行编译</li><li>-Xmixed 默认为混合模式 开始解释执行, 启动速度较快, 对热点代码实行检测和编译</li><li>-Xint 使用编译模式, 启动很快,执行稍慢</li><li>-XComp 使用纯编译模式, 执行很快, 启动很慢</li></ul></li></ul></li></ul><h4 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h4><p>因为双亲委派机制是在ClassLoader中的loadClass方法中已经完成了的, 所以要想打破这个机制可以重写loadClass方法.</p><p><strong>什么时候发生过打破双亲委派机制</strong></p><ol><li>JDK1.2之前, 自定义ClassLoader都必须重写loadClass</li><li>ThreadContextClassLoader可以实现基础类调用实现类代码, 通过thread.setContextClassLoader指定</li><li>热启动, 热部署<ol><li>osgi tomcat都有自己的模块指定classloader(可以加载统一类库的不同版本)</li></ol></li></ol><h3 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h3><h4 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h4><p>验证文件是否符合JVM规定</p><h4 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h4><p>把class文件的静态变量赋默认值</p><h4 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a>Resolution</h4><p>在ClassLoader的loadClass中, 有一个布尔值, 这个代表是否进行解析</p><p>这个节点就是将类, 方法, 属性等符号引用解析为直接引用</p><p>常量池汇总的各种符号引用解析为指针, 偏移量等内存地址的直接饮用</p><h3 id="Initializing"><a href="#Initializing" class="headerlink" title="Initializing"></a>Initializing</h3><p>调用类初始化代码<clinit>, 给静态成员变量赋初始值</clinit></p><p>解析阶段先看一道题:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test05</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> T t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        count <span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出是什么.</p><p>通过运行得知, 输出为3.</p><p>如果将T类中的两个static调换一下位置</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test05</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> T t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        count <span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出就变成了2.</p><p>为什么呢?</p><p>根据我们之前说的类加载过程, 在Linking的Preparation阶段, </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> T t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>会给count和t赋默认值, int的默认值是0, t的默认值是null</p><p>再到Initializing阶段, 会给静态变量赋初值,  count的值赋为2, t的值调构造方法, 对count++. 所以count为3.</p><p>如果两句反过来,</p><p>在Preparation阶段, t的null, count是0</p><p>再到Initializing阶段, 先对t赋值, 调用构造方法, count++ 此时count为1.</p><p>再对count赋初值, count为2.</p><h4 id="关于指令重排"><a href="#关于指令重排" class="headerlink" title="关于指令重排"></a>关于指令重排</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test06</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test06 t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test06</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>就这么简单的一个例子</p><p>我们去查看他的二进制文件,查看他在main方法处做了什么</p><pre><code>0 new #2 &lt;com/echi/jvm/day01/Test06&gt;3 dup4 invokespecial #3 &lt;com/echi/jvm/day01/Test06.&lt;init&gt;&gt;7 astore_18 return</code></pre><p>首先在0处申请了内存</p><p>4处调用构造方法, 7是把调用构造方法 完成初始化的这块内存赋值给 t.</p><p>在4和7处, 有可能会发生指令重排. 如果7先发生, 就是先把内存地址放到t中了, 其他线程可能就会获取出问题.</p><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="硬件层的并发优化基础知识"><a href="#硬件层的并发优化基础知识" class="headerlink" title="硬件层的并发优化基础知识"></a>硬件层的并发优化基础知识</h3><h4 id="存储区的层次结构"><a href="#存储区的层次结构" class="headerlink" title="存储区的层次结构"></a>存储区的层次结构</h4><ol><li>L0: 寄存器 </li><li>L1:高速缓存</li><li>L2:高速缓存</li><li>L3:高速缓存</li><li>L4:主存</li><li>L5:磁盘</li><li>L6:远程文件存储</li></ol><p>寄存器是最快的, 往下依次速度慢下来.</p><h4 id="cache-line"><a href="#cache-line" class="headerlink" title="cache line"></a>cache line</h4><p>缓存行对齐  伪共享</p><p><img src="/2020/07/07/2020-07-07/%E7%BC%93%E5%AD%98%E8%A1%8C.jpg" alt></p><p>L1和L2都是在CPU的每个核内的, 也就是说, 如果x在第一个计算单元中被改成1 , 在第二个计算单元中被改成2, 这种不一致会如何处理.</p><p><strong>总线锁</strong></p><p>当操作一个数据的时候, 可以通过对总线加锁的方式防止同时访问.</p><p>这种方式效率太低, 如果一个CPU访问x, 把总线上锁之后, 另一个CPU访问y, 也要进行等待.</p><p><strong>一致性协议</strong></p><p>一般都会说MESI协议, 这是IntelCPU会用的协议, 其他品牌的CPU用的是其他一致性协议.</p><p>MESI其实是四种状态 Modified, Exclusive, Shared, Invalid.</p><ul><li>Modified 在当前CPU修改过</li><li>Exclusive 独占, 只有一个CPU在用</li><li>Shared 多个CPU同时在用</li><li>Invalid 如果这个值被其他CPU修改过.</li></ul><p>通过该协议对多个CPU之间的缓存保持一致性</p><p>比如如果发现自己用的值已经是Invalid状态, 就再去内存读一次.</p><p>MESI叫做缓存锁, 原来的总线锁依然存在.</p><p>有些无法被缓存的数据, 或者跨越多个缓存行的数据, 依然必须使用总线锁</p><p>所以现代CPU数据一致性的实现是由缓存锁+总线锁共同实现的.</p><p><strong>缓存行</strong></p><p>对于一个数据, 如果想要读取他, 不会单纯的只读取这一个数据, 而是会读取他所在的这一个缓存行.</p><p>这个缓存行多数是64字节大小.</p><p>现在有一个场景, 两颗CPU, CPU1使用x, CPU2使用y, x和y放在同一个缓存行上.</p><p>那么, 当CPU1修改x之后会将整个缓存行修改回去, 而CPU2读取到的x和y都会变成Invalid.</p><p>但是CPU2本身不需要收到x的失效信息, CPU1也不会对y进行更改.</p><p>这种被叫做伪共享.</p><p>位于同一缓存行的两个不同数据. 被两个不同CPU锁定, 产生互相影响的伪共享问题.</p><p><strong>缓存行对齐</strong></p><p>前面提过这个, 使用几个额外的变量将缓存行补齐, 保证共享的变量不在同一个缓存行上.</p><h4 id="乱序问题"><a href="#乱序问题" class="headerlink" title="乱序问题"></a>乱序问题</h4><p><img src="/2020/07/07/2020-07-07/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C.jpg" alt></p><p>CPU在执行的时候, 如果发现指令1要去内存中读数据. </p><p>因为CPU的速度是相当快的, 比内存快100倍.</p><p>所以CPU回去分析下面几条指令, 是否有指令不依赖于指令1的.</p><p><strong>合并写</strong></p><p>CPU在L1高速缓存之前 还有一个WCBuffer, Writing Comblining 合并写.</p><p>合并写的容量非常小, 只有4个字节. </p><p>当CPU写入L1的时候, 使用WCBuffer写入L2.</p><p><strong>证明乱序</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test06</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            Thread one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    x <span class="token operator">=</span> b<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    y <span class="token operator">=</span> a<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            one<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>two<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            one<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>two<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String result <span class="token operator">=</span> <span class="token string">"第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"次 ( "</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> y <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>简单分析一下, 两个线程同时开始.</p><p>a,b分别赋值, 再把值赋值给x和y.</p><p>如果t1先执行, a=1, 此时有两种情况, t2插入进来, b=1先执行. 此时结果为 (1,1)</p><p>如果t1没有被打断, 此时x=0,结果为 (0, 1).</p><p>如果t2先执行, b=1, 此时也是两种情况, 结果分别为 (1,1)和(1,0).</p><p>但是有没有可能会出现 (0,0)呢.</p><p>如果是顺序执行, 确实不可能出现 (0,0), 因为x,y想要完成赋值必须要经过a=1或者b=1 或者a,b都等于1.</p><pre><code>第209511次 ( 0, 0)</code></pre><p>但是结果显示, 在数次循环之后, 确实打印出了 (0,0)这种情况.</p><p>因此证明了CPU的乱序执行是存在的.</p><h4 id="如何解决乱序问题"><a href="#如何解决乱序问题" class="headerlink" title="如何解决乱序问题"></a>如何解决乱序问题</h4><p>我们之前提到volatile可以禁止指令重排序.</p><p><strong>CPU层面</strong></p><p>在CPU层面使用的是内存屏障来防止指令重排序.</p><p><strong>内存屏障</strong></p><p>拿IntelCPU来说,有三条指令.</p><p>sfence:在sfence指令前的写操作当必须在sfence指令后的写操作前完成</p><p>lfence:在lfence指令前的读操作必须在lfence指令后的读操作前完成.</p><p>mfence:在mfence指令前的读写操作必须在mfence指令后的读写操作前完成.</p><p><img src="/2020/07/07/2020-07-07/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.jpg" alt></p><p>如上图, 在两条写指令中间加入一道sfence, 保证写指令1执行完之后写指令2才能执行.</p><p><strong>原子指令</strong></p><p>如x86上的”lock …”指令是一个Full Barrier, 执行时会锁住内存子系统来确保执行顺序, 甚至跨多个CPU.</p><p>Sofeware Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序.</p><p><strong>JVM级别如何规范</strong></p><p>LoadLoad屏障:</p><p>​    对于这样的语句 Load1; LoadLoad; Load2,</p><p>​    在Load2及后续读取操作要读取的数据被访问前, 保证Load1要读取的数据被读取完毕.</p><p>StoreStore屏障:</p><p>​    对于这样的语句 Store1; StoreStore; Store2.</p><p>​    在Store及后续写入操作执行前, 保证Store1的写入操作对其他处理器可见.</p><p>LoadStore屏障:</p><p>​    对于这样的语句 Load1; LoadStore; Store2</p><p>​    在Store2及后续写入操作被刷出前, 保证Load1要读取的数据被读取完毕.</p><p>StoreLoad屏障:</p><p>​    对这样的语句 Store1; StoreLoad; Load2</p><p>​    在Load2及后续所有读取操作执行前, 保证Store1的写入对所有处理器可见.</p><h3 id="volatile的实现细节"><a href="#volatile的实现细节" class="headerlink" title="volatile的实现细节"></a>volatile的实现细节</h3><ol><li><p>字节码层面</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test07</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对这个类编译后查看他的class文件,</p><p><img src="/2020/07/07/2020-07-07/volatile%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2.jpg" alt></p><p>volatile在字节码层面时, Access flags变为0x0040 , 标记为volatile</p></li><li><p>JVM层面</p><p><img src="/2020/07/07/2020-07-07/volatile%E5%9C%A8JVM%E5%B1%82%E9%9D%A2.jpg" alt></p><p>在JVM层面, 对于所有的volatile</p><p>在写操作前面加上 StoreStoreBarrier, 在写操作后面加上 StoreLoadBarrier.</p><p>在读操作前面加上 LoadLoadBarrier, 在读操作后面加上 LoadStoreBarrier.</p></li><li><p>OS和硬件层面</p><p>windows是使用lock指令实现的.</p></li></ol><h3 id="Synchronized的实现细节"><a href="#Synchronized的实现细节" class="headerlink" title="Synchronized的实现细节"></a>Synchronized的实现细节</h3><ol><li><p>字节码层面</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test08</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对这个类编译后查看他的class文件,</p><p><img src="/2020/07/07/2020-07-07/Synchronized%E5%AD%97%E8%8A%82%E7%A0%81%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95.jpg" alt></p><p>synchronized修饰的方法在字节码层面时, Access flags变为0x0020 , 标记为synchronized</p><p><img src="/2020/07/07/2020-07-07/Synchronized%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97.jpg" alt></p><p>同步代码块会使用monitorenter和moniterexit.</p><p>而下面还有一个monitorexit, 是当产生异常的时候, 会自动退出.</p></li><li><p>JVM层面</p><p>C C++调用了操作系统提供的同步机制</p></li><li><p>OS和硬件层面</p><p>x86: lock comxchg xxxxx</p></li></ol><h3 id="Java8大原子操作-虚拟机规范"><a href="#Java8大原子操作-虚拟机规范" class="headerlink" title="Java8大原子操作(虚拟机规范)"></a>Java8大原子操作(虚拟机规范)</h3><p>(已弃用)</p><p>最新的JSR-133已经放弃这种描述, 但是JMM没有变化</p><ul><li>lock: 主内存, 标识变量为线程独占</li><li>unlock: 主内存, 解锁线程独占变量</li><li>read: 主内存, 读取内容到工作内存</li><li>load: 工作内存, read后的值放入线程本地变量副本</li><li>use: 工作内存, 传值给执行引擎</li><li>assign: 工作内存, 执行引擎结果赋值给线程本地变量</li><li>store: 工作内存, 存值到主内存给write备用</li><li>write: 主内存, 写变量值</li></ul><h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h3><p>JVM规定重排序必须遵守的规则</p><ul><li>程序次序规则: 同一个线程内, 按照代码出现的顺序, 前面的代码先行与后面的代码, 准确的说是控制流顺序, 因为要考虑到分支和循环结构.</li><li>管程锁定规则: 一个unlock操作先行发生于后面(时间上)对同一个锁的lock操作.</li><li>volatile变量规则: 对一个volatile变量的写操作先行发生于后面(时间上)对这个变量的读写操作.</li><li>线程启动规则: Thread的start()方法先行发生于这个线程的每一个操作.</li><li>线程终止规则: 线程的所有操作都先行与此线程的终止检测. 可以通过Thread.join()方法结束, Thread.isAlive()的返回值等手段检测线程的终止.</li><li>线程中断规则: 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生, 可以通过Thread.interrupt()方法检测线程是否中断.</li><li>对象终结规则: 一个对象的初始化完成先行于发生它的finalize()方法的开始.</li><li>传递性: 如果操作A先行于操作B, 操作B先行于操作C, 那么操作A先行于操作C.</li></ul><p>as if serial 不管如何重排序, 单线程执行结果不会改变.</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><h3 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h3><ol><li>class loading</li><li>class linking(verification, preparation, resolution)</li><li>class initializing</li><li>申请对象内存</li><li>成员变量赋默认值</li><li>调用构造方法<init><ol><li>成员变量顺序赋初始值</li><li>执行构造方法语句</li></ol></init></li></ol><p>如果class还没load到内存, 需要先做前面提过的将class加载到内存.</p><p>在class加载到内存之后, 需要先申请内存, 然后将成员变量赋默认值 int是0,boolean是false.</p><p>然后调用构造方法, 这个构造方法讲的是字节码中的<init>方法, 比如成员变量 int i = 4; 会先将i赋值为4, 再去执行java代码中写的构造方法中的语句.</init></p><h3 id="对象在内存中的存储布局"><a href="#对象在内存中的存储布局" class="headerlink" title="对象在内存中的存储布局"></a>对象在内存中的存储布局</h3><h4 id="查看JVM启动参数"><a href="#查看JVM启动参数" class="headerlink" title="查看JVM启动参数"></a>查看JVM启动参数</h4><p>java -XX:+PrintCommandLineFlags -version</p><pre><code>-XX:InitialHeapSize=132847360 -XX:MaxHeapSize=2125557760 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</code></pre><h4 id="对象大小"><a href="#对象大小" class="headerlink" title="对象大小"></a>对象大小</h4><p><strong>普通对象</strong></p><ol><li><p>对象头: markword 8</p></li><li><p>ClassPointer指针: -XX:+UseCompressedClassPointers 为4字节, 不开启为8字节 开启内存压缩</p></li><li><p>实例数据</p><ol><li><p>引用类型: -XX:UseCompressedOops 为4字节, 不开启为8字节 开启内存压缩</p><p>Oops Ordinary Object Pointers</p></li></ol></li><li><p>Padding对齐, 8的倍数</p></li></ol><p><strong>数组对象</strong></p><ol><li>对象头: markword 8</li><li>数组长度: 4字节</li><li>数组数据</li><li>对齐</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test04</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// markword 8</span>                    <span class="token comment" spellcheck="true">// class pointer 4</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4</span>    String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4</span>    <span class="token keyword">int</span> sex<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4</span>    <span class="token keyword">byte</span> b1<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1</span>    <span class="token keyword">byte</span> b2<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1</span>    Object object<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4</span>    <span class="token keyword">byte</span> b3<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1</span>                    <span class="token comment" spellcheck="true">// padding 1</span><span class="token punctuation">}</span></code></pre><p>上面这个对象的大小就是 8+4+4+4+1+1+4+1+1 = 24字节.</p><p><strong>HotSpot开启内存压缩的规则(64位)</strong></p><ol><li>4G以下, 直接砍掉高32位</li><li>4G - 32G, 默认开启内存压缩 ClassPointers Oops</li><li>32G, 压缩无效, 使用64位</li></ol><p>内存并不是越大越好</p><h3 id="对象头具体包括什么"><a href="#对象头具体包括什么" class="headerlink" title="对象头具体包括什么"></a>对象头具体包括什么</h3><h4 id="markword结构"><a href="#markword结构" class="headerlink" title="markword结构"></a>markword结构</h4><pre><code>32 bits:--------hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)size:32 ------------------------------------------&gt;| (CMS free block)PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)64 bits:--------unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)size:64 -----------------------------------------------------&gt;| (CMS free block)unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)[ptr             | 00]  locked             ptr points to real header on stack[header      | 0 | 01]  unlocked           regular object header[ptr             | 10]  monitor            inflated lock (header is wapped out)[ptr             | 11]  marked             used by markSweep to mark an object</code></pre><p><img src="/2020/07/07/2020-07-07/markword.png" alt></p><p>markwrod在对象不同的状态表示的意义也是不同的.</p><p>当对象处于无锁态的时候, 使用后3位表示锁状态, 前25位表示hashCode, 如果没有重写过hashCode, 会根据对象的内存地址算出一个.或者调用System.identityHashCode时, 会产生hashCode.</p><p>在对象不同的状态时, 最后2位锁标志位是不一样的, GC时也会用到锁.</p><p>因为分代年龄只有4位, 因此GC年龄默认是15 且最大是15.</p><h4 id="对象定位"><a href="#对象定位" class="headerlink" title="对象定位"></a>对象定位</h4><ol><li><p>句柄池</p><p>句柄池就是 当 T t = new T(); 对象new出来之后, t指向两个指针, 一部分指向实例对象的内存, 另一部分指向T.class.</p></li><li><p>直接指针</p><p>直接指针是指, 当对象new出来之后, 指向实例对象, 实例对象指向T.class.</p></li></ol><p>HotSpot使用的就是直接指针,</p><h2 id="Runtime-Data-Area"><a href="#Runtime-Data-Area" class="headerlink" title="Runtime Data Area"></a>Runtime Data Area</h2><h4 id="PC-程序技术器"><a href="#PC-程序技术器" class="headerlink" title="PC 程序技术器"></a>PC 程序技术器</h4><p>program counter</p><p>存放指令</p><p>虚拟机的运行, 类似于这样的循环:</p><p>while( not end ){</p><p>​    取PC中的位置, 找到对应位置的指令;</p><p>​    执行该指令;</p><p>​    PC++;    </p><p>}</p><h4 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h4><p>每个线程都独有一个站, 和线程一起创建.</p><p>栈中存储的是栈帧.</p><h4 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap 堆"></a>Heap 堆</h4><p>堆在线程中共享</p><h4 id="Method-Area-方法区"><a href="#Method-Area-方法区" class="headerlink" title="Method Area 方法区"></a>Method Area 方法区</h4><p>方法区在线程中共享.</p><p>存储的是class.</p><p>在Java8之前, 方法区的实现叫Perm Space永久区, 字符串常量位于Perm Space, FGC不会清理. 大小启动时指定.</p><p>在Java8之后, 方法区的实现叫Meta Space元空间, 字符串常量位于堆, FGC会清理. 大小不指定的话最大就是物理内存.</p><h4 id="Run-Time-Constant-Pool"><a href="#Run-Time-Constant-Pool" class="headerlink" title="Run-Time Constant Pool"></a>Run-Time Constant Pool</h4><p>运行时常量池是在每个class或者interface文件中的常量池.</p><h4 id="Native-Method-Stacks"><a href="#Native-Method-Stacks" class="headerlink" title="Native Method Stacks"></a>Native Method Stacks</h4><p>当调用到本地方法的时候, 会用到本地方法栈, 和java的栈类似.</p><blockquote><p> 每个线程有自己的程序计数器, 栈和本地方法栈. 所有线程都共享一个堆和方法区.</p></blockquote><h4 id="Frame-栈帧"><a href="#Frame-栈帧" class="headerlink" title="Frame 栈帧"></a>Frame 栈帧</h4><p>前面说过, 栈中存储的是一个个的栈帧, 而栈帧中存储的有四部分内容.</p><ul><li><p>局部变量</p></li><li><p>操作数栈</p></li><li><p>动态链接</p><blockquote><p>动态链接指的是运行时常量池中对应的记录. 如果还没解析, 就进行动态解析, 然后拿来使用.</p></blockquote></li><li><p>返回地址</p><blockquote><p>返回值地址就是方法结束之后, 应该回到哪个地方.</p></blockquote></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test09</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        i <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// i = ++i;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>先看一道题, 这个输出是多少.</p><p>输出是0.</p><p>但是为什么会这样, 可以很清楚的看到已经做了i++操作.</p><p>我们去看他的二进制文件,</p><pre><code>// main 方法编译后的 0 iconst_0 1 istore_1 2 iload_1 3 iinc 1 by 1 6 istore_1 7 getstatic #2 &lt;java/lang/System.out&gt;10 iload_111 invokevirtual #3 &lt;java/io/PrintStream.println&gt;14 return</code></pre><p><img src="/2020/07/07/2020-07-07/%E6%A0%88%E5%B8%A7%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.jpg" alt="局部变量表"></p><p>局部变量表中0代表String[] args, 1代表int i;</p><pre class=" language-java"><code class="language-java"> <span class="token number">0</span> iconst_0        <span class="token comment" spellcheck="true">// 将0压入操作数栈</span> <span class="token number">1</span> istore_1        <span class="token comment" spellcheck="true">// 将操作数栈栈顶出栈, 放到局部变量表1的位置 即i的位置</span> <span class="token number">2</span> iload_1        <span class="token comment" spellcheck="true">// 将局部变量表1位置的值load到操作数栈</span> <span class="token number">3</span> iinc <span class="token number">1</span> by <span class="token number">1</span>    <span class="token comment" spellcheck="true">// 将局部变量表1位置的值加1</span> <span class="token number">6</span> istore_1        <span class="token comment" spellcheck="true">// 将操作数栈的栈顶出栈, 放到局部变量表1的位置</span> <span class="token number">7</span> getstatic #<span class="token number">2</span> <span class="token operator">&lt;</span>java<span class="token operator">/</span>lang<span class="token operator">/</span>System<span class="token punctuation">.</span>out<span class="token operator">></span><span class="token number">10</span> iload_1<span class="token number">11</span> invokevirtual #<span class="token number">3</span> <span class="token operator">&lt;</span>java<span class="token operator">/</span>io<span class="token operator">/</span>PrintStream<span class="token punctuation">.</span>println<span class="token operator">></span><span class="token number">14</span> <span class="token keyword">return</span></code></pre><p>从3和6我们可以看出, i++是直接在局部变量表中做的自增, 而 i=i++ 做的是先将i的值挪到操作数栈, 在i自增之后, 又将操作数栈中没有自增的值放了回来, 这样就导致了i++的结果丢失.</p><p>那么如果++i呢?</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test09</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        i = i++;</span>        i <span class="token operator">=</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果是9.</p><pre><code> 0 bipush 8 2 istore_1 3 iinc 1 by 1 6 iload_1 7 istore_1 8 getstatic #2 &lt;java/lang/System.out&gt;11 iload_112 invokevirtual #3 &lt;java/io/PrintStream.println&gt;15 return</code></pre><p>可以看到 在++i中, iinc 1 by 1这次放到了istroe_1前面, 因此这次的操作就是先自增, 再放到操作数栈, 然后将操作数栈中的数放回局部变量表.</p><h4 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h4><p><clinit> class init 类的初始化方法</clinit></p><p><init> 实例的初始化方法</init></p><p>invokexxxx</p><ul><li>invokeStatic 调用静态方法</li><li>invokeVirtual 自带多态的调用</li><li>invokeInterface 通过interface调用的.</li><li>invokeSpecial 可以直接定位的, 不需要多态的 (private方法, 构造方法)</li><li>invokeDynamic 动态的class lambda表达式, 或者反射或者其他动态语言</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发(四)</title>
      <link href="/2020/07/06/2020-07-06/"/>
      <url>/2020/07/06/2020-07-06/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程与高并发-四"><a href="#多线程与高并发-四" class="headerlink" title="多线程与高并发(四)"></a>多线程与高并发(四)</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>执行者, 有一个方法 execute().</p><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>继承自Executor, 也是一个接口.</p><p>除了execute()方法之外, 还完善了整个任务执行器的生命周期.</p><p>shutdown() 结束, </p><p>shutdownNow() 立刻结束, </p><p>isShutdown()是否已经结束</p><p>isTerminated()是否已经执行完了</p><p>awaitTermination(long timeout, TimeUnit unit)等待xx时间</p><h3 id="Callable-amp-Future"><a href="#Callable-amp-Future" class="headerlink" title="Callable&amp;Future"></a>Callable&amp;Future</h3><p>除此之外, ExecutorService中还有一个Future<t> submit(Callable<t> task)方法.</t></t></p><p>在java1.5的时候添加了一个叫Callable的接口, 为了解决Runnable没有返回值的情况.</p><p>同时还添加了一个Future接口, 在Callable执行完之后, 结果会封装到Future中.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>    Callable<span class="token operator">&lt;</span>String<span class="token operator">></span> call <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Hello Callable"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    ExecutorService service <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Future<span class="token operator">&lt;</span>String<span class="token operator">></span> future <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>call<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// future.get() 方法是阻塞的,阻塞直到获取到线程的返回值</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>还有一个类叫做FutureTask, 他可以既当Future又当Task.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>    FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在FutureTask类中, 实现了RunnableFuture接口, 而Runnable接口又继承了Runnable和Future.</p><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>CompletableFuture可以用来管理多个Future.</p><pre><code>public class Test03 {   public static void main(String[] args) {      CompletableFuture&lt;Double&gt; futureTB = CompletableFuture.supplyAsync(() -&gt; priceOfTB());      CompletableFuture&lt;Double&gt; futureJD = CompletableFuture.supplyAsync(() -&gt; priceOfJD());      CompletableFuture&lt;Double&gt; futurePDD = CompletableFuture.supplyAsync(() -&gt; priceOfPDD());      CompletableFuture.allOf(futureTB, futureJD, futurePDD).join();   }   public static double priceOfTB() {      try {         Thread.sleep(100);      } catch (InterruptedException e) {         e.printStackTrace();      }      return 1.0;   }   public static double priceOfJD() {      try {         Thread.sleep(200);      } catch (InterruptedException e) {         e.printStackTrace();      }      return 2.0;   }   public static double priceOfPDD() {      try {         Thread.sleep(300);      } catch (InterruptedException e) {         e.printStackTrace();      }      return 3.0;   }}</code></pre><p> 比如以上例子就是使用CompletableFuture来使多个Future都完成才继续.</p><p>也可以使用他的其他方法对返回值进行操作.</p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>ThreadPoolExecutor是继承自AbstractExecutorService, 这是一个抽象类, 实现了ExecutorService接口.</p><p>在阿里代码规约中是禁止手动new Thread来开启多线程的, 也禁止使用Executors来创建线程池.</p><p>推荐的方法是使用ThreadPoolExecutor来手动创建一个线程池.</p><p>ThreadPoolExecutor的构造方法有七大参数</p><pre class=" language-java"><code class="language-java">ThreadPoolExecutor tpe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>    <span class="token comment" spellcheck="true">// 核心线程数</span>    <span class="token number">2</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">// 最大线程数</span>    <span class="token number">4</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 生存时间</span>    <span class="token number">60</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">//生存时间单位</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 任务队列</span>    <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 线程工厂</span>    Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 拒绝策略</span>    <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>DiscardOldestPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>核心线程数  <ul><li>线程池一创建出来就会有一些核心线程</li></ul></li><li>最大线程数<ul><li>当任务处理不过来, 线程池能扩展到的最大线程数</li></ul></li><li>生存时间<ul><li>线程如果长时间不工作, 就会将线程关闭</li></ul></li><li>生存时间单位</li><li>任务队列<ul><li>阻塞队列 可以放入各种各样的BlockingQueue</li></ul></li><li>线程工厂<ul><li>传入一个ThreadFactory  可以设置ThreadFactory生产线程的名字</li><li>线程的名字非常重要, 如果线程没有自定义名字, 当发现线程出问题的之后, 面对 pool-1-thread-1这种名字无从寻找问题.</li></ul></li><li>拒绝策略<ul><li>当线程池中的线程都在忙, 阻塞队列满了, 而且线程池已经到达最大线程数的时候, 就会启动拒绝策略.</li><li>JDK提供了默认四种拒绝策略. 也可以自定义.</li><li>AbortPolicy 抛异常</li><li>DiscardPolicy 扔掉, 不抛异常</li><li>DiscardOldestPolicy 扔掉排队时间最久的</li><li>CallerRunsPolicy 调用者处理</li></ul></li></ul><h3 id="线程池工厂-Executors"><a href="#线程池工厂-Executors" class="headerlink" title="线程池工厂 Executors"></a>线程池工厂 Executors</h3><p>Executors可以说是线程池的工厂, 是用来产生线程池的.</p><ol><li><p>newSingleThreadExecutor()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>创建一个只有一个线程的线程池, 为什么要有这种一个线程的线程池? 只想要一个线程直接new Thread不就行了吗 ?</p><p>线程池中不光有线程, 还维护了任务队列, 如果自己new Thread就要自己维护这个任务队列. 而且线程池还可以维护生命周期.</p><p>但是, 这个线程池是有问题的, 他的线程任务队列是LinkedBlockingQueue, 默认给的最大长度是Integer.MAX_VALUE. 这是一个非常危险的行为, 如果线程处理不过来, 导致任务越积越多, 可能会导致任务队列真的存放这么多任务最终导致OOM.</p></li><li><p>newCachedThreadPool()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                  60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从参数中可以看出来, cachedThreadPool核心线程数是0, 最大线程数是Integer.MAX_VALUE, 而且任务队列是0.</p><p>如果线程池中没有空闲线程, 就会起一个新的线程来执行这个任务. </p><p>这显然也是有问题的, 如果同时大量的任务打过来很有可能会导致开启过多线程.而过多的线程可能会导致CPU的资源都耗费在线程切换上了.</p></li><li><p>newFixedThreadPool(int nThreads)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                  0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>创建一个固定线程数的线程池, 这个线程池和SingleThreadExecutor的问题一样, 都是任务队列太长, 可能会导致OOM.</p></li><li><p>newScheduledThreadPool(int corePoolSize)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>定时器任务, 这个线程池和cachedThreadPool的问题是一样的, 最大线程数量太大.</p></li></ol><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并发: concurrent</p><p>并行: parallel </p><p>并发指任务提交, 并行指任务执行.</p><p>并行是并发的子集.</p><h3 id="ThreadPoolExecutor源码解析"><a href="#ThreadPoolExecutor源码解析" class="headerlink" title="ThreadPoolExecutor源码解析"></a>ThreadPoolExecutor源码解析</h3><h4 id="1、常用变量的解释"><a href="#1、常用变量的解释" class="headerlink" title="1、常用变量的解释"></a>1、常用变量的解释</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量</span><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// runState is stored in the high-order bits</span><span class="token comment" spellcheck="true">// 4. 线程池有5种状态，按大小排序如下：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Packing and unpacking ctl</span><span class="token comment" spellcheck="true">// 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* * Bit field accessors that don't require unpacking ctl. * These depend on the bit layout and on workerCount being never negative. */</span><span class="token comment" spellcheck="true">// 8. `runStateLessThan()`，线程池状态小于xx</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">runStateLessThan</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> c <span class="token operator">&lt;</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 9. `runStateAtLeast()`，线程池状态大于等于xx</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> c <span class="token operator">>=</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 基本类型参数校验</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 空指针校验</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="3、提交执行task的过程"><a href="#3、提交执行task的过程" class="headerlink" title="3、提交执行task的过程"></a>3、提交执行task的过程</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn't, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// worker数量比核心线程数小，直接创建worker执行任务</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// worker数量超过核心线程数，任务直接进入队列</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。</span>        <span class="token comment" spellcheck="true">// 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。</span>    <span class="token comment" spellcheck="true">// 这儿有3点需要注意：</span>    <span class="token comment" spellcheck="true">// 1. 线程池不是运行状态时，addWorker内部会判断线程池状态</span>    <span class="token comment" spellcheck="true">// 2. addWorker第2个参数表示是否创建核心线程</span>    <span class="token comment" spellcheck="true">// 3. addWorker返回false，则说明任务执行失败，需要执行reject操作</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="4、addworker源码解析"><a href="#4、addworker源码解析" class="headerlink" title="4、addworker源码解析"></a>4、addworker源码解析</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>    retry<span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 外层自旋</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价</span>        <span class="token comment" spellcheck="true">// (rs > SHUTDOWN) || </span>        <span class="token comment" spellcheck="true">// (rs == SHUTDOWN &amp;&amp; firstTask != null) || </span>        <span class="token comment" spellcheck="true">// (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span>        <span class="token comment" spellcheck="true">// 1. 线程池状态大于SHUTDOWN时，直接返回false</span>        <span class="token comment" spellcheck="true">// 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false</span>        <span class="token comment" spellcheck="true">// 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false</span>        <span class="token comment" spellcheck="true">// Check if queue empty only if necessary.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>               firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>               <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 内层自旋</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// worker数量超过容量，直接返回false</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>                wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 使用CAS的方式增加worker数量。</span>            <span class="token comment" spellcheck="true">// 若增加成功，则直接跳出外层循环进入到第二部分</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Re-read ctl</span>            <span class="token comment" spellcheck="true">// 线程池状态发生变化，对外层循环进行自旋</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 其他情况，直接内层循环进行自旋即可</span>            <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// worker的添加必须是串行的，因此需要加锁</span>            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Recheck while holding lock.</span>                <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span>                <span class="token comment" spellcheck="true">// shut down before lock acquired.</span>                <span class="token comment" spellcheck="true">// 这儿需要重新检查线程池状态</span>                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                    <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// worker已经调用过了start()方法，则不再创建worker</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// worker创建并添加到workers成功</span>                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 更新`largestPoolSize`变量</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 启动worker线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="5、线程池worker任务单元"><a href="#5、线程池worker任务单元" class="headerlink" title="5、线程池worker任务单元"></a>5、线程池worker<strong>任务单元</strong></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>    <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * This class will never be serialized, but we provide a     * serialVersionUID to suppress a javac warning.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6138294804551838833L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Thread this worker is running in.  Null if factory fails. */</span>    <span class="token keyword">final</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Initial task to run.  Possibly null. */</span>    Runnable firstTask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Per-thread task counter */</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Creates with given first task and thread from ThreadFactory.     * @param firstTask the first task (null if none)     */</span>    <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Delegates main run loop to outer runWorker  */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 省略代码...</span><span class="token punctuation">}</span></code></pre><h4 id="6、核心线程执行逻辑-runworker"><a href="#6、核心线程执行逻辑-runworker" class="headerlink" title="6、核心线程执行逻辑-runworker"></a>6、核心线程执行逻辑-runworker</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用unlock()是为了让外部可以中断</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token comment" spellcheck="true">// 这个变量用于判断是否进入过自旋（while循环）</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这儿是自旋</span>        <span class="token comment" spellcheck="true">// 1. 如果firstTask不为null，则执行firstTask；</span>        <span class="token comment" spellcheck="true">// 2. 如果firstTask为null，则调用getTask()从队列获取任务。</span>        <span class="token comment" spellcheck="true">// 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这儿对worker进行加锁，是为了达到下面的目的</span>            <span class="token comment" spellcheck="true">// 1. 降低锁范围，提升性能</span>            <span class="token comment" spellcheck="true">// 2. 保证每个worker执行的任务是串行的</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// If pool is stopping, ensure thread is interrupted;</span>            <span class="token comment" spellcheck="true">// if not, ensure thread is not interrupted.  This</span>            <span class="token comment" spellcheck="true">// requires a recheck in second case to deal with</span>            <span class="token comment" spellcheck="true">// shutdownNow race while clearing interrupt</span>            <span class="token comment" spellcheck="true">// 如果线程池正在停止，则对当前线程进行中断操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。</span>            <span class="token comment" spellcheck="true">// 这两个方法在当前类里面为空实现。</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 帮助gc</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 已完成任务数加一 </span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 自旋操作被退出，说明线程池正在结束</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newWorkStealingPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span>        <span class="token punctuation">(</span>Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         ForkJoinPool<span class="token punctuation">.</span>defaultForkJoinWorkerThreadFactory<span class="token punctuation">,</span>         null<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>WorkStealingPool和原来的区别就是, 每个线程都有自己单独的队列. 当某个线程执行完自己的任务时, 会去其他线程的队列中偷一个任务.</p><p>而原本的线程池都是ThreadPoolExecutor, WorkStealingPool是ForkJoinPool.</p><h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>ForkJoinPool适合做把一个大任务切分成一个个小任务, 小任务执行完的结果再汇总.</p><p>因为任务需要可以进行切分, 所以要求任务继承ForkJoinTask. 我们可以使用ForkJoinTask的子类RecursiveTask和RecursiveAction.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test05</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">1000000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_NUM <span class="token operator">=</span> <span class="token number">50000</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"single calculate sum : "</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AddTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Long<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> start<span class="token punctuation">;</span>        <span class="token keyword">int</span> end<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">AddTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> Long <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">&lt;=</span> MAX_NUM<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> sum<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> middle <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                AddTask subTask1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AddTask</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>                AddTask subTask2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AddTask</span><span class="token punctuation">(</span>middle<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>                subTask1<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                subTask2<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> subTask1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> subTask2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//    static class AddTask extends RecursiveAction {</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//        int start;</span><span class="token comment" spellcheck="true">//        int end;</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//        public AddTask(int start, int end){</span><span class="token comment" spellcheck="true">//            this.start = start;</span><span class="token comment" spellcheck="true">//            this.end = end;</span><span class="token comment" spellcheck="true">//        }</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//        @Override</span><span class="token comment" spellcheck="true">//        protected void compute() {</span><span class="token comment" spellcheck="true">//            if (end - start &lt;= MAX_NUM){</span><span class="token comment" spellcheck="true">//                long sum = 0;</span><span class="token comment" spellcheck="true">//                for (int i = start; i &lt;= end; i++) {</span><span class="token comment" spellcheck="true">//                    sum += i;</span><span class="token comment" spellcheck="true">//                }</span><span class="token comment" spellcheck="true">//                System.out.println("from : " + start + " to : " + end + " sum = " + sum);</span><span class="token comment" spellcheck="true">//            }else {</span><span class="token comment" spellcheck="true">//                int middle = start + (end - start) / 2;</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//                AddTask subTask1 = new AddTask(start, middle);</span><span class="token comment" spellcheck="true">//                AddTask subTask2 = new AddTask(middle + 1, end);</span><span class="token comment" spellcheck="true">//                subTask1.fork();</span><span class="token comment" spellcheck="true">//                subTask2.fork();</span><span class="token comment" spellcheck="true">//            }</span><span class="token comment" spellcheck="true">//        }</span><span class="token comment" spellcheck="true">//    }</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        ForkJoinPool fjp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AddTask task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AddTask</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        fjp<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="ParallelStream"><a href="#ParallelStream" class="headerlink" title="ParallelStream"></a>ParallelStream</h3><p>ParallelStream也是使用ForkJoinPool的一个Stream.</p><h2 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h2><p>单机性能最好的MQ</p><h3 id="Disruptor的特点"><a href="#Disruptor的特点" class="headerlink" title="Disruptor的特点"></a>Disruptor的特点</h3><p>无锁, 高并发, 使用环形Buffer, 直接覆盖(不用清除)旧的数据, 降低GC频率</p><p>实现了基于时间的生产者消费者模式(观察者模式)</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发(三)</title>
      <link href="/2020/07/05/2020-07-05/"/>
      <url>/2020/07/05/2020-07-05/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程与高并发-三"><a href="#多线程与高并发-三" class="headerlink" title="多线程与高并发(三)"></a>多线程与高并发(三)</h1><h2 id="多线程场景下的容器"><a href="#多线程场景下的容器" class="headerlink" title="多线程场景下的容器"></a>多线程场景下的容器</h2><p>在Java日常开发中经常使用到容器. 下面就看看多线程场景下容器的选择</p><h3 id="容器的选择"><a href="#容器的选择" class="headerlink" title="容器的选择"></a>容器的选择</h3><h4 id="Map容器"><a href="#Map容器" class="headerlink" title="Map容器"></a>Map容器</h4><p>一个场景: 100个线程, 每个线程向容器中添加10w条数据, 比较Hashtable,Collections和ConcurrentHashMap的时间.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer RUN_TIMES <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer THREAD_NUM <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> keyArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UUID</span><span class="token punctuation">[</span>THREAD_NUM <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">]</span><span class="token punctuation">;</span>        UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> valueArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UUID</span><span class="token punctuation">[</span>THREAD_NUM <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_NUM <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            keyArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            valueArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">testHashTableAdd</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">,</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCollectionsAdd</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">,</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testConcurrentHashMapAdd</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">,</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testHashTableAdd</span><span class="token punctuation">(</span>UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> keyArr<span class="token punctuation">,</span> UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Hashtable<span class="token operator">&lt;</span>UUID<span class="token punctuation">,</span> UUID<span class="token operator">></span> hashtable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span>THREAD_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> startNum <span class="token operator">=</span> i <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">;</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> RUN_TIMES<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hashtable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> valueArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HashTable　添加完毕, 时间 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testCollectionsAdd</span><span class="token punctuation">(</span>UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> keyArr<span class="token punctuation">,</span> UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>UUID<span class="token punctuation">,</span> UUID<span class="token operator">></span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>UUID<span class="token punctuation">,</span> UUID<span class="token operator">></span> hashtable <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span>THREAD_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> startNum <span class="token operator">=</span> i <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">;</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> RUN_TIMES<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hashtable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> valueArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collections　添加完毕, 时间 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testConcurrentHashMapAdd</span><span class="token punctuation">(</span>UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> keyArr<span class="token punctuation">,</span> UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>UUID<span class="token punctuation">,</span> UUID<span class="token operator">></span> hashtable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span>THREAD_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> startNum <span class="token operator">=</span> i <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">;</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> RUN_TIMES<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hashtable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> valueArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcurrentHashMap　添加完毕, 时间 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果:</p><pre><code>HashTable　添加完毕, 时间 : 13056Collections　添加完毕, 时间 : 9884ConcurrentHashMap　添加完毕, 时间 : 55504</code></pre><p>可以看到, 时间上来看是Collections最快, ConcurrentHashMap最慢, 而且慢的不止是一点.</p><p>为什么呢?</p><p>我们都知道ConcurrentHashMap是设计来给多线程场景下用的, 而且使用了分段锁机制, 为什么还没有直接Synchronized同步快呢?</p><p>一般情况下, 我们使用容器, 读的情况要比写的情况多, 所以我们再来看看读时的时间.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer RUN_TIMES <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer THREAD_NUM <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer SEARCH_TIMES <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> keyArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UUID</span><span class="token punctuation">[</span>THREAD_NUM <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">]</span><span class="token punctuation">;</span>        UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> valueArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UUID</span><span class="token punctuation">[</span>THREAD_NUM <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_NUM <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            keyArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            valueArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">testHashTableAdd</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">,</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCollectionsAdd</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">,</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testConcurrentHashMapAdd</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">,</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testHashTableAdd</span><span class="token punctuation">(</span>UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> keyArr<span class="token punctuation">,</span> UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Hashtable<span class="token operator">&lt;</span>UUID<span class="token punctuation">,</span> UUID<span class="token operator">></span> hashtable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span>THREAD_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> startNum <span class="token operator">=</span> i <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">;</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> RUN_TIMES<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hashtable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> valueArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HashTable　添加完毕, 时间 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> SEARCH_TIMES<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hashtable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HashTable　查询完毕, 时间 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testCollectionsAdd</span><span class="token punctuation">(</span>UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> keyArr<span class="token punctuation">,</span> UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>UUID<span class="token punctuation">,</span> UUID<span class="token operator">></span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>UUID<span class="token punctuation">,</span> UUID<span class="token operator">></span> hashtable <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span>THREAD_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> startNum <span class="token operator">=</span> i <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">;</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> RUN_TIMES<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hashtable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> valueArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collections　添加完毕, 时间 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> SEARCH_TIMES<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hashtable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collections　查询完毕, 时间 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testConcurrentHashMapAdd</span><span class="token punctuation">(</span>UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> keyArr<span class="token punctuation">,</span> UUID<span class="token punctuation">[</span><span class="token punctuation">]</span> valueArr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>UUID<span class="token punctuation">,</span> UUID<span class="token operator">></span> hashtable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span>THREAD_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> startNum <span class="token operator">=</span> i <span class="token operator">*</span> RUN_TIMES<span class="token punctuation">;</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> RUN_TIMES<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hashtable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> valueArr<span class="token punctuation">[</span>startNum<span class="token operator">+</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcurrentHashMap　添加完毕, 时间 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> SEARCH_TIMES<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hashtable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcurrentHashMap　查询完毕, 时间 : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在添加完之后, 再开这么多线程每个线程去取keyArr中第10个元素, 取一千万次</p><pre class=" language-java"><code class="language-java">HashTable　添加完毕<span class="token punctuation">,</span> 时间 <span class="token operator">:</span> <span class="token number">14196</span>HashTable　查询完毕<span class="token punctuation">,</span> 时间 <span class="token operator">:</span> <span class="token number">50732</span>Collections　添加完毕<span class="token punctuation">,</span> 时间 <span class="token operator">:</span> <span class="token number">9536</span>Collections　查询完毕<span class="token punctuation">,</span> 时间 <span class="token operator">:</span> <span class="token number">51183</span>ConcurrentHashMap　添加完毕<span class="token punctuation">,</span> 时间 <span class="token operator">:</span> <span class="token number">43753</span>ConcurrentHashMap　查询完毕<span class="token punctuation">,</span> 时间 <span class="token operator">:</span> <span class="token number">1592</span></code></pre><p>可以看到, ConcurrentHashMap的长处在于查询.</p><h4 id="Collection容器"><a href="#Collection容器" class="headerlink" title="Collection容器"></a>Collection容器</h4><p>场景: 一个容器中有10w条数据, 起100个线程每次去移除容器中第一个.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> LENGTH <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THREAD_NUM <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">testVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Vector<span class="token operator">&lt;</span>Integer<span class="token operator">></span> vector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> LENGTH<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            vector<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> LENGTH<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    Integer poll <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>poll <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>poll<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>testVector方法执行是会报错的, 因为<code>vector.size() &gt; 0</code>所做的判断和<code>vector.remove(0)</code>虽然每个都是原子操作, 但是两步原子操作并没有合成一步原子操作, 会导致有的线程remove的时候容器中已经没有元素了.</p><p>而Queue中使用cas出队,本身就是一步原子操作.</p><h3 id="同步Map"><a href="#同步Map" class="headerlink" title="同步Map"></a>同步Map</h3><p>我们学过Map都知道, Map的实现有HashMap, LinkedHashMap和TreeMap.</p><p>其中, LinkedHashMap是HashMap加了一个双向链表保证插入顺序, TreeMap是使用红黑树使节点排序.</p><p>那么同步容器中为什么没有ConcurrentTreeMap呢?</p><p>如果同步的时候也想要排序怎么办.</p><p>JUC提供了<code>ConcurrentSkipListMap</code>.</p><p>他是使用跳表实现的, 因为使用cas实现树结构太复杂了.</p><h3 id="同步List"><a href="#同步List" class="headerlink" title="同步List"></a>同步List</h3><p>CopyOnWriteList是JUC提供的同步列表.</p><p>CopyOnWrite的意思是写时复制.</p><p>基于实际情况下, 读的情况远大于写的情况. </p><p>当我们向数组中写数据的时候, 考虑用CopyOnWrite来提高效率.</p><p>CopyOnWrite在写的时候不加锁. </p><p>众所周知, Vector在写和读的时候都加锁,而CopyOnWrite读时候不加锁, 但是在写的时候会在原数组的基础上copy一个出来, 将添加的元素添加到最后一个.</p><p>在写完之后将容器的引用指向新的数组.</p><p>这样处理的好处是, 写的时候对读没有影响.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>因此, CopyOnWriteList添加的效率是比较低的, 因为每次都要拷贝一份数组.</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue 阻塞队列</p><p>阻塞队列提供的方法可以使线程阻塞, 所以叫阻塞队列.</p><ol><li>LinkedBlockingQueue 无界阻塞队列</li><li>ArrayBlockingQueue 有界阻塞队列</li><li>DelayQueue 可以实现在时间上的排序</li><li>SynchronousQueue 用来给线程之间传递内容的</li><li>TransferQueue 是前面队列的组合</li></ol><h4 id="Queue中的方法"><a href="#Queue中的方法" class="headerlink" title="Queue中的方法"></a>Queue中的方法</h4><ul><li><p>boolean offer(E e) </p></li><li><p>boolean add(E e)</p></li><li><p>E poll();</p></li><li><p>E peek();</p></li></ul><p>offer()和add()都是向队列中添加元素. 区别在于, 当队列满了, offer()会返回false, 而add()会抛异常.</p><p>peek()方法是取队头元素, 并且不会remove掉.</p><p>poll()方法是取队头元素, 并且remove掉.</p><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>阻塞队列在队列的基础上加了put()和take()方法.</p><p>对应offer和poll.</p><p>但是offer和poll失败了就返回false, put和take如果失败了就会在这里等.</p><p>当然, offer也提供了等待一个时间的重载方法, 可以使线程等候一段时间.</p><p><strong>DelayQueue</strong></p><p>DelayQueue可以实现按照等待的时间进行排序.</p><p>向这个Queue中添加任务要求必须实现Delayed接口.</p><p>实现getDelay和compareTo方法, 在队列中等待越短的任务会优先得到运行.</p><p>一般用来按时间进行任务调度.</p><p><strong>PriorityQueue</strong></p><p>上面的DelayQueue本质上是一个PriorityQueue.</p><p>在他内部进行了一个排序.</p><p>PriorityQueue内部实现是使用了树.可以理解为堆排序中的小根堆.小的值排在上面.</p><p><strong>SynchronousQueue</strong></p><p>这个Queue的容量为0, 不是用来装东西的. 跟Exchanger很像, 是用来交换的.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    SynchronousQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程结束 queue.size()="</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当把子线程那部分代码注释掉的时候, 程序无法结束, 并且无任何输出.</p><p>如果使用add方法, 会直接报错</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        SynchronousQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程结束 queue.size()="</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>因为这个队列不是个容器, 不能装东西.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法的总结</title>
      <link href="/2020/07/03/2020-07-03/"/>
      <url>/2020/07/03/2020-07-03/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法的总结"><a href="#排序算法的总结" class="headerlink" title="排序算法的总结"></a>排序算法的总结</h2><p>各种排序算法的时间复杂度和空间复杂度的总结.</p><table><thead><tr><th></th><th>时间复杂度</th><th>额外空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>选择排序</td><td>O(N^2)</td><td>O(1)</td><td>无</td></tr><tr><td>冒泡排序</td><td>O(N^2)</td><td>O(1)</td><td>有</td></tr><tr><td>插入排序</td><td>O(N^2)</td><td>O(1)</td><td>有</td></tr><tr><td>归并排序</td><td>O(N*logN)</td><td>O(N)</td><td>有</td></tr><tr><td>随机快排</td><td>O(N*logN)</td><td>O(logN)</td><td>无</td></tr><tr><td>堆排序</td><td>O(N*logN)</td><td>O(1)</td><td>无</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>计数排序</td><td>O(N)</td><td>O(M)</td><td>有</td></tr><tr><td>基数排序</td><td>O(N)</td><td>O(N)</td><td>有</td></tr></tbody></table><h2 id="排序算法的选择"><a href="#排序算法的选择" class="headerlink" title="排序算法的选择"></a>排序算法的选择</h2><ol><li>不基于比较的排序, 对样本数据有严格要求, 不易改写</li><li>基于比较的排序, 只要规定好两个样本怎么比大小就可以直接复用</li><li>基于比较的排序, 时间复杂度的极限是 O(N*logN)</li><li>时间复杂度 O(N*logN) , 额外空间复杂度低于 O(N), 且稳定的基于比较的排序是不存在的.</li><li>为了绝对的速度选快排, 为了省空间选堆排, 为了稳定性选归并.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发(二)</title>
      <link href="/2020/06/30/2020-06-30/"/>
      <url>/2020/06/30/2020-06-30/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程与高并发-二"><a href="#多线程与高并发-二" class="headerlink" title="多线程与高并发(二)"></a>多线程与高并发(二)</h2><h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><p>先看一个例子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">long</span> count1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> AtomicLong count2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> LongAdder count3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongAdder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Object lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        count1<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread thread <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread thread <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> endTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sync : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// -------------</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    count2<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread thread <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread thread <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        endTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Atomic : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// --------------</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    count3<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread thread <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread thread <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        endTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LongAdder : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>例子描述的很简单, 都是起1000个线程做累加操作, 分别看看synchronized,Atomic类, LongAdder三种方式那种效率更高.</p><pre><code>sync : 1365Atomic : 2319LongAdder : 473</code></pre><p>执行时间可以看出, LongAdder远比其他两种方式更快.</p><p>那么为什么呢?</p><h4 id="java-doc"><a href="#java-doc" class="headerlink" title="java doc"></a>java doc</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * One or more variables that together maintain an initially zero * {@code long} sum.  When updates (method {@link #add}) are contended * across threads, the set of variables may grow dynamically to reduce * contention. Method {@link #sum} (or, equivalently, {@link * #longValue}) returns the current total combined across the * variables maintaining the sum. * * &lt;p>This class is usually preferable to {@link AtomicLong} when * multiple threads update a common sum that is used for purposes such * as collecting statistics, not for fine-grained synchronization * control.  Under low update contention, the two classes have similar * characteristics. But under high contention, expected throughput of * this class is significantly higher, at the expense of higher space * consumption. * * &lt;p>LongAdders can be used with a {@link * java.util.concurrent.ConcurrentHashMap} to maintain a scalable * frequency map (a form of histogram or multiset). For example, to * add a count to a {@code ConcurrentHashMap&lt;String,LongAdder> freqs}, * initializing if not already present, you can use {@code * freqs.computeIfAbsent(k -> new LongAdder()).increment();} * * &lt;p>This class extends {@link Number}, but does &lt;em>not&lt;/em> define * methods such as {@code equals}, {@code hashCode} and {@code * compareTo} because instances are expected to be mutated, and so are * not useful as collection keys. * * @since 1.8 * @author Doug Lea */</span></code></pre><p>LongAdder中会维护一个或多个变量，这些变量共同组成一个long型的“和”。当多个线程同时更新（特指“add”）值时，为了减少竞争，可能会动态地增加这组变量的数量。“sum”方法（等效于longValue方法）返回这组变量的“和”值。<br> 当我们的场景是为了统计技术，而不是为了更细粒度的同步控制时，并且是在多线程更新的场景时，LongAdder类比AtomicLong更好用。 在小并发的环境下，论更新的效率，两者都差不多。但是高并发的场景下，LongAdder有着明显更高的吞吐量，但是有着更高的空间复杂度。</p><h4 id="LongAddr维护一个Cell数组"><a href="#LongAddr维护一个Cell数组" class="headerlink" title="LongAddr维护一个Cell数组"></a>LongAddr维护一个Cell数组</h4><p>LongAddr在高并发下性能更好的原因是使用了分段锁.</p><p>就像ConcurrentHashMap的分段锁一样, LongAddr中维护了一个Cell数组, 每个线程尽量都写在自己那个分段中, 当求和的时候再将每个分段中的值加起来.</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是可以替代Synchronized的.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"m"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 可以替换成</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>    Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"m"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注意, 上面的lock.lock()是不能放在try块中的.</p><p>ReentrantLock是要手动解锁的, 而且要确保必须要解锁.</p><p>synchronized在同步代码块或者同步方法执行完之后自动释放锁, 使用ReentrantLock要在finally中unlock.</p><h4 id="为什么要用ReentrantLock"><a href="#为什么要用ReentrantLock" class="headerlink" title="为什么要用ReentrantLock"></a>为什么要用ReentrantLock</h4><p>既然synchronized会自动释放锁, ReentrantLock要手动释放, 为什么还要用ReentrantLock呢?</p><h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03</span> <span class="token punctuation">{</span>    ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">boolean</span> b <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"m2 "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test03 t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token operator">:</span><span class="token operator">:</span>m1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token operator">:</span><span class="token operator">:</span>m2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>ReentrantLock提供了tryLock方法, 在给定时间内尝试获取锁.</p><p>当锁获取成功, 或者超市之后返回. 会返回一个boolean类型的值, 标志是否获得锁成功,</p><p>后续的处理可以根据这个布尔值来判断. </p><p>当然,上述代码是有问题的, 如果tryLock没有获取到锁, 就不应该在finally中unlock().</p><h4 id="lockInterruptly"><a href="#lockInterruptly" class="headerlink" title="lockInterruptly"></a>lockInterruptly</h4><p>lock.lockInterruptibly()的作用是：如果当前线程未被中断，则获取锁定(需要等待别的线程释放锁才行)，如果已被中断则出现异常。但是使用lock.lock()时，当前线程被中断，不会报错。</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁的意思是, 按照线程访问的顺序获取锁, 而非公平锁会有一个抢占锁的过程.</p><p>非公平锁的性能要更好一些, ReentrantLock和synchronized都是默认非公平锁.</p><pre class=" language-java"><code class="language-java">ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这就代表是公平锁.</p><p>当已经加锁时, 其他线程过来访问是会被加入到一个等待队列中. 此时如果有一个线程过来访问, 该线程是否会去检查等待队列中是否有等待线程是判断该锁是否公平的条件. </p><p>非公平锁不会判断等待队列中是否有线程正在等待,而直接去试图获取锁. </p><p>此时是有可能直接获取到锁而先于其他先到并且等待的线程获得到锁.</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>countdown 倒数 latch 门闩</p><p>差不多相当于赛跑前 3,2,1 砰 的作用.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">usingCountDownLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Thread<span class="token punctuation">[</span><span class="token punctuation">]</span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    CountDownLatch latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threads<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threads<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">+=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread thread <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end latch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>开启100个线程, 每个线程在做完从1加到10000之后, 使用<code>latch.countDown();</code>在countDownLatch上-1, 当countDownLatch为中值为0 的时候, 可以继续从<code>latch.await();</code>向下走.</p><p>join()也可以做到这个, 为什么要用CountDownLatch呢?</p><p>join必须是线程结束之后才结束, 而且所有注册到这个线程上的线程全部都要结束.</p><p>而CountDownLatch的大小可以自己设置, 一个线程里可以多次调用countDown().</p><p>比如有100个线程, 要求只要80个做完就可以, 那就可以new CountDownLatch(80);</p><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>栅栏 </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    CyclicBarrier barrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"满人 发车"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码的意思是, 每来一个线程, 运行到<code>barrier.await();</code>时, 当barrier中堆了20个,就把栅栏放下来.</p><p>输出: </p><pre><code>满人 发车满人 发车满人 发车满人 发车满人 发车</code></pre><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p>读写锁的概念就是共享锁和排他锁</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test07</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token keyword">static</span> ReadWriteLock readWriteLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Lock readLock <span class="token operator">=</span> readWriteLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Lock writeLock <span class="token operator">=</span> readWriteLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span>Lock lock<span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"read over!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>Lock lock<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"write over!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Runnable readR <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">read</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        Runnable writeR <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">write</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>readR<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>writeR<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果是上面这种互斥锁, 那么20个线程无论如何都是要运行20秒的.</p><p>但是读的时候并没有发生数据改变, 因此读和读之间并不需要加锁.</p><p>简单修改一下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test07</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token keyword">static</span> ReadWriteLock readWriteLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Lock readLock <span class="token operator">=</span> readWriteLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Lock writeLock <span class="token operator">=</span> readWriteLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span>Lock lock<span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"read over!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>Lock lock<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"write over!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Runnable readR <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">read</span><span class="token punctuation">(</span>readLock<span class="token punctuation">)</span><span class="token punctuation">;</span>        Runnable writeR <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">write</span><span class="token punctuation">(</span>writeLock<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>readR<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>writeR<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>将传入的锁换成读写锁, 理论上来说读的18个线程应该可以互不影响的读, 1秒内就可以完成18个读操作.</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Semaphore s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"T1 running.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"T1 running.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"T2 running.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"T2 running.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>Semaphore s = new Semaphore(1);</code>的意思是, 开一个信号量, 当一个线程获取锁的时候该信号量-1, 如果为0则获取失败,必须等待.</p><p>主要是用于限流, 比如卖票, 开5个窗口, 最多同时允许5个线程同时运行.</p><p>Semaphore 也可以选择公平和非公平.</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>     sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span>permits<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span>permits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>交换</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Exchanger<span class="token operator">&lt;</span>String<span class="token operator">></span> exchanger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exchanger</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        String s <span class="token operator">=</span> <span class="token string">"T1"</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            s <span class="token operator">=</span> exchanger<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        String s <span class="token operator">=</span> <span class="token string">"T2"</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            s <span class="token operator">=</span> exchanger<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出:</p><pre><code>t1 T2t2 T1</code></pre><p>Exchanger.exchange()方法是阻塞的.</p><p><img src="/2020/06/30/2020-06-30/exchanger.jpg" alt></p><p>t1执行到exchange()方法的时候将要交换的值放入Exchanger中, 然后阻塞等待.</p><p>t2执行到exchange()方法的时候在Exchanger中进行交换. 然后两个线程回复运行.</p><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>LockSupport可以实现对某个线程的阻塞和唤醒.</p><p>如果用nofity(), 会唤醒阻塞的所有线程, 而想要针对某一个特定的线程进行唤醒是较为困难的.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after 8s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当子线程打印出5之后, 使子线程阻塞. </p><p>在主线程中等待8秒之后, 唤醒特定的子线程. </p><p>AQS同步器中就是使用LockSupport将线程阻塞的.</p><p>另一个有意思的事情是, unpark() 可以先于park()调用.</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>如果是notify的话, nofity在wait之前是没有作用的.</p><p>但是在LockSupport中, 如果先执行了unpark(), 在后续阻塞的时候就会直接放行.</p><h3 id="线程可见性"><a href="#线程可见性" class="headerlink" title="线程可见性"></a>线程可见性</h3><p>一个小例子:</p><p><strong>直接使用volatile</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test11</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t2 结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>t1一直在向list中添加数据, t2在检视list的大小, 当list.size()大于5的时候跳出循环打印信息.</p><p>结果可能会出现t1一直在执行, 已经执行完了t2还是没有监视到list.size()大于5.</p><p>这种情况我们之前碰到过, 没有加volatile导致线程间不可见.</p><p>那将list前加上volatile重新运行测试</p><p>发现还是有t2一直不结束的情况出现.</p><p>volatile不是已经保证线程可见性了吗? </p><p>但是List类型是个引用类型, volatile保证的是这个引用的地址值.</p><p>因为list向里面添加并没有改变地址值, 所以t2中感知不到list的变化.</p><p><strong>使用synchronized</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test12</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">volatile</span> List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t2 结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用synchronized的方式加锁, 在t1线程向list中添加了5个元素之后, nofity唤醒t2.</p><p>最后结果依然是 t1添加完十次之后, t2线程才会打印.</p><p>这里涉及到notify方法, <code>notify不会释放锁</code>.</p><p>因此t2在wait等待被t1nofity之后, 必须要获取到lock这把锁.</p><p>那么做一个小小的修改:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test13</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">volatile</span> List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t2 结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>t1线程在notify唤醒t2之后, 自己wait释放这把锁, t2获取到这把锁之后打印结束的文字, 并且再次唤醒t1, 使t1继续未完成的向list中添加元素操作.</p><p><strong>使用CountDownLatch</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test14</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">volatile</span> List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CountDownLatch latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t2 结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果将t1中的sleep去掉</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test14</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">volatile</span> List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CountDownLatch latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"t2 结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>此时的输出是有问题的, 在t1中size为5的时候, 此时t2的latch已经打开. </p><p>但是t1并没有让渡CPU使用权, 所以t2仍然只能在t1执行完之后再执行.</p><p>解决方法就是再添加一个CountDownLatch, 当size为5的时候将t1拦住, t2执行完后再将t1放开.</p><p><strong>使用LockSupport</strong></p><p>使用LockSupport同理, 也是需要两个, 在t1的size为5时将t2unpark, 将自己park.</p><p>在t2完成之后将t1unpark.</p><h4 id="两个线程交替打印"><a href="#两个线程交替打印" class="headerlink" title="两个线程交替打印"></a>两个线程交替打印</h4><p>两个线程交替打印, 一个线程打印A<del>Z, 一个线程打印0</del>25</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String s <span class="token operator">=</span> <span class="token string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="token punctuation">;</span>    ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Condition condition1 <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Condition condition2 <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                condition2<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                condition1<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                condition1<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                condition2<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="实现一个生产者消费者容器"><a href="#实现一个生产者消费者容器" class="headerlink" title="实现一个生产者消费者容器"></a>实现一个生产者消费者容器</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test16</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>T<span class="token operator">></span> lists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">private</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> MAX<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> T <span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        T t <span class="token operator">=</span> lists<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test16<span class="token operator">&lt;</span>String<span class="token operator">></span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test16</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">25</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    t<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"p"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>ReentrantLock版本, 使用Condition指定唤醒生产者或消费者</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test17</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>T<span class="token operator">></span> lists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">private</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Condition producer <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Condition consumer <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> MAX<span class="token punctuation">)</span><span class="token punctuation">{</span>                producer<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>            consumer<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> T <span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                consumer<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            T t <span class="token operator">=</span> lists<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            producer<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test17<span class="token operator">&lt;</span>String<span class="token operator">></span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test17</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">25</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    t<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"p"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>从lock()开始看AQS源码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>进入lock()</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ReentrantLock.java   </span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用Sync的lock方法</span>    <span class="token comment" spellcheck="true">// 此时的sync是Sync的子类NonfairSync</span>    sync<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// NonfairSync</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// cas交换state状态</span>    <span class="token comment" spellcheck="true">// 因此Sync是继承AQS的, 并且没有重写这个方法</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 如果cas操作成功, 将当前线程保存在AQS的持有线程中</span>        <span class="token comment" spellcheck="true">// AQS中维护了一个exclusiveOwnerThread, 标志持有锁的线程</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">// 如果cas失败, 调用AQS中的acquire方法</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AbstractQueuedSynchronizer.java</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// stateOffset是16</span>    <span class="token comment" spellcheck="true">// AQS内部维护了一个int 类型 使用volatile修饰的state</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// AQS中的tryAcquire方法直接抛出了一个异常</span>    <span class="token comment" spellcheck="true">// 会调回到Sync中的tryAcquire方法</span>    <span class="token comment" spellcheck="true">// 如果tryAcquire返回true, 尝试加锁成功, !true = false, 后面判断条件短路, 方法结束</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token comment" spellcheck="true">// 如果尝试获取锁失败, 将线程放入队列</span>        <span class="token comment" spellcheck="true">// AQS中维护了一个Node组成的双向链表</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 没有获取到锁, 而且成功放到等待队列中, 将自己线程阻塞节约CPU资源</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// NonfairSync</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取当前线程</span>    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取当前锁状态</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果c==0, 意味着没加锁, 可以进行获取锁操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 尝试获取锁, 如果获取成功, 如上面的lock方法一样</span>        <span class="token comment" spellcheck="true">// 如果失败, 返回false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果c!=0, 意味着已经加锁了.</span>    <span class="token comment" spellcheck="true">// 判断一下当前线程是不是持锁线程</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果当前线程是吃锁线程, 将state加上传入的参数</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 到这里就意味着, 要么已经上锁, 要么没有和其他线程抢锁失败</span>    <span class="token comment" spellcheck="true">// 方法名叫tryAcquire, 尝试获取 尝试获取失败, 返回false</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AbstractQueuedSynchronizer.java</span><span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 用当前线程和给定的模式创建一个node</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 尝试是否可以直接添加到等待队列队尾</span>    Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果tail是空,在enq()方法中初始化</span>    <span class="token comment" spellcheck="true">// 如果tail不是空, 用cas来尝试入队</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果cas成功, 直接返回</span>        <span class="token comment" spellcheck="true">// 如果失败, 进入enq方法, 以自旋的方式尝试直到成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AbstractQueuedSynchronizer.java</span><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果等待队列没有初始化, 将新建一个node节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 尝试添加到队尾</span>            <span class="token comment" spellcheck="true">// 如果没有添加成功,就不停的重试</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AbstractQueuedSynchronizer.java</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取到node的前置节点</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果前置节点就是head, 就去尝试获取一下锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果获取成功了,说明前面的节点已经释放锁了, 那么当前节点就是head</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 看看当前节点是否应该被park</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AbstractQueuedSynchronizer.java</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果现在的状态已经是SIGNAL, 就将这个线程park</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果现在的状态是CANCELLED, 就把这个线程移出等待队列</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果现在状态是CONDITION或PROPAGATE, 就把线程状态改成SIGNAL</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>CANCELLED:1,在同步队列中等待的线程等待超时或者中断，需要从同步队列中取消等待。</li><li>SIGNAL:-1,后继节点的线程处于等待，而当前节点的线程如果释放同步状态或者取消，将会通知后继节点，表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li><li>CONDITION:-2,节点在等待队列中，节点线程在等待condition上，当其他线程对Condition调用signal()后，会把该节点从等待队列转移到同步队列中，加入到对同步状态的获取中</li><li>PROPAGATE:-3,表示下一次共享式同步状态获取将会无条件地被传播下去</li><li>INITIAL:0,初始化状态</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test19</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>Person<span class="token operator">></span> tl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            tl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>        String name <span class="token operator">=</span> <span class="token string">"zhangsan"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面这段代码中使用了ThreadLocal, 在t1等待两秒, t2等待一秒后设置一个new Person(), t1获取到的结果是null</p><p>因为ThreadLocal是给每个线程保存自己线程的值, 线程间不通用.</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ThreadLocal.java</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取当前线程</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据当前线程, 获取ThreadLocalMap</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 将当前threadLocal对象作为key放进map</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ThreadLocal.java</span>ThreadLocalMap <span class="token function">getMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取ThreadLocalMap</span>    <span class="token comment" spellcheck="true">// t的threadLocals是存放在Thread类中的.</span>    <span class="token comment" spellcheck="true">// 因此此处返回的是当前线程的threadLocals</span>    <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Thread.java</span><span class="token comment" spellcheck="true">// ThreadLocalMap是保存在Thread类中的</span>ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><h3 id="Java的四种引用"><a href="#Java的四种引用" class="headerlink" title="Java的四种引用"></a>Java的四种引用</h3><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li></ul><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>普通我们用到的引用就是强引用.</p><pre class=" language-javascript"><code class="language-javascript">Object o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test20</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        M m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> null<span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">M</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finalize"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在Object类中有一个方法finalize(), 这个方法是对象被垃圾回收之前会调用的方法</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>当一个对象被软引用指向的时候, 当内存不够用的时候就会回收.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test21</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 用软引用 分配一个10m的byte数组</span>        SoftReference<span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 此时20m的内存只占用10m, 尝试垃圾回收</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 垃圾回收后再尝试获取</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 20m的内存已经使用了10m, 再次分配15m内存, 此时内存不够用, 软引用应该要被回收</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在运行这个代码之前, 先将JVM的堆内存设置成20m. 加上参数: <code>-Xms20M -Xmx20M</code></p><p>java8运行结果会是<code>java.lang.OutOfMemoryError: Java heap space</code>, java11的运行会自动将m引用删掉.</p><p>可以用作缓存</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>只要GC就会被回收.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test22</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        WeakReference<span class="token operator">&lt;</span>M<span class="token operator">></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取弱引用</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用GC</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次尝试获取弱引用</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadLocal<span class="token operator">&lt;</span>M<span class="token operator">></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// </span>        threadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>com.echi.thread.M@76ed5528nullfinalize</code></pre><p>弱引用的作用在于, 如果有一个强引用指向他的时候, 只要这个强引用消失掉, 这个弱引用也会在下一次GC回收.</p><p>弱引用的一个应用就是ThreadLocal</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ThreadLocalMap中实际是Entry数组,</span><span class="token comment" spellcheck="true">// 而Entry是继承自WeakReference的</span><span class="token comment" spellcheck="true">// 也就是说Entry也是一个弱引用.</span><span class="token comment" spellcheck="true">// 所以这个key是通过弱引用只想的ThreadLocal对象</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 而threadLocal在Thread中是一个强引用,</span><span class="token comment" spellcheck="true">// 因此, 当线程结束的时候, ThreadLocal上的强引用消失.</span><span class="token comment" spellcheck="true">// 如果Entry是一个强引用, threadLocal就不能被回收, 有可能发生内存泄漏</span></code></pre><p><img src="/2020/06/30/2020-06-30/ThreadLocal%E5%BC%B1%E5%BC%95%E7%94%A8.jpg" alt></p><p>那么还有一个问题, 当key指向的弱引用被回收了之后,key变为null, value再也无法被访问到了.</p><p>但是value是被强引用指向的, 仍然不会回收.</p><p>当这个threadLocals中的key越来越多的时候, 仍可能会出现内存泄漏的情况.</p><p>所以使用threadLocal, 当用完了之后一定要remove();</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用主要是用来管理堆外内存.</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先将堆内存调小</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test23</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> LIST <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 引用queue 装引用的队列</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ReferenceQueue<span class="token operator">&lt;</span>M<span class="token operator">></span> QUEUE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先用虚引用装一个M</span>        PhantomReference<span class="token operator">&lt;</span>M<span class="token operator">></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 循环的申请1m的空间</span>                LIST<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 尝试获取虚引用</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>phantomReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 看看队列中有没有值</span>                Reference<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">M</span><span class="token operator">></span> poll <span class="token operator">=</span> QUEUE<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>poll <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 虚引用被回收了 "</span> <span class="token operator">+</span> poll<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>虚引用调用get()方法只会返回null,</p><pre><code>nullnullnullnullnullnullnullnullnullnullfinalizenullnullnullnullnull 虚引用被回收了 java.lang.ref.PhantomReference@2f791ac9nullnull</code></pre><p>在NIO中有一个直接内存, DirectByteBuffer. 这个Buffer使用的是直接内存, 堆外内存.</p><p>当DirectByteBuffer回收的时候可以通过QUEUE检测到, 从而清理堆外内存.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发(一)</title>
      <link href="/2020/06/29/2020-06-29/"/>
      <url>/2020/06/29/2020-06-29/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程与高并发-一"><a href="#多线程与高并发-一" class="headerlink" title="多线程与高并发(一)"></a>多线程与高并发(一)</h2><p>程序, 进程, 线程, 纤程(协程)</p><p><strong>程序</strong></p><p>程序就是硬盘上保存的可执行的代码</p><p><strong>进程</strong></p><p>程序开始执行, 硬盘上的代码加载到内存中就叫进程</p><p><strong>线程</strong></p><p>线程就是进程调度的最小单位</p><p><strong>纤程(协程)</strong></p><p>用户态的线程</p><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><h4 id="Thread类的run-方法和start-方法"><a href="#Thread类的run-方法和start-方法" class="headerlink" title="Thread类的run()方法和start()方法"></a>Thread类的run()方法和start()方法</h4><p>先看一个简单的例子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">T1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"T1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在main()方法中直接new了一个Thread类, 然后调用它的run()方法.</p><p>输出:</p><pre><code>T1T1T1T1T1T1T1T1T1T1mainmainmainmainmainmainmainmainmainmain</code></pre><p>可以看到, 先输出’T1’ 再输出’main’</p><p>因为, 直接调用run()方法, 执行run()方法的仍然是main线程.</p><p><img src="/2020/06/29/2020-06-29/run%E6%96%B9%E6%B3%95%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C.jpg" alt></p><p>如果调用Thread的start()方法,输出就几乎是交替执行了</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">T1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"T1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//        new T1().run();</span>    <span class="token keyword">new</span> <span class="token class-name">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出</p><pre><code>mainT1mainT1mainT1mainT1mainT1mainT1mainT1mainT1mainT1T1main</code></pre><p><img src="/2020/06/29/2020-06-29/start%E6%96%B9%E6%B3%95%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C.jpg" alt></p><p>这是run()方法和start()方法的主要区别.</p><h4 id="启动线程的几种方式"><a href="#启动线程的几种方式" class="headerlink" title="启动线程的几种方式"></a>启动线程的几种方式</h4><ol><li>继承Thread类</li><li>传入Runnable接口的实现类</li><li>线程池</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"run my Thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyRun</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"run myRUN"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"run Lambda"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 阿里代码规约中不建议使用这种方式, 这个以后再谈</span>    Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"run Executor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>基于java8的lambda可以直接匿名的实现一个只有一个方法的接口, 也可以直接在new Thread的时候传入一个lambda表达式.</p><h4 id="对线程运行状态的操作"><a href="#对线程运行状态的操作" class="headerlink" title="对线程运行状态的操作"></a>对线程运行状态的操作</h4><p><strong>sleep()方法</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>sleep()方法的意思是, 当前线程睡眠一段时间,把cpu让渡给其他线程使用.</p><p><strong>yield()方法</strong></p><p>Thread.yield()方法是要求当前执行的线程先把cpu让出来, 并且当前线程进入等待队列.</p><p>在cpu执行的时候, 有可能会拿到原来的线程执行, 也有也能拿到本来就在等待的线程执行.</p><p><strong>join()方法</strong></p><p>join()方法常用来等待其他线程结束.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testJoin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在上面这段代码中, 创建了两个线程, t1和t2 . </p><p>在t2中调用了 t1.join().</p><p>这句代码的意思是, t2线程加入到t1线程中, 等到t1线程执行完了再继续向下执行.</p><p>所以,输出是:</p><pre><code>A0A1A2A3A4A5A6A7A8A9A10A11A12A13A14A15A16A17A18A19B</code></pre><h4 id="线程的六大状态"><a href="#线程的六大状态" class="headerlink" title="线程的六大状态"></a>线程的六大状态</h4><p><img src="/2020/06/29/2020-06-29/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB%E5%9B%BE.jpg" alt></p><p>线程大致可以分为六种状态</p><ol><li>new</li><li>Runnable</li><li>Teminated</li><li>TimedWaiting</li><li>Waiting</li><li>Blocked</li></ol><p><strong>new</strong></p><p>线程被创建出来的时候就是new状态</p><p><strong>Runnable</strong></p><p>Runnable里又可以分为两个状态, Ready和Running.</p><p>Ready就是可以执行,正在等待队列中等待的线程.</p><p>Running就是cpu正在执行的线程.</p><p><strong>Teminated</strong></p><p>线程执行完毕,结束时就是Teminated状态</p><p><strong>TimeWaiting</strong></p><p>等待一定时间之后会回到Runnable状态</p><p><strong>Waiting</strong></p><p>当调用了一些方法使线程等待时, 就进入了waiting状态, 需要相应的操作将该状态的线程唤醒.</p><p><strong>Blocked</strong></p><p>当线程进入同步代码块, 没有获取到锁的时候, 就会是Blocked状态,当获取到锁以后就回到了Runnable状态</p><p>可以用Thread中的getState()方法来获取线程当前的状态</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MyThread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出:</p><pre><code>NEWRUNNABLE0123456789TERMINATED</code></pre><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>访问一个共享资源或者一个临界区时, 必须要上锁.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">private</span> Object o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">{</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" count = "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在上面的代码示例中, 在多个线程想要访问count这个资源的时候,必须要获取o的锁.</p><p>只有拿到了o,才可以进行下面的–和打印操作.</p><p>Synchronized关键字在JVM规范中并没有固定必须如何实现. </p><p>在HotSpot中, 是在对象的头中取出2位, makword来实现的.</p><p>这两位代表了不同的锁类型.</p><p><strong>Synchronized在不同地方的应用</strong></p><p>上面我们说了, synchronized可以锁一个对象, 那么也可以锁this对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" count = "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当锁对象为this时, 上面这种写法等价于:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    count<span class="token operator">--</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" count = "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当sunchronized用来修饰static的方法时, 锁定的对象是当前类的class对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    count<span class="token operator">--</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" count = "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>此时等同于直接锁定T.class</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>Test06<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" count = "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>使用synchronized的例子</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test07</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        count <span class="token operator">--</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" count = "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test07 t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test07</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token string">"THREAD"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码显然输出是有问题的, 那只要在run()方法上添加synchronized关键字就可以了.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test07</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        count <span class="token operator">--</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" count = "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test07 t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test07</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token string">"THREAD"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>synchronized是可重入的</strong></p><p>假如synchronized是不可重入的, 在同一个方法中,两个synchronized修饰的方法如果相互产生调用, 就会出现死锁的情况.</p><p>同样, 如果子类中synchronized修饰的方法调用了super中的方法, 也会产生死锁.</p><p>所以synchronized一定是可重入的.</p><p><strong>当synchronized中产生抛出异常的时候会自动释放锁</strong></p><p>在synchronized修饰的方法中, 如果抛出异常, 会自动释放锁.</p><p>如果产生了异常不释放锁的话, 抛到了该方法的调用方, 锁未被释放. 以后所有的线程都没法再获取到这把锁了.</p><h4 id="synchronized的底层实现"><a href="#synchronized的底层实现" class="headerlink" title="synchronized的底层实现"></a>synchronized的底层实现</h4><p>在JDK早期的时候, synchronized是重量级的. 导致所有的锁都要向操作系统申请锁, 就造成synchronized效率低.</p><p>后来进行了 改进, 引入了锁升级</p><p>第一个访问的线程时, 在markword中记录这个线程的id (偏向锁)  默认不会产生线程竞争</p><p>如果有线程竞争的话, 就升级为自旋锁 (默认情况下自旋10次)</p><p>如果10次之后还是没有获得锁, 升级为重量级锁</p><p>synchronized升级的过程是不可逆的, 假设一段时间内竞争较激烈, 已经升级为重量级锁了. </p><p>之后的一段时间没有太强烈的竞争, 这时轻量级锁的效率会更高. </p><p>但是因为锁升级不能回退, 所以不能降级成轻量级锁.</p><p>执行时间短, 线程数少的情况下, 用自旋较合适.</p><p>执行时间长, 线程数叫多的情况下, 用系统锁更合适.</p><h4 id="锁对象发生改变"><a href="#锁对象发生改变" class="headerlink" title="锁对象发生改变"></a>锁对象发生改变</h4><p>锁定某对象o, 如果o的属性发生改变, 不影响锁的使用. 但是如果o变成另外一个对象, 则锁定的对象发生改变.</p><p>因为synchronized是使用对象头中的markword来判断锁类型, </p><p>当前锁的是o对象, 如果使 <code>o = new Object();</code>这种情况下锁对象的markword又重置回没有加锁的状态, 会出现问题.</p><p>所以应在锁对象上加上final修饰,以免引用发生改变.</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h4><p>首先看个例子:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test08</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"m start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>running<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"m end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test08 t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test08</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>t<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        t<span class="token punctuation">.</span>running <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>启动main线程, 在main中开启了一个线程执行m方法, 如果running没有改变的话, 应该是一个死循环, 永远也不会输出”m end”.</p><p>在子线程启动后, 主线程睡眠1毫秒, 确保子线程正在进行死循环.</p><p>然后将running设置为false.</p><p>按照一般想法, running设置为false, 死循环条件不成立. 结束循环,打印”m end”, 然后结束.</p><p>实际上输出了”m start”和”main end”之后 , 程序就一直等在这里.</p><p>解决这个问题的方法就是将running加个<code>volatile</code>修饰.</p><p>volatile这个词的含义是可变的,易变的.</p><h4 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h4><p>volatile有两个作用</p><ol><li>保证线程可见性</li><li>禁止指令重排序</li></ol><p><strong>保证可见性</strong></p><p><img src="/2020/06/29/2020-06-29/%E7%BA%BF%E7%A8%8B%E5%8F%98%E9%87%8F%E5%89%AF%E6%9C%AC.jpg" alt></p><p>在上图中, t1,t2分别持有在堆中flag变量值的副本.</p><p>因为JVM是一个虚拟的计算机, 所以和真实的计算机很像. </p><p>每个线程都会从堆中读取出变量的值,维护在自己的工作内存中.</p><p>因此t1线程中改变了flag的值, 然后写回堆中, 而并没有通知其他使用到flag的线程.</p><p>另一方面, t2中使用flag仍在使用的他自己维护的工作内存中的内容, 什么时候使用flag已经改掉的值也是没法控制的.</p><p>这种情况就叫做线程之间不可见.</p><p>在硬件上, 多核CPU之间变量的改变是通过<code>MESI协议</code>进行同步的.</p><p>而线程是跑在各个CPU上的, 所以volatile也是通过该协议实现的.</p><p><strong>禁止指令重排序</strong></p><p>指令重排序也是CPU上出现的问题, 现在的CPU为了执行的效率, 会进行指令的乱序执行.</p><p>即 会分析找出那些互相没有关联可以并发执行的指令，然后送到几个独立的执行单元进行并发执行.</p><p>指令重排序的一个例子是单例模式的双重检查式.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面是一段双重检查的单例模式, instance前面没有加volatile修饰, 运行多次也不会出现什么问题.</p><p>但是这个volatile要不要加?</p><p>结果是要的.</p><p>因为<code>instance = new Singleton();</code> 的时候, 编译器编译之后, 这条指令会分为三步, </p><ol><li>申请内存</li><li>给这个对象的成员变量初始化</li><li>把这块内存的内容复制给instance</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Object o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>比如这一小段代码, 就是做了一个new的操作.</p><p><img src="/2020/06/29/2020-06-29/new%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81.jpg" alt></p><p>查看他的字节码, 可以发现实际上有四行字节码指令来完成一行new代码的.</p><p>如果发生了指令重排序, 2和3换了位置,就会出现这个实例在初始化到一半的时候, 就赋值给instance这个变量了.</p><p>如果t1是第一次调用这个方法, getInstance()执行到new一半的时候, 即 执行完 1, 3时, 此时该对象的成员变量还没有初始化, 如果是基础数据类型会有默认值如0, false之类.</p><p>这个时候t2也过来调用getInstance()这个方法, 此时进入第一个if判断instance是否为null, 因为3已经执行过了 所以instance不为null, 那么t2执行这个方法就直接返回了.</p><p> t2拿到这个实例之后可能会调用里面的一些成员变量, 也就是有可能会拿到未初始化的成员变量的值. </p><p>这有可能会出现我们并不想要出现的情况.</p><h4 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h4><p>首先看一个例子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test09</span> <span class="token punctuation">{</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test09 t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test09</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Thread<span class="token operator">></span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            threads<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>t<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"thread"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        threads<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> o<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threads<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                o<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在main线程中开启十个线程, 每个线程都对count做10000次自增操作.</p><p>最后结果预期应该是 10个线程 * 10000 = 100000.</p><p>但是实际输出会小于100000.</p><p>为什么呢? </p><p>因为自增在字节码指令中不是一个原子操作.</p><p>比如有t1,t2两个线程正在同时做操作, 此时count为0.</p><p>t1读取count为0, t2读取count为0.</p><p>t1做了自增操作此时count为1, t2也做了自增操作此时count为1.</p><p>t1将count为1写回堆中, t2感知到了t1的修改, 放弃了工作内存中保存的count值,重新从堆中读取到count为1.</p><p>t1写完结束, t2将count为1写回堆中, t2结束.</p><p>t1和t2两个线程都做了count++的操作, 按理count应该为2.</p><p>但是因为t2在执行时已经做完增加的操作, 感知到t1的提交后放弃了该操作, 导致这时的count值不对.</p><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test10</span> <span class="token punctuation">{</span>   AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// count++</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Test10 t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test10</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      List<span class="token operator">&lt;</span>Thread<span class="token operator">></span> threads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         threads<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token operator">:</span><span class="token operator">:</span>m<span class="token punctuation">,</span> <span class="token string">"thread"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      threads<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> o<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      threads<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>         <span class="token keyword">try</span> <span class="token punctuation">{</span>            o<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>原子类是Java提供是一系列原子操作, 上面这段代码可以看到, 多线程并发的情况下, 如果是普通的int型, 会需要加锁保证线程安全.</p><p>而使用了AtomicInteger就不需要加锁, 他本身就是线程安全的操作.</p><p>Atomic类的原理是CAS操作,</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// AtomicInteger.java</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// UnSafe.java</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> var5<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到, 在UnSafe类中使用了compareAndSwapInt()方法来保证原子操作.</p><p>CAS的含义是 Compare And Set</p><p>比较 并且 设置.</p><p>cas(V, Expected, NewValue)</p><p>​    if V == Expected</p><p>​    V = NewValue</p><p>​    otherWise try again or fail</p><p>如果该变量的值是我期望的值, 我就把他设置成一个新的值. 如果不是期望的值, 说明已经有其他线程更改了这个值. 这个时候就可以再试一遍或者失败操作.</p><p>那如果在判断变量值等于期望值的时候, 还没来得及将变量值修改为新的值, 就被其他线程打断了. 这时候怎么办呢?</p><p>CAS是CPU原语层面的支持, 确保了原子性不能被打断.</p><p><strong>ABA问题</strong></p><p>在CAS中会产生一个ABA问题, 比如一个变量i, 预期是1, 新值是2. </p><p>t1进行CAS操作的时候, 如果已经将i改为2, 在执行结束将要退出的时候, 再次判断.</p><p>此时只能判断i为2, 而不能判断出i是否经历过由2变为3或者其他值, 又再次变成2的过程.</p><p>而这不是我们想要的, 我们想要的是t1修改了之后其他所有人都不能再操作成功.</p><p>若想解决这个问题, 在CAS的时候加一个版本号, 每次CAS成功都将版本号+1.</p><h4 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h4><p>Unsafe是直接操作JVM中的内存.</p><p>在Java8中是不能直接使用的, 在Java11中做个改变,可以直接获取到了. 而且都改成了弱引用.</p><ul><li>直接操作内存<ul><li>allocateMemory</li><li>putXXX</li><li>freeMemory</li><li>pageSize</li></ul></li><li>直接生成类实例<ul><li>allocateInstance</li></ul></li><li>直接操作类或实例变量<ul><li>objectFieldOffset</li><li>getInt</li><li>getObject</li></ul></li><li>CAS相关操作<ul><li>compareAnsSwapObject</li><li>compareAnsSwapInt</li><li>compareAnsSwapLong</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK动态代理和CGLIB动态代理</title>
      <link href="/2020/06/28/2020-06-28/"/>
      <url>/2020/06/28/2020-06-28/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK动态代理和CGLIB动态代理"><a href="#JDK动态代理和CGLIB动态代理" class="headerlink" title="JDK动态代理和CGLIB动态代理"></a>JDK动态代理和CGLIB动态代理</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理模式是一种常用的设计模式, 代表性的有Spring中的AOP.</p><p>代理模式就像是一个中介一样, 以租房为例.</p><p>房东作为被代理类, 租客作为调用方, 中介就是租客和房东中间的代理. 在中介的操作下, 租客租下了房间, 中介在中间做了一些事情.</p><p>代理分为静态代理和动态代理.</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理就是预先写好的代理类.</p><p>举个例子:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// IRoom.java</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IRoom</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">rent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Room.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Room</span> <span class="token keyword">implements</span> <span class="token class-name">IRoom</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"房东收租金100块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Client.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Room room <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Room</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        room<span class="token punctuation">.</span><span class="token function">rent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出:</p><pre><code>房东收租金100块</code></pre><p>很简单一个例子, 直接找房东租房, 房东直接收租金100块.</p><p>加上代理:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// IRoom.java</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IRoom</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">rent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Room.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Room</span> <span class="token keyword">implements</span> <span class="token class-name">IRoom</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"房东收租金100块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// RoomProxy.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RoomProxy</span> <span class="token keyword">implements</span> <span class="token class-name">IRoom</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> IRoom iRoom<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">RoomProxy</span><span class="token punctuation">(</span>IRoom iRoom<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>iRoom <span class="token operator">=</span> iRoom<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中介收中介费10块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iRoom<span class="token punctuation">.</span><span class="token function">rent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中介收手续费1块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Client.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RoomProxy roomProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RoomProxy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Room</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        roomProxy<span class="token punctuation">.</span><span class="token function">rent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出:</p><pre><code>中介收中介费10块房东收租金100块中介收手续费1块</code></pre><p>可以看到, 代理的含义就是在一个代理类中, 调用被代理类的方法, 在调用中可以做一些额外的事情.</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理大概可以分两类:</p><ul><li>JDK动态代理</li><li>CGLIB动态代理</li></ul><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 被代理类实现的接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ITeacherDao</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 被代理类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TeacherDao</span> <span class="token keyword">implements</span> <span class="token class-name">ITeacherDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"teachDao teach"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 代理类工厂</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Object teacherDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ProxyFactory</span><span class="token punctuation">(</span>Object teacherDao<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>teacherDao <span class="token operator">=</span> teacherDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * public static Object newProxyInstance(ClassLoader loader,     *                                           Class&lt;?>[] interfaces,     *                                           InvocationHandler h)     *     * 1. ClassLoader loader : 指定当前目标对象使用的类加载器获取加载器的方法固定     * 2. Class&lt;?>[] interfaces : 目标对象实现的接口类型, 使用泛型的方式确认类型     * 3. InvocationHandler h : 事件处理, 执行目标对象的方法时,会触发事件处理器的方法, 会把当前执行的目标对象方法作为参数传入     *     * @return     */</span>    <span class="token keyword">public</span> Object <span class="token function">getNewProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>teacherDao<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> teacherDao<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"jdk代理开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Object returnVal <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>teacherDao<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"jdk代理结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> returnVal<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 调用方</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span><span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ProxyFactory proxyFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TeacherDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ITeacherDao newProxyInstance <span class="token operator">=</span> <span class="token punctuation">(</span>ITeacherDao<span class="token punctuation">)</span>proxyFactory<span class="token punctuation">.</span><span class="token function">getNewProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newProxyInstance<span class="token punctuation">.</span><span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>newProxyInstance<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到, 虽然添加了一个<code>ProxyFactory</code>的类, 但是该类持有的是一个Object类型的对象, 也就是说, 该类可以创建’任何’类的代理对象.</p><p>为什么要把[任何]两个字打双引号呢?</p><p>主要看这一句代码:</p><p>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</p><p>这里面有三个参数:</p><ol><li>ClassLoader loader: 指定使用哪个类加载器加载该生成的代理对象</li><li>Class&lt;?&gt;[] interfaces: 传入该类实现的接口</li><li>InvocationHandler h: 执行方法时的事件处理器</li></ol><p>可以看到, 第二个参数<code>Class&lt;?&gt;[] interfaces</code>是要求该被代理类必须要实现接口的, 因此JDK的动态代理只能代理实现了接口的类.</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ProxyGenerator</span><span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">generateClassFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 添加hashCode(),equals(),toString()方法</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addProxyMethod</span><span class="token punctuation">(</span>hashCodeMethod<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addProxyMethod</span><span class="token punctuation">(</span>equalsMethod<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addProxyMethod</span><span class="token punctuation">(</span>toStringMethod<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取代理类的接口</span>    Class<span class="token punctuation">[</span><span class="token punctuation">]</span> var1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>interfaces<span class="token punctuation">;</span>    <span class="token keyword">int</span> var2 <span class="token operator">=</span> var1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> var3<span class="token punctuation">;</span>    Class <span class="token class-name">var4</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var3 <span class="token operator">&lt;</span> var2<span class="token punctuation">;</span> <span class="token operator">++</span>var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>        var4 <span class="token operator">=</span> var1<span class="token punctuation">[</span>var3<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取接口中的方法</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> var5 <span class="token operator">=</span> var4<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> var6 <span class="token operator">=</span> var5<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var7 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var7 <span class="token operator">&lt;</span> var6<span class="token punctuation">;</span> <span class="token operator">++</span>var7<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Method var8 <span class="token operator">=</span> var5<span class="token punctuation">[</span>var7<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 添加代理方法</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addProxyMethod</span><span class="token punctuation">(</span>var8<span class="token punctuation">,</span> var4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    Iterator var11 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>proxyMethods<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List var12<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>var11<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        var12 <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span>var11<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">checkReturnTypes</span><span class="token punctuation">(</span>var12<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Iterator var15<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将方法添加进class文件中</span>        <span class="token comment" spellcheck="true">// 添加生成的构造方法</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>methods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">generateConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        var11 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>proxyMethods<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>var11<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            var12 <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span>var11<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var15 <span class="token operator">=</span> var12<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>var15<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ProxyGenerator<span class="token punctuation">.</span>ProxyMethod var16 <span class="token operator">=</span> <span class="token punctuation">(</span>ProxyGenerator<span class="token punctuation">.</span>ProxyMethod<span class="token punctuation">)</span>var15<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>fields<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProxyGenerator<span class="token punctuation">.</span>FieldInfo</span><span class="token punctuation">(</span>var16<span class="token punctuation">.</span>methodFieldName<span class="token punctuation">,</span> <span class="token string">"Ljava/lang/reflect/Method;"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>methods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>var16<span class="token punctuation">.</span><span class="token function">generateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>methods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">generateStaticInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var10<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span><span class="token string">"unexpected I/O Exception"</span><span class="token punctuation">,</span> var10<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>methods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">65535</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"method limit exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>fields<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">65535</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"field limit exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cp<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token function">dotToSlash</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>className<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cp<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token string">"java/lang/reflect/Proxy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        var1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>interfaces<span class="token punctuation">;</span>        var2 <span class="token operator">=</span> var1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var3 <span class="token operator">&lt;</span> var2<span class="token punctuation">;</span> <span class="token operator">++</span>var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            var4 <span class="token operator">=</span> var1<span class="token punctuation">[</span>var3<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>cp<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token function">dotToSlash</span><span class="token punctuation">(</span>var4<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cp<span class="token punctuation">.</span><span class="token function">setReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteArrayOutputStream var13 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        DataOutputStream var14 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOutputStream</span><span class="token punctuation">(</span>var13<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            var14<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">889275714</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var14<span class="token punctuation">.</span><span class="token function">writeShort</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var14<span class="token punctuation">.</span><span class="token function">writeShort</span><span class="token punctuation">(</span><span class="token number">49</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>cp<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>var14<span class="token punctuation">)</span><span class="token punctuation">;</span>            var14<span class="token punctuation">.</span><span class="token function">writeShort</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>accessFlags<span class="token punctuation">)</span><span class="token punctuation">;</span>            var14<span class="token punctuation">.</span><span class="token function">writeShort</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cp<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token function">dotToSlash</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>className<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var14<span class="token punctuation">.</span><span class="token function">writeShort</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cp<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token string">"java/lang/reflect/Proxy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var14<span class="token punctuation">.</span><span class="token function">writeShort</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>interfaces<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            Class<span class="token punctuation">[</span><span class="token punctuation">]</span> var17 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>interfaces<span class="token punctuation">;</span>            <span class="token keyword">int</span> var18 <span class="token operator">=</span> var17<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var19 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var19 <span class="token operator">&lt;</span> var18<span class="token punctuation">;</span> <span class="token operator">++</span>var19<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Class <span class="token class-name">var22</span> <span class="token operator">=</span> var17<span class="token punctuation">[</span>var19<span class="token punctuation">]</span><span class="token punctuation">;</span>                var14<span class="token punctuation">.</span><span class="token function">writeShort</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cp<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token function">dotToSlash</span><span class="token punctuation">(</span>var22<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            var14<span class="token punctuation">.</span><span class="token function">writeShort</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>fields<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var15 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fields<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>var15<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ProxyGenerator<span class="token punctuation">.</span>FieldInfo var20 <span class="token operator">=</span> <span class="token punctuation">(</span>ProxyGenerator<span class="token punctuation">.</span>FieldInfo<span class="token punctuation">)</span>var15<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                var20<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>var14<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            var14<span class="token punctuation">.</span><span class="token function">writeShort</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>methods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var15 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>methods<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>var15<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ProxyGenerator<span class="token punctuation">.</span>MethodInfo var21 <span class="token operator">=</span> <span class="token punctuation">(</span>ProxyGenerator<span class="token punctuation">.</span>MethodInfo<span class="token punctuation">)</span>var15<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                var21<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>var14<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            var14<span class="token punctuation">.</span><span class="token function">writeShort</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> var13<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var9<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span><span class="token string">"unexpected I/O Exception"</span><span class="token punctuation">,</span> var9<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="/2020/06/28/2020-06-28/%E4%BB%A3%E7%90%86%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95.jpg" alt></p><p>从上面的代码可以看到, JDK中添加代理类是使用获取接口, 从接口获取方法再添加到class文件中.</p><p>因此JDK中动态代理的劣势就是要求被代理类必须要实现接口.</p><p><strong>保存动态生成的代理类</strong></p><p>在代码中添加下面一行代码就可以将生成的代理类保存下来, 默认保存地址是当前工作路径的 <code>com.sun.proxy</code>包下.</p><pre><code>System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code></pre><h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><p>CGLIB动态代理就规避了这个问题, 不再要求被代理类必须实现接口, 而且写起来更加简单, 只需要在pom文件里添加cglib的引用即可.</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;3.2.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>代码:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 被代理类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TeacherDao</span> <span class="token keyword">implements</span> <span class="token class-name">ITeacherDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"teachDao rent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 调用方</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>TeacherDao<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始cglib代理"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Object invoke <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> objects<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结束cglib代理"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> invoke<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TeacherDao o <span class="token operator">=</span> <span class="token punctuation">(</span>TeacherDao<span class="token punctuation">)</span>enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        o<span class="token punctuation">.</span><span class="token function">teach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出:</p><pre><code>开始cglib代理teachDao rent结束cglib代理</code></pre><p>可以看到, <code>enhancer.setSuperclass(TeacherDao.class);</code>设置的是SuperClass, </p><p>而调用中<code>Object invoke = methodProxy.invokeSuper(o, objects);</code>也是使用<code>invokeSuper</code>的方式调用的.</p><p>因此CGLIB生成的代理类是被代理类的子类.</p><p>如果该被代理类被声明为final, 就无法使用CGLIB生成代理类了.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO API</title>
      <link href="/2020/06/12/2020-6-12/"/>
      <url>/2020/06/12/2020-6-12/</url>
      
        <content type="html"><![CDATA[<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="NIO简介"><a href="#NIO简介" class="headerlink" title="NIO简介"></a>NIO简介</h2><p>Java NIO (New IO  /  Non Blocking IO)<br>是从Java1.4版本开始引入的一个新的IO API, 可以的替代标准的Java IO API.<br>NIO与原来的IO有同样的作用和目的, 但是使用的方式完全不同, NIO支持面向缓冲区的,基于通道的IO操作.<br>NIO将以更加高效的方式进行文件的读写操作.</p><p><strong>NIO与IO的主要区别</strong></p><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区</td></tr><tr><td>阻塞IO (Blocking IO)</td><td>非阻塞IO (Non Blocking IO)</td></tr><tr><td>(无)</td><td>选择器(Selectors)</td></tr></tbody></table><h2 id="通道和缓冲区"><a href="#通道和缓冲区" class="headerlink" title="通道和缓冲区"></a>通道和缓冲区</h2><p>NIO系统的核心在于: 通道(Channel)和缓冲区(Buffer).<br>通道表示打开到IO设备(例如:文件,套接字)的连接.<br>若需要使用NIO系统, 需要获取用于连接IO设备的通道一级用于容纳数据的缓冲区.<br>然后操作缓冲区, 对数据进行处理.</p><p><code>简而言之, Channel负责传输, Buffer负责存储</code></p><h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer):"></a>缓冲区(Buffer):</h3><p>在JAVA NIO中负责数据的存取. 缓冲区就是数组,用于存储不同数据类型的数据.</p><p>根据数据类型不同(boolean除外),提供了相应类型的缓冲区:</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>上述缓冲区的管理方法几乎一致,通过allocate()获取缓冲区</p><p>缓冲区存取数据的两个核心方法:</p><ul><li>put(): 存入数据到缓冲区中</li><li>get(): 获取缓冲区中的数据</li></ul><p>Buffer的核心属性:</p><ul><li>capacity: 容量,表示缓冲区中最大存储数据的容量. 一旦声明不能改变.</li><li>limit: 界限,表示缓冲区中可以操作数据的大小. (limit后的数据不能进行读写)</li><li>position: 位置, 表示缓冲区中正在操作数据的位置.</li><li>mark: 标记, 表示记录当前position的位置,可以通过reset()恢复到mark的位置</li></ul><p>mark &lt;= position &lt;= limit &lt;= capacity</p><p>缓冲区的测试代码: </p><pre><code>@Testpublic void test01(){    String str = &quot;abcde&quot;;    // 1. 分配一个指定大小的缓冲区    ByteBuffer allocate = ByteBuffer.allocate(1024);    System.out.println(&quot;---------allocate()------------&quot;);    System.out.println(allocate.position());    // 0    System.out.println(allocate.limit());       // 1024    System.out.println(allocate.capacity());    // 1024    // 2. 利用put()存入数据到缓冲区中    System.out.println(&quot;-------put()--------&quot;);    allocate.put(str.getBytes());    System.out.println(allocate.position());    // 5    System.out.println(allocate.limit());       // 1024    System.out.println(allocate.capacity());    // 1024    // 3. 切换读取数据模式    System.out.println(&quot;---------flip()------------&quot;);    allocate.flip();    System.out.println(allocate.position());    // 0    System.out.println(allocate.limit());       // 5    System.out.println(allocate.capacity());    // 1024    // 4. 利用get() 读取缓冲区中的数据    System.out.println(&quot;--------get()------------&quot;);    byte[] dst = new byte[allocate.limit()];    // {0,0,0,0,0}    allocate.get(dst);    System.out.println(new String(dst, 0, dst.length));    System.out.println(&quot;---------after get()------------&quot;);    System.out.println(allocate.position());    // 5    System.out.println(allocate.limit());       // 5    System.out.println(allocate.capacity());    // 1024    // 5. rewind() 可重复读数据    allocate.rewind();    System.out.println(&quot;---------rewind()------------&quot;);    System.out.println(allocate.position());    // 0    System.out.println(allocate.limit());       // 5    System.out.println(allocate.capacity());    // 1024    // 6. 清空缓冲区. 但是缓冲区中的数据依然存在,但是处于&quot;被遗忘&quot;状态    allocate.clear();    System.out.println(&quot;---------clear()------------&quot;);    System.out.println(allocate.position());    // 0    System.out.println(allocate.limit());       // 1024    System.out.println(allocate.capacity());    // 1024    System.out.println((char)allocate.get());   // &#39;a&#39;    System.out.println(allocate.position());    // 1}@Testpublic void test02(){    String str = &quot;abcde&quot;;    ByteBuffer allocate = ByteBuffer.allocate(1024);    // 缓冲区中存入数据    allocate.put(str.getBytes());    // 切换读模式    allocate.flip();    byte[] bytes = new byte[allocate.limit()];    // 读两个, 从bytes数组的索引0开始存    allocate.get(bytes, 0, 2);    System.out.println(new String(bytes));      // ab    // 标记当然读到的位置    allocate.mark();    // 再读两个,从bytes数组的索引2开始存    allocate.get(bytes, 2,2);    System.out.println(new String(bytes));      // abcd    System.out.println(allocate.position());    // 4    // 将position,读指针重置到mark处    allocate.reset();    System.out.println(allocate.position());    // 2    System.out.println(&quot;-----------&quot;);    // 判断缓冲区中是否还有剩余数据    if (allocate.hasRemaining()){               // 现在position=2, limit=5        // 获取缓冲区中还要操作的数量        System.out.println(allocate.remaining());// limit-position    }}</code></pre><p><strong>直接缓冲区与非直接缓冲区</strong></p><p>非直接缓冲区: 通过allocate()方法分配缓冲区, 将缓冲区建立在JVM的内存中<br>直接缓冲区: 通过allocateDirect()方法分配直接缓冲区,将缓冲区建立在操作系统的物理内存中. 可以提高效率.</p><ul><li>字节缓冲区要么是直接的,要么是非直接的. 如果为直接字节缓冲区,则Java虚拟机会尽最大努力直接在此缓冲区上执行本机IO操作. 也就是说, 在每次调用基础操作系统的一个本机IO操作之前(或之后),虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中(或从中间缓冲区中复制内容).</li><li>直接字节缓冲区可以通过调用此类的allocateDirect()工厂方法来创建. 此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区. 直接缓冲区的内容可以驻留在常规的垃圾回收堆之外, 因此,他们对应用程序的内存需求量造成的影响可能并不明显. 所以, 建议将直接缓冲区主要分配给哪些易受基础系统的本机IO操作影响的大型,持久的缓冲区. 一般情况下, 最好仅在直接缓冲区能再程序性能方面带来明显好处时分配他们.</li><li>直接字节缓冲区还可以通过FileChannel的map()方法将文件区域直接映射到内存中来创建. 该方法返回MappedByteBuffer. Java平台的实现有助于通过JNI从本机代码创建直接字节缓冲区. 如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域, 则试图访问该区域不会更改该缓冲区的内容, 并且将会在访问期间或稍后的某个时间导致抛出不确定的异常.</li><li>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其isDirect()方法来确定. 提供此方法是为了能够在性能关键型代码中执行显示缓冲区管理.</li></ul><p><img src="/2020/06/12/2020-6-12/%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="非直接缓冲区"></p><p><img src="/2020/06/12/2020-6-12/%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="直接缓冲区"></p><p>当应用程序发起一个read请求时, 磁盘中的数据没法直接传到应用程序中.<br>磁盘中的数据会<strong>首先读到内核地址空间</strong>中, 然后在<strong>内核地址空间的数据会copy到用户地址空间</strong>中, 然后数据才会读到应用程序中.<br>写数据是同样的需要copy一次.<br>在这个过程中, copy这步操作显得略微多余, 于是NIO中提出了内存映射文件,也叫直接缓冲区.<br>他在内核地址空间和用户地址空间之间, 在物理内存中直接开辟了一块缓冲区.因此把中间copy的过程省掉了.</p><p>但是开辟直接缓冲区的消耗是比较大的. 而且直接缓冲区脱离了JVM的控制, 完全由操作系统控制,</p><pre><code>@Testpublic void test03(){    ByteBuffer buf = ByteBuffer.allocateDirect(1024);    // 判断是否是直接缓冲区    System.out.println(buf.isDirect()); // true}</code></pre><h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><ol><li><p>通道: 由java.nio.channels包定义的. Channel表示IO源与目标打开的连接.<br>Channel类似于传统的”流”. 只不过Channel本身不能直接访问数据, Channel只能与Buffer进行交互.</p></li><li><p>通道的主要实现类<br>java.nio.channels.Channel 接口:<br>FileChannel<br>SocketChannel<br>ServerSocketChannel<br>DatagramChannel</p></li><li><p>获取通道</p><ul><li><p>Java针对支持通道的类提供了getChannel()方法<br>  本地IO:<br>  FileInputStream/FileOutputStream<br>  RandomAccessFile</p><p>  网络IO:<br>  Socket<br>  ServerSocket<br>  DatagramSocket</p></li><li><p>在 JDK 1.7 中的NIO.2 针对各个通道提供了静态方法 open()</p></li><li><p>在 JDK 1.7 中的NIO.2 的Files工具类的newByteChannel()</p></li></ul></li></ol><p>利用通道完成文件的复制</p><pre><code>@Testpublic void test01() throws IOException {    File file = new File(&quot;1.txt&quot;);    System.out.println(file.getAbsolutePath());    FileInputStream in = new FileInputStream(&quot;1.txt&quot;);    FileOutputStream out = new FileOutputStream(&quot;2.txt&quot;);    // 1. 获取通道    FileChannel inChannel = in.getChannel();    FileChannel outChannel = out.getChannel();    // 2. 分配指定大小的缓冲区    ByteBuffer buf = ByteBuffer.allocate(1024);    // 3. 将通道中的数据存到缓冲区中    while (inChannel.read(buf) != -1){        // 切换成读数据模式        buf.flip();         // 4. 将缓冲区的数据写入通道        outChannel.write(buf);        buf.clear();// 清空缓冲区    }    // close要放在try块的finally里确保关闭    outChannel.close();    inChannel.close();    out.close();    in.close();}</code></pre><p>使用直接缓冲区完成文件复制(内存映射文件)</p><pre><code>@Testpublic void test02() throws IOException {    FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.txt&quot;), StandardOpenOption.READ);    FileChannel outChannel = FileChannel.open(Paths.get(&quot;2.txt&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.READ);    // 内存映射文件    MappedByteBuffer inMapBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());    MappedByteBuffer outMapBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());    // 直接对缓冲区进行数据的读写操作    byte[] dst = new byte[inMapBuffer.limit()];    inMapBuffer.get(dst);    outMapBuffer.put(dst);    inChannel.close();    outChannel.close();}</code></pre><ol start="4"><li>通道之间的数据传输<br>transferFrom()<br>transferTo()</li></ol><pre><code>@Testpublic void test03() throws IOException {    FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.txt&quot;), StandardOpenOption.READ);    FileChannel outChannel = FileChannel.open(Paths.get(&quot;2.txt&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.READ);//  inChannel.transferTo(0, inChannel.size(), outChannel);    outChannel.transferFrom(inChannel, 0, inChannel.size());    inChannel.close();    outChannel.close();}</code></pre><p><strong>分散(Scatter)聚集(Gather)</strong><br>分散读取(Scattering Reads): 将通道中的数据分散到多核缓冲区中<br>聚集写入(Gathering Writes): 将多个缓冲区中的数据聚集到通道中</p><pre><code>// 分散和聚集@Testpublic void test04() throws IOException {    RandomAccessFile raf1 = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;);    // 1. 获取通道    FileChannel channel1 = raf1.getChannel();    // 2. 分配指定大小的缓冲区    ByteBuffer buf1 = ByteBuffer.allocate(100);    ByteBuffer buf2 = ByteBuffer.allocate(1024);    ByteBuffer[] bufs = {buf1, buf2};    // 3. 分散读取    channel1.read(bufs);    for (ByteBuffer byteBuffer : bufs) {        byteBuffer.flip();    }    System.out.println(new String(bufs[0].array(), 0, bufs[0].limit()));    System.out.println(&quot;---------------&quot;);    System.out.println(new String(bufs[1].array(), 0, bufs[1].limit()));    RandomAccessFile raf2 = new RandomAccessFile(&quot;2.txt&quot;, &quot;rw&quot;);    FileChannel channel2 = raf2.getChannel();    channel2.write(bufs);    channel2.close();    channel1.close();}</code></pre><p>**字符集: Charset<br>编码: 字符串 -&gt; 字节数组<br>解码: 字节数组 -&gt; 字符串</p><pre><code>@Testpublic void test06() throws CharacterCodingException {    Charset cs1 = Charset.forName(&quot;GBK&quot;);    // 获取编码器    CharsetEncoder ce = cs1.newEncoder();    // 获取解码器    CharsetDecoder cd = cs1.newDecoder();    CharBuffer cBuf = CharBuffer.allocate(1024);    cBuf.put(&quot;安抚无法发泄出&quot;);    cBuf.flip();    // 编码    ByteBuffer bBuf = ce.encode(cBuf);    for (int i = 0; i &lt; bBuf.limit(); i++) {        System.out.println(bBuf.get());    }    // 解码    bBuf.flip();    CharBuffer cBuf2 = cd.decode(bBuf);    System.out.println(cBuf2.toString());}</code></pre><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p><strong>一个阻塞socket</strong></p><pre><code>// 客户端向服务端发送一个文件@Testpublic void client() throws IOException {    // 1. 获取通道    SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9898));    FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.txt&quot;), StandardOpenOption.READ);    // 2. 分配指定大小的缓冲区    ByteBuffer buf = ByteBuffer.allocate(1024);    // 3. 读取本地文件并发送到服务端    while (inChannel.read(buf) != -1){        buf.flip();        socketChannel.write(buf);        buf.clear();    }    // 4. 关闭通道    inChannel.close();    socketChannel.close();}// 服务端接受文件并写到硬盘上@Testpublic void server() throws IOException {    // 1. 获取通道    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();    // 2. 绑定连接    serverSocketChannel.bind(new InetSocketAddress(9898));    FileChannel inChannel = FileChannel.open(Paths.get(&quot;2.txt&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE);    // 3. 获取客户端连接的通道    SocketChannel socketChannel = serverSocketChannel.accept();    // 4. 分配一个指定大小的缓冲区    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);    // 4. 接收客户端的数据,并保存到本地.    while (socketChannel.read(byteBuffer) != -1){        byteBuffer.flip();        inChannel.write(byteBuffer);        byteBuffer.clear();    }    inChannel.close();    socketChannel.close();    serverSocketChannel.close();}</code></pre><p><strong>阻塞式,带回应socket</strong></p><pre><code>@Testpublic void client() throws IOException {    SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9898));    FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.txt&quot;), StandardOpenOption.READ);    ByteBuffer buf = ByteBuffer.allocate(1024);    while (inChannel.read(buf) != -1){        buf.flip();        sChannel.write(buf);        buf.clear();    }    // 关闭输出流, 告诉服务端数据已经发送完了    sChannel.shutdownOutput();    int len = 0;    while ((len = sChannel.read(buf)) != -1){        buf.flip();        System.out.println(new String(buf.array(), 0, len));        buf.clear();    }    inChannel.close();    sChannel.close();}@Testpublic void server() throws IOException {    ServerSocketChannel ssChannel = ServerSocketChannel.open();    FileChannel outChannel = FileChannel.open(Paths.get(&quot;2.txt&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE);    ssChannel.bind(new InetSocketAddress(9898));    SocketChannel sChannel = ssChannel.accept();    ByteBuffer buf = ByteBuffer.allocate(1024);    while (sChannel.read(buf) != -1){        buf.flip();        outChannel.write(buf);        buf.clear();    }    //发送反馈给客户端    buf.put(&quot;服务端接收数据成功&quot;.getBytes());    buf.flip();    sChannel.write(buf);    sChannel.shutdownOutput();    sChannel.close();    outChannel.close();    ssChannel.close();}</code></pre><p><strong>非阻塞模式</strong></p><p>选择器(Selector): 选择器是SelectableChannel对象的多路复用器, Selector可以同时监控多个SelectableChannel的IO状况, 也就是说, 利用Selector可使一个单独的线程管理多个Channel. Selector是非阻塞IO的核心.</p><p>选择器的应用:</p><p>创建Selector: 通过调用Selector.open()方法创建一个Selector.<br>向选择器注册通道: SelectableChannel.register(Selector sel, int ops);<br>当调用register(Selector sel, int ops)将通道注册选择器时, 选择器对通道的监听事件, 需要通过第二个参数ops指定.<br>可以监听的事件类型(可使用SelectionKey的四个常量表示):<br>    - 读: SelectionKey.OP_READ(1)<br>    - 写: SelectionKey.OP_WRITE(4)<br>    - 连接: SelectionKey.OP_CONNECT(8)<br>    - 接收: SelectionKey.OP_ACCEPT(16)<br>若注册时不止监听一个事件, 则可以使用”位或”操作符连接<br>    &gt; int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; </p><pre><code>@Testpublic void client() throws IOException {    // 1. 获取通道    SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9898));    // 2. 切换到非阻塞模式    sChannel.configureBlocking(false);    // 3. 分配指定大小的缓冲区    ByteBuffer buf = ByteBuffer.allocate(1024);    // 4. 发送数据给服务端    buf.put(LocalDateTime.now().toString().getBytes());    buf.flip();    sChannel.write(buf);    buf.clear();    // 关闭连接    sChannel.close();}@Testpublic void server() throws IOException {    // 1. 获取通道    ServerSocketChannel ssChannel = ServerSocketChannel.open();    // 2. 绑定端口    ssChannel.bind(new InetSocketAddress(9898));    // 3. 切换到非阻塞模式    ssChannel.configureBlocking(false);    // 4. 获取选择器    Selector selector = Selector.open();    // 5. 将通道注册到选择器上, 并且指定监听事件    ssChannel.register(selector, SelectionKey.OP_ACCEPT);    // 6. 轮询式的获取选择器上已经&quot;准备就绪&quot;的事件    while (selector.select() &gt; 0){        // 7. 获取当前选择器中所有注册的&quot;选择键(已就绪的监听事件)&quot;        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();        while (it.hasNext()){            // 8. 获取准备就绪的事件            SelectionKey selectionKey = it.next();            // 9. 判断具体是什么事件准备就绪            if (selectionKey.isAcceptable()){                // 10. 若&quot;接收就绪&quot;, 获取客户端连接                SocketChannel sChannel = ssChannel.accept();                // 11. 将客户端连接切换非阻塞模式                sChannel.configureBlocking(false);                // 12. 将该通道注册到选择器上                sChannel.register(selector, SelectionKey.OP_READ);            }else if (selectionKey.isReadable()){                // 13. 获取当前选择器上&quot;读就绪&quot;状态的通道                SocketChannel sChannel = (SocketChannel) selectionKey.channel();                // 14. 读取数据                ByteBuffer buf = ByteBuffer.allocate(1024);                int len = 0;                while ((len = sChannel.read(buf))&gt; 0){                    buf.flip();                    System.out.println(new String(buf.array(), 0, len));                    buf.clear();                }            }            // 15. 取消选择键            it.remove();        }    }}</code></pre><h2 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道(Pipe):"></a>管道(Pipe):</h2><p>Java NIO管道是两个线程之间的单向数据连接. Pipe有一个source通道和一个sink通道. 数据会被写到sink通道, 从source通道读取.</p><pre><code>@Testpublic void test1() throws IOException {    // 1. 获取管道    Pipe pipe = Pipe.open();    // 2. 将缓冲区的数据写入管道    Pipe.SinkChannel sinkChannel = pipe.sink();    ByteBuffer buf = ByteBuffer.allocate(1024);    buf.put(&quot;通过单向管道发送数据&quot;.getBytes());    buf.flip();    sinkChannel.write(buf);    buf.clear();    // 3. 读取缓冲区中的数据    Pipe.SourceChannel sourceChannel = pipe.source();    int len = sourceChannel.read(buf);    buf.flip();    System.out.println(new String(buf.array(), 0, len));}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - nio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>J.U.C (一)</title>
      <link href="/2020/06/11/2020-6-11/"/>
      <url>/2020/06/11/2020-6-11/</url>
      
        <content type="html"><![CDATA[<p>整体认识J.U.C, 之前也写过AQS相关的博客, 那时候听了一节课就匆匆忙忙的记笔记写博客, 对J.U.C也没有一个系统的学习.</p><p>最近翻到一篇博客写的挺全的,想拿来学习一下.</p><p><a href="/http://www.blogjava.net/xylz/archive/2010/07/08/325587.html">深入浅出Java Concurrcy</a></p><h2 id="整体认识"><a href="#整体认识" class="headerlink" title="整体认识"></a>整体认识</h2><p>首先要对J.U.C包下的内容做一个整体的认识.</p><ul><li>原子操作</li><li>锁</li><li>并发容器</li><li>线程池</li></ul><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><blockquote><p>“原子操作(atomic operation)是不需要synchronized”，这是多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p></blockquote><p>通常情况下，在Java里面，++i或者–i不是线程安全的，这里面有三个独立的操作：或者变量当前值，为该值+1/-1，然后写回新的值。在没有额外资源可以利用的情况下，只能使用加锁才能保证读-改-写这三个操作时“原子性”的。</p><h4 id="基本数据类型的原子操作"><a href="#基本数据类型的原子操作" class="headerlink" title="基本数据类型的原子操作"></a>基本数据类型的原子操作</h4><p>int addAndGet(int delta)<br>          以原子方式将给定值与当前值相加。 实际上就是等于线程安全版本的i =i+delta操作。</p><p>boolean compareAndSet(int expect, int update)<br>          如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 如果成功就返回true，否则返回false，并且不修改原值。</p><p>int decrementAndGet()<br>          以原子方式将当前值减 1。 相当于线程安全版本的–i操作。</p><p>int get()<br>          获取当前值。</p><p>int getAndAdd(int delta)<br>          以原子方式将给定值与当前值相加。 相当于线程安全版本的t=i;i+=delta;return t;操作。</p><p>int getAndDecrement()<br>          以原子方式将当前值减 1。 相当于线程安全版本的i–操作。</p><p>int getAndIncrement()<br>          以原子方式将当前值加 1。 相当于线程安全版本的i++操作。</p><p>int getAndSet(int newValue)<br>          以原子方式设置为给定值，并返回旧值。 相当于线程安全版本的t=i;i=newValue;return t;操作。</p><p>int incrementAndGet()<br>          以原子方式将当前值加 1。 相当于线程安全版本的++i操作。 </p><p>void lazySet(int newValue)<br>          最后设置为给定值。 延时设置变量值，这个等价于set()方法，但是由于字段是volatile类型的，因此次字段的修改会比普通字段（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修改新值的任务，原线程就不等待修改结果立即返回（这种解释其实是不正确的，但是可以这么理解）。</p><p>void set(int newValue)<br>          设置为给定值。 直接修改原始值，也就是i=newValue操作。</p><p>boolean weakCompareAndSet(int expect, int update)<br>          如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。JSR规范中说：以原子方式读取和有条件地写入变量但不 创建任何 happen-before 排序，因此不提供与除 weakCompareAndSet 目标外任何变量以前或后续读取或写入操作有关的任何保证。大意就是说调用weakCompareAndSet时并不能保证不存在happen-before的发生（也就是可能存在指令重排序导致此操作失败）。但是从Java源码来看，其实此方法并没有实现JSR规范的要求，最后效果和compareAndSet是等效的，都调用了unsafe.compareAndSwapInt()完成操作。</p><p><strong>下面的代码是一个测试样例，为了省事就写在一个方法里面来了。</strong></p><pre><code>public class AtomicIntegerTest {    @Test    public void testAll() throws InterruptedException{        final AtomicInteger value = new AtomicInteger(10);        assertEquals(value.compareAndSet(1, 2), false);        assertEquals(value.get(), 10);        assertTrue(value.compareAndSet(10, 3));        assertEquals(value.get(), 3);        value.set(0);        //        assertEquals(value.incrementAndGet(), 1);        assertEquals(value.getAndAdd(2),1);        assertEquals(value.getAndSet(5),3);        assertEquals(value.get(),5);        //        final int threadSize = 10;        Thread[] ts = new Thread[threadSize];        for (int i = 0; i &lt; threadSize; i++) {            ts[i] = new Thread() {                public void run() {                    value.incrementAndGet();                }            };        }        //        for(Thread t:ts) {            t.start();        }        for(Thread t:ts) {            t.join();        }        //        assertEquals(value.get(), 5+threadSize);    }}</code></pre><p><code>AtomicInteger</code>和<code>AtomicLong</code>、<code>AtomicBoolean</code>、<code>AtomicReference</code>差不多，这里就不介绍了。</p><h4 id="数组的原子操作"><a href="#数组的原子操作" class="headerlink" title="数组的原子操作"></a>数组的原子操作</h4><p>在这一部分开始讨论数组原子操作和一些其他的原子操作</p><p>AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray的API类似，选择有代表性的AtomicIntegerArray来描述这些问题。</p><p>int get(int i)</p><p>获取位置 i 的当前值。很显然，由于这个是数组操作，就有索引越界的问题（IndexOutOfBoundsException异常）。</p><p>对于下面的API其实和AtomicInteger是类似的</p><pre><code>void set(int i, int newValue)void lazySet(int i, int newValue)int getAndSet(int i, int newValue)boolean compareAndSet(int i, int expect, int update)boolean weakCompareAndSet(int i, int expect, int update)int getAndIncrement(int i)int getAndDecrement(int i)int getAndAdd(int i, int delta)int incrementAndGet(int i)int decrementAndGet(int i)int addAndGet(int i, int delta)</code></pre><p>整体来说，数组的原子操作在理解上还是相对比较容易的，这些API就是有多使用才能体会到它们的好处，而不仅仅是停留在理论阶段。</p><p>现在关注字段的原子更新。</p><h4 id="字段的原子操作"><a href="#字段的原子操作" class="headerlink" title="字段的原子操作"></a>字段的原子操作</h4><p>AtomicIntegerFieldUpdater<t>/AtomicLongFieldUpdater<t>/AtomicReferenceFieldUpdater&lt;T,V&gt;是基于反射的原子更新字段的值。</t></t></p><p>相应的API也是非常简单的，但是也是有一些约束的。</p><ul><li>字段必须是volatile类型的！</li><li>字段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</li><li>只能是实例变量，不能是类变量，也就是说不能加static关键字。</li><li>只能是可修改变量，不能是final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。</li><li>对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。</li></ul><p>在下面的例子中描述了操作的方法。</p><pre><code>public class AtomicIntegerFieldUpdaterDemo {   class DemoData{       public volatile int value1 = 1;       volatile int value2 = 2;       protected volatile int value3 = 3;       private volatile int value4 = 4;   }    AtomicIntegerFieldUpdater&lt;DemoData&gt; getUpdater(String fieldName) {        return AtomicIntegerFieldUpdater.newUpdater(DemoData.class, fieldName);    }    void doit() {        DemoData data = new DemoData();        System.out.println(&quot;1 ==&gt; &quot;+getUpdater(&quot;value1&quot;).getAndSet(data, 10));        System.out.println(&quot;3 ==&gt; &quot;+getUpdater(&quot;value2&quot;).incrementAndGet(data));        System.out.println(&quot;2 ==&gt; &quot;+getUpdater(&quot;value3&quot;).decrementAndGet(data));        System.out.println(&quot;true ==&gt; &quot;+getUpdater(&quot;value4&quot;).compareAndSet(data, 4, 5));    }    public static void main(String[] args) {        AtomicIntegerFieldUpdaterDemo demo = new AtomicIntegerFieldUpdaterDemo();        demo.doit();    }} </code></pre><p>在上面的例子中DemoData的字段value3/value4对于AtomicIntegerFieldUpdaterDemo类是不可见的，因此通过反射是不能直接修改其值的。</p><p>AtomicMarkableReference类描述的一个&lt;Object,Boolean&gt;的对，可以原子的修改Object或者Boolean的值，这种数据结构在一些缓存或者状态描述中比较有用。这种结构在单个或者同时修改Object/Boolean的时候能够有效的提高吞吐量。</p><p>AtomicStampedReference类维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。对比AtomicMarkableReference类的&lt;Object,Boolean&gt;，AtomicStampedReference维护的是一种类似&lt;Object,int&gt;的数据结构，其实就是对对象（引用）的一个并发计数。但是与AtomicInteger不同的是，此数据结构可以携带一个对象引用（Object），并且能够对此对象和计数同时进行原子操作。</p><p>在后面的章节中会提到“ABA问题”，而AtomicMarkableReference/AtomicStampedReference在解决“ABA问题”上很有用。</p><h4 id="指令重排序和happens-before"><a href="#指令重排序和happens-before" class="headerlink" title="指令重排序和happens-before"></a>指令重排序和happens-before</h4><p>在Java Concurrency in Practice中是这样定义线程安全的：</p><blockquote><p>当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替运行，并且不需要额外的同步及在调用方代码不必做其他的协调，这个类的行为仍然是正确的，那么这个类就是线程安全的。</p></blockquote><p>显然只有资源竞争时才会导致线程不安全，因此无状态对象永远是线程安全的。</p><p>原子操作的描述是： 多个线程执行一个操作时，其中任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤，那么这个操作就是原子的。</p><p><strong>指令重排序</strong><br>Java语言规范规定了JVM线程内部维持顺序化语义，也就是说只要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致。这个过程通过叫做指令的重排序。指令重排序存在的意义在于：JVM能够根据处理器的特性（CPU的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合CPU的执行特点，最大限度的发挥机器的性能。</p><p>程序执行最简单的模型是按照指令出现的顺序执行，这样就与执行指令的CPU无关，最大限度的保证了指令的可移植性。这个模型的专业术语叫做顺序化一致性模型。但是现代计算机体系和处理器架构都不保证这一点（因为人为的指定并不能总是保证符合CPU处理的特性）。</p><p>我们来看最经典的一个案例。</p><pre><code>public class ReorderingDemo {    static int x = 0, y = 0, a = 0, b = 0;    public static void main(String[] args) throws Exception {        for (int i = 0; i &lt; 100; i++) {            x=y=a=b=0;            Thread one = new Thread() {                public void run() {                    a = 1;                    x = b;                }            };            Thread two = new Thread() {                public void run() {                    b = 1;                    y = a;                }            };            one.start();            two.start();            one.join();            two.join();            System.out.println(x + &quot; &quot; + y);        }    } }</code></pre><p>在这个例子中one/two两个线程修改区x,y,a,b四个变量，在执行100次的情况下，可能得到(0 1)或者（1 0）或者（1 1）。</p><p>事实上按照JVM的规范以及CPU的特性有很可能得到（0 0）。当然上面的代码大家不一定能得到（0 0），因为run()里面的操作过于简单，可能比启动一个线程花费的时间还少，因此上面的例子难以出现（0,0）。</p><p>但是在现代CPU和JVM上确实是存在的。由于run()里面的动作对于结果是无关的，因此里面的指令可能发生指令重排序，即使是按照程序的顺序执行，数据变化刷新到主存也是需要时间的。</p><p>假定是按照a=1;x=b;b=1;y=a;执行的，x=0是比较正常的，虽然a=1在y=a之前执行的，但是由于线程one执行a=1完成后还没有来得及将数据1写回主存（这时候数据是在线程one的堆栈里面的），线程two从主存中拿到的数据a可能仍然是0（显然是一个过期数据，但是是有可能的），这样就发生了数据错误。</p><p>在两个线程交替执行的情况下数据的结果就不确定了，在机器压力大，多核CPU并发执行的情况下，数据的结果就更加不确定了。</p><p><strong>Happens-before法则</strong><br>Java存储模型有一个happens-before原则，就是如果动作B要看到动作A的执行结果（无论A/B是否在同一个线程里面执行），那么A/B就需要满足happens-before关系。</p><p>在介绍happens-before法则之前介绍一个概念：JMM动作（Java Memeory Model Action），Java存储模型动作。一个动作（Action）包括：变量的读写、监视器加锁和释放锁、线程的start()和join()。后面还会提到锁的。</p><p>happens-before完整规则：</p><ul><li><p>同一个线程中的每个Action都happens-before于出现在其后的任何一个Action。</p></li><li><p>对一个监视器的解锁happens-before于每一个后续对同一个监视器的加锁。</p></li><li><p>对volatile字段的写入操作happens-before于每一个后续的同一个字段的读操作。</p></li><li><p>Thread.start()的调用会happens-before于启动线程里面的动作。</p></li><li><p>Thread中的所有动作都happens-before于其他线程检查到此线程结束或者Thread.join（）中返回或者Thread.isAlive()==false。</p></li><li><p>一个线程A调用另一个另一个线程B的interrupt（）都happens-before于线程A发现B被A中断（B抛出异常或者A检测到B的isInterrupted（）或者interrupted()）。</p></li><li><p>一个对象构造函数的结束happens-before与该对象的finalizer的开始</p></li><li><p>如果A动作happens-before于B动作，而B动作happens-before与C动作，那么A动作happens-before于C动作。</p></li></ul><p><strong>volatile语义</strong></p><p>volatile相当于synchronized的弱实现，也就是说volatile实现了类似synchronized的语义，却又没有锁机制。它确保对volatile字段的更新以可预见的方式告知其他的线程。</p><p>volatile包含以下语义：</p><ul><li><p>Java 存储模型不会对valatile指令的操作进行重排序：这个保证对volatile变量的操作时按照指令的出现顺序执行的。</p></li><li><p>volatile变量不会被缓存在寄存器中（只有拥有线程可见）或者其他对CPU不可见的地方，每次总是从主存中读取volatile变量的结果。也就是说对于volatile变量的修改，其它线程总是可见的，并且不是使用自己线程栈内部的变量。也就是在happens-before法则中，对一个valatile变量的写操作后，其后的任何读操作理解可见此写操作的结果。</p></li></ul><p>尽管volatile变量的特性不错，但是volatile并<code>不能保证线程安全</code>的，也就是说volatile字段的操作不是原子性的，volatile变量只能保证可见性（一个线程修改后其它线程能够理解看到此变化后的结果），<strong>要想保证原子性，目前为止只能加锁！</strong></p><p>volatile通常在下面的场景：</p><pre><code>volatile boolean done = false;…while( ! done ){    dosomething();}</code></pre><p>应用volatile变量的三个原则：</p><ul><li><p>写入变量不依赖此变量的值，或者只有一个线程修改此变量</p></li><li><p>变量的状态不需要与其它变量共同参与不变约束</p></li><li><p>访问变量不需要加锁</p></li></ul><h4 id="原子操作-1"><a href="#原子操作-1" class="headerlink" title="原子操作"></a>原子操作</h4><p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁（后面的章节还会谈到锁）。</p><p>锁机制存在以下问题：</p><ul><li><p>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p></li><li><p>一个线程持有锁会导致其它所有需要此锁的线程挂起。</p></li><li><p>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p></li></ul><p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p><p>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p><p><strong>CAS 操作</strong></p><p>上面的乐观锁用到的机制就是CAS，Compare and Swap。</p><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><p>非阻塞算法 （nonblocking algorithms）:</p><blockquote><p>一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p></blockquote><p>现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。</p><p>拿出AtomicInteger来研究在没有锁的情况下是如何做到数据正确性的。</p><pre><code>private volatile int value;</code></pre><p>首先毫无疑问，在没有锁的机制下可能需要借助volatile原语，保证线程间的数据是可见的（共享的）。</p><p>这样才获取变量的值的时候才能直接读取。</p><pre><code>public final int get() {    return value;}</code></pre><p>然后来看看++i是怎么做到的。</p><pre><code>public final int incrementAndGet() {    for (;;) {        int current = get();        int next = current + 1;        if (compareAndSet(current, next))            return next;    }}</code></pre><p>在这里采用了CAS操作，每次从内存中读取数据然后将此数据和+1后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。<br>而compareAndSet利用JNI来完成CPU指令的操作。</p><pre><code>public final boolean compareAndSet(int expect, int update) {      return unsafe.compareAndSwapInt(this, valueOffset, expect, update);}</code></pre><p>整体的过程就是这样子的，利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。</p><p>而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。参考资料的文章中介绍了如果利用CAS构建非阻塞计数器、队列等数据结构。</p><p>CAS看起来很爽，但是会导致“ABA问题”。</p><p>CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。因此前面提到的原子操作AtomicStampedReference/AtomicMarkableReference就很有用了。这允许一对变化的元素进行原子操作。</p><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>尽管synchronized在语法上已经足够简单了，在JDK 5之前只能借助此实现，但是由于是独占锁，性能却不高，因此JDK 5以后就开始借助于JNI来完成更高级的锁实现。</p><p>JDK 5中的锁是接口java.util.concurrent.locks.Lock。另外java.util.concurrent.locks.ReadWriteLock提供了一对可供读写并发的锁。根据前面的规则，我们从java.util.concurrent.locks.Lock的API开始。</p><pre><code>void lock();</code></pre><p>获取锁。</p><p>如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。</p><hr><pre><code>void lockInterruptibly() throws InterruptedException;</code></pre><p>如果当前线程未被中断，则获取锁。</p><p>如果锁可用，则获取锁，并立即返回。</p><p>如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下两种情况之一以前，该线程将一直处于休眠状态：</p><ul><li>锁由当前线程获得</li><li>其他某个线程中断当前线程，并且支持对锁获取的中断</li></ul><p>如果当前线程处于以下两种情况时, 则将抛出 InterruptedException，并清除当前线程的已中断状态。：</p><ul><li>在进入此方法时已经设置了该线程的中断状态</li><li>在获取锁时被中断，并且支持对锁获取的中断</li></ul><hr><pre><code>Condition newCondition();</code></pre><p>返回绑定到此 Lock 实例的新 Condition 实例。</p><hr><pre><code>boolean tryLock();</code></pre><p>仅在调用时锁为空闲状态才获取该锁。</p><p>如果锁可用，则获取锁，并立即返回值 true。如果锁不可用，则此方法将立即返回值 false。</p><p>通常对于那些不是必须获取锁的操作可能有用。</p><hr><pre><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</code></pre><p>如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。</p><p>如果锁可用，则此方法将立即返回值 true。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下三种情况之一前，该线程将一直处于休眠状态：</p><ul><li>锁由当前线程获得</li><li>其他某个线程中断当前线程，并且支持对锁获取的中断</li><li>已超过指定的等待时间</li></ul><p>如果获得了锁，则返回值 true。</p><p>如果当前线程：</p><ul><li>在进入此方法时已经设置了该线程的中断状态</li><li>在获取锁时被中断，并且支持对锁获取的中断，</li></ul><p>则将抛出 InterruptedException，并会清除当前线程的已中断状态。</p><p>如果超过了指定的等待时间，则将返回值 false。如果 time 小于等于 0，该方法将完全不等待。</p><hr><pre><code>void unlock();</code></pre><p>释放锁。对应于lock()、tryLock()、tryLock(xx)、lockInterruptibly()等操作，如果成功的话应该对应着一个unlock()，这样可以避免死锁或者资源浪费。</p><pre><code>public class AtomicIntegerWithLock {    private int value;    private Lock lock = new ReentrantLock();    public AtomicIntegerWithLock() {        super();    }    public AtomicIntegerWithLock(int value) {        this.value = value;    }    public final int get() {        lock.lock();        try {            return value;        } finally {            lock.unlock();        }    }    public final void set(int newValue) {        lock.lock();        try {            value = newValue;        } finally {            lock.unlock();        }    }    public final int getAndSet(int newValue) {        lock.lock();        try {            int ret = value;            value = newValue;            return ret;        } finally {            lock.unlock();        }    }    public final boolean compareAndSet(int expect, int update) {        lock.lock();        try {            if (value == expect) {                value = update;                return true;            }            return false;        } finally {            lock.unlock();        }    }    public final int getAndIncrement() {        lock.lock();        try {            return value++;        } finally {            lock.unlock();        }    }    public final int getAndDecrement() {        lock.lock();        try {            return value--;        } finally {            lock.unlock();        }    }    public final int incrementAndGet() {        lock.lock();        try {            return ++value;        } finally {            lock.unlock();        }    }    public final int decrementAndGet() {        lock.lock();        try {            return --value;        } finally {            lock.unlock();        }    }    public String toString() {        return Integer.toString(get());    }}</code></pre><p>类AtomicIntegerWithLock是线程安全的，此结构中大量使用了Lock对象的lock/unlock方法对。</p><p>同样可以看到的是对于自增和自减操作使用了++/–。</p><p>之所以能够保证线程安全，是因为Lock对象的lock()方法保证了只有一个线程能够只有此锁。</p><p>需要说明的是对于任何一个lock()方法，都需要一个unlock()方法与之对于，通常情况下为了保证unlock方法总是能够得到执行，unlock方法被置于finally块中。</p><p>另外这里使用了java.util.concurrent.locks.ReentrantLock.ReentrantLock对象，下一个小节中会具体描述此类作为Lock的唯一实现是如何设计和实现的。</p><p>尽管synchronized实现Lock的相同语义，并且在语法上比Lock要简单多，但是前者却比后者的开销要大得多。做一个简单的测试。</p><blockquote><p>jdk1.6之后, synchronized已经引入了偏向锁,轻量级锁,性能大大提升. 性能已经不是Synchronized和Lock之间选择的比较了</p></blockquote><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p>在理解J.U.C原理以及锁机制之前，我们来介绍J.U.C框架最核心也是最复杂的一个基础类：<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>。</p><p><img src="/2020/06/11/2020-6-11/AQS%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.jpg" alt="AQS继承结构"><br>上面的继承体系中，AbstractQueuedSynchronizer是CountDownLatch/FutureTask/ReentrantLock/RenntrantReadWriteLock/Semaphore的基础，因此AbstractQueuedSynchronizer是Lock/Executor实现的前提。<br>公平锁、不公平锁、Condition、CountDownLatch、Semaphore等放到后面的篇幅中说明。</p><p>完整的设计原理可以参考Doug Lea的论文 The java.util.concurrent Synchronizer Framework ，这里做一些简要的分析。</p><p>基本的思想是表现为一个同步器，支持下面两个操作：</p><p>获取锁：</p><p>首先判断当前状态是否允许获取锁，如果是就获取锁，否则就阻塞操作或者获取失败.</p><p>也就是说如果是独占锁就可能阻塞，如果是共享锁就可能失败。</p><p>另外如果是阻塞线程，那么线程就需要进入阻塞队列。当状态位允许获取锁时就修改状态，并且如果进了队列就从队列中移除。</p><pre><code>while(synchronization state does not allow acquire){    enqueue current thread if not already queued;    possibly block current thread;}dequeue current thread if it was queued;</code></pre><p>释放锁:</p><p>这个过程就是修改状态位，如果有线程因为状态位阻塞的话就唤醒队列中的一个或者更多线程。</p><pre><code>update synchronization state;if(state may permit a blocked thread to acquire)    unlock one or more queued threads;</code></pre><p>要支持上面两个操作就必须有下面的条件：</p><ul><li>原子性操作同步器的状态位</li><li>阻塞和唤醒线程</li><li>一个有序的队列</li></ul><p>目标明确，要解决的问题也清晰了，那么剩下的就是解决上面三个问题。</p><p><em>状态位的原子操作</em><br>这里使用一个32位的整数来描述状态位，前面章节的原子操作的理论知识整好派上用场，在这里依然使用CAS操作来解决这个问题。事实上这里还有一个64位版本的同步器（AbstractQueuedLongSynchronizer），这里暂且不谈。</p><p><em>阻塞和唤醒线程</em></p><p>标准的JAVA API里面是无法挂起（阻塞）一个线程，然后在将来某个时刻再唤醒它的。JDK 1.0的API里面有Thread.suspend和Thread.resume，并且一直延续了下来。但是这些都是过时的API，而且也是不推荐的做法。</p><p>在JDK 5.0以后利用JNI在LockSupport类中实现了此特性。</p><pre><code>LockSupport.park()LockSupport.park(Object)LockSupport.parkNanos(Object, long)LockSupport.parkNanos(long)LockSupport.parkUntil(Object, long)LockSupport.parkUntil(long)LockSupport.unpark(Thread)</code></pre><p>上面的API中park()是在当前线程中调用，导致线程阻塞，带参数的Object是挂起的对象，这样监视的时候就能够知道此线程是因为什么资源而阻塞的。</p><p>由于park()立即返回，所以通常情况下需要在循环中去检测竞争资源来决定是否进行下一次阻塞。park()返回的原因有三：</p><ul><li>其他某个线程调用将当前线程作为目标调用 unpark；</li><li>其他某个线程中断当前线程；</li><li>该调用不合逻辑地（即毫无理由地）返回。</li></ul><p>其实第三条就决定了需要循环检测了，类似于通常写的while(checkCondition()){Thread.sleep(time);}类似的功能。</p><p><em>有序队列</em><br>在AQS中采用CHL列表来解决有序的队列的问题。</p><p><img src="/2020/06/11/2020-6-11/CHLl%E5%88%97%E8%A1%A8.png" alt></p><p>AQS采用的CHL模型采用下面的算法完成FIFO的入队列和出队列过程。</p><p>对于入队列(enqueue)：采用CAS操作，每次比较尾结点是否一致，然后插入的到尾结点中。</p><pre><code>do {    pred = tail;}while ( !compareAndSet(pred,tail,node) );</code></pre><p>对于出队列(dequeue):由于每一个节点也缓存了一个状态，决定是否出队列，因此当不满足条件时就需要自旋等待，一旦满足条件就将头结点设置为下一个节点。</p><pre><code>while (pred.status != RELEASED) ;head  = node;</code></pre><p>实际上这里自旋等待也是使用LockSupport.park()来实现的。</p><p>AQS里面有三个核心字段：</p><pre><code>private volatile int state;private transient volatile Node head;private transient volatile Node tail;</code></pre><p>其中state描述的有多少个线程取得了锁，对于互斥锁来说state&lt;=1。</p><p>head/tail加上CAS操作就构成了一个CHL的FIFO队列。</p><p>下面是Node节点的属性。</p><p>volatile int waitStatus; 节点的等待状态，一个节点可能位于以下几种状态：<br>    ANCELLED = 1： 节点操作因为超时或者对应的线程被interrupt。节点不应该留在此状态，一旦达到此状态将从CHL队列中踢出。<br>    SIGNAL = -1： 节点的继任节点是（或者将要成为）BLOCKED状态（例如通过LockSupport.park()操作），因此一个节点一旦被释放（解锁）或者取消就需要唤醒（LockSupport.unpack()）它的继任节点。<br>    CONDITION = -2：表明节点对应的线程因为不满足一个条件（Condition）而被阻塞。<br>    0： 正常状态，新生的非CONDITION节点都是此状态。<br>    非负值标识节点不需要被通知（唤醒）。<br>volatile Node prev;此节点的前一个节点。节点的waitStatus依赖于前一个节点的状态。</p><p>volatile Node next;此节点的后一个节点。后一个节点是否被唤醒（uppark()）依赖于当前节点是否被释放。</p><p>volatile Thread thread;节点绑定的线程。</p><p>Node nextWaiter;下一个等待条件（Condition）的节点，由于Condition是独占模式，因此这里有一个简单的队列来描述Condition上的线程节点。</p><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><pre><code>public void java.util.concurrent.locks.ReentrantLock.lock()</code></pre><blockquote><p>获取锁。<br>如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。<br>如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。<br>如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1。  </p></blockquote><p>从上面的文档可以看出ReentrantLock是可重入锁的实现。</p><p>而内部是委托java.util.concurrent.locks.ReentrantLock.Sync.lock()实现的。<br>java.util.concurrent.locks.ReentrantLock.Sync是抽象类，有java.util.concurrent.locks.ReentrantLock.FairSync和java.util.concurrent.locks.ReentrantLock.NonfairSync两个实现，也就是常说的公平锁和不公平锁。</p><p>公平锁和非公平锁</p><blockquote><p>如果获取一个锁是按照请求的顺序得到的，那么就是公平锁，否则就是非公平锁。</p></blockquote><p>在没有深入了解内部机制及实现之前，先了解下为什么会存在公平锁和非公平锁。</p><p>公平锁保证一个阻塞的线程最终能够获得锁，因为是有序的，所以总是可以按照请求的顺序获得锁。</p><p>不公平锁意味着后请求锁的线程可能在其前面排列的休眠线程恢复前拿到锁，这样就有可能提高并发的性能。</p><p>这是因为通常情况下挂起的线程重新开始与它真正开始运行，二者之间会产生严重的延时。</p><p>因此非公平锁就可以利用这段时间完成操作。</p><p>这是非公平锁在某些时候比公平锁性能要好的原因之一。</p><p>二者在实现上的区别会在后面介绍，我们先从公平锁（FairSync）开始。</p><p>前面说过<code>java.util.concurrent.locks.AbstractQueuedSynchronizer （AQS)</code>是Lock的基础，对于一个FairSync而言，lock()就直接调用AQS的acquire(int arg);</p><p>public final void acquire(int arg) 以独占模式获取对象，忽略中断。通过至少调用一次 tryAcquire(int) 来实现此方法，并在成功时返回。否则在成功之前，一直调用 tryAcquire(int) 将线程加入队列，线程可能重复被阻塞或不被阻塞。</p><p>在介绍实现之前先要补充上一节的知识，对于一个AQS的实现而言，通常情况下需要实现以下方法来描述如何锁定线程。</p><ul><li>tryAcquire(int) 试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。</li><li>tryRelease(int) 试图设置状态来反映独占模式下的一个释放。 此方法总是由正在执行释放的线程调用。释放锁可能失败或者抛出异常，这个在后面会具体分析。</li><li>tryAcquireShared(int) 试图在共享模式下获取对象状态。</li><li>tryReleaseShared(int) 试图设置状态来反映共享模式下的一个释放。</li><li>isHeldExclusively() 如果对于当前（正调用的）线程，同步是以独占方式进行的，则返回 true。</li></ul><p>除了tryAcquire(int)外，其它方法会在后面具体介绍。</p><p>首先对于ReentrantLock而言，不管是公平锁还是非公平锁，都是独占锁，也就是说同时能够有一个线程持有锁。</p><p>因此对于acquire(int arg)而言，arg==1。在AQS中acquire的实现如下：</p><pre><code>public final void acquire(int arg) {    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();}</code></pre><p>这个看起来比较复杂，我们分解以下4个步骤。</p><ol><li>如果tryAcquire(arg)成功，那就没有问题，已经拿到锁，整个lock()过程就结束了。如果失败进行操作2。</li><li>创建一个独占节点（Node）并且此节点加入CHL队列末尾。进行操作3。</li><li>自旋尝试获取锁，失败根据前一个节点来决定是否挂起（park()），直到成功获取到锁。进行操作4。</li><li>如果当前线程已经中断过，那么就中断当前线程（清除中断位）。</li></ol><p>这是一个比较复杂的过程，我们按部就班一个一个分析。</p><p><strong>tryAcquire(acquires)</strong></p><p>对于公平锁而言，它的实现方式如下：</p><pre><code>protected final boolean tryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) {        if (isFirst(current) &amp;&amp;            compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0)            throw new Error(&quot;Maximum lock count exceeded&quot;);        setState(nextc);        return true;    }    return false;}</code></pre><p>在这段代码中，前面说明对于AQS存在一个state来描述当前有多少线程持有锁。</p><p>由于AQS支持共享锁（例如读写锁，后面会继续讲），所以这里state&gt;=0，但是由于ReentrantLock是独占锁，所以这里不妨理解为0&lt;=state，acquires=1。</p><p>isFirst(current)是一个很复杂的逻辑，包括踢出无用的节点等复杂过程，这里暂且不提，大体上的意思是说判断AQS是否为空或者当前线程是否在队列头（为了区分公平与非公平锁）。</p><ol><li>如果当前锁有其它线程持有，c!=0，进行操作2。否则，如果当前线程在AQS队列头部，则尝试将AQS状态state设为acquires（等于1），成功后将AQS独占线程设为当前线程返回true，否则进行2。这里可以看到compareAndSetState就是使用了CAS操作。</li><li>判断当前线程与AQS的独占线程是否相同，如果相同，那么就将当前状态位加1（这里+1后结果为负数后面会讲，这里暂且不理它），修改状态位，返回true，否则进行3。这里之所以不是将当前状态位设置为1，而是修改为旧值+1呢？这是因为ReentrantLock是可重入锁，同一个线程每持有一次就+1。</li><li>返回false。</li></ol><p>比较非公平锁的tryAcquire实现java.util.concurrent.locks.ReentrantLock.Sync.nonfairTryAcquire(int)，公平锁多了一个判断当前节点是否在队列头，这个就保证了是否按照请求锁的顺序来决定获取锁的顺序（同一个线程的多次获取锁除外）。</p><p>现在再回头看公平锁和非公平锁的lock()方法。公平锁只有一句acquire(1)；而非公平锁的调用如下：</p><pre><code>final void lock() {    if (compareAndSetState(0, 1))        setExclusiveOwnerThread(Thread.currentThread());    else        acquire(1);}</code></pre><p>很显然，非公平锁在第一次获取锁，或者其它线程释放锁后（可能等待），优先采用compareAndSetState(0,1)然后设置AQS独占线程而持有锁，这样有时候比acquire(1)顺序检查锁持有而要高效。</p><p>即使在重入锁上，也就是compareAndSetState(0,1)失败，但是是当前线程持有锁上，非公平锁也没有问题。</p><p><strong>addWaiter(mode)</strong><br>tryAcquire失败就意味着入队列了。此时AQS的队列中节点Node就开始发挥作用了。</p><p>一般情况下AQS支持独占锁和共享锁，而独占锁在Node中就意味着条件（Condition）队列为空（上一篇中介绍过相关概念）。</p><p>在java.util.concurrent.locks.AbstractQueuedSynchronizer.Node中有两个常量，</p><pre><code>//独占节点模式static final Node EXCLUSIVE = null;//共享节点模式static final Node SHARED = new Node(); </code></pre><p>addWaiter(mode)中的mode就是节点模式，也就是共享锁还是独占锁模式。</p><p>前面一再强调ReentrantLock是独占锁模式。</p><pre><code>private Node addWaiter(Node mode) {     Node node = new Node(Thread.currentThread(), mode);     // Try the fast path of enq; backup to full enq on failure     Node pred = tail;     if (pred != null) {         node.prev = pred;         if (compareAndSetTail(pred, node)) {             pred.next = node;             return node;         }     }     enq(node);     return node;}</code></pre><p>上面是节点如队列的一部分。当前仅当队列不为空并且将新节点插入尾部成功后直接返回新节点。否则进入enq(Node)进行操作。</p><pre><code>private Node enq(final Node node) {    for (;;) {        Node t = tail;        if (t == null) { // Must initialize            Node h = new Node(); // Dummy header            h.next = node;            node.prev = h;            if (compareAndSetHead(h)) {                tail = node;                return h;            }        }        else {            node.prev = t;            if (compareAndSetTail(t, node)) {                t.next = node;                return t;            }        }    }}</code></pre><p>enq(Node)去队列操作实现了CHL队列的算法，如果为空就创建头结点，然后同时比较节点尾部是否是改变来决定CAS操作是否成功，当且仅当成功后才将为不节点的下一个节点指向为新节点。可以看到这里仍然是CAS操作。</p><p><strong>acquireQueued(node,arg)</strong></p><p>自旋请求锁，如果可能的话挂起线程，直到得到锁，返回当前线程是否中断过（如果park()过并且中断过的话有一个interrupted中断位）。</p><pre><code>final boolean acquireQueued(final Node node, int arg) {    try {        boolean interrupted = false;        for (;;) {            final Node p = node.predecessor();            if (p == head &amp;&amp; tryAcquire(arg)) {                setHead(node);                p.next = null; // help GC                return interrupted;            }            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = true;        }    } catch (RuntimeException ex) {        cancelAcquire(node);        throw ex;    }}</code></pre><p>下面的分析就需要用到上节节点的状态描述了。acquireQueued过程是这样的：</p><ol><li>如果当前节点是AQS队列的头结点（如果第一个节点是DUMP节点也就是傀儡节点，那么第二个节点实际上就是头结点了），就尝试在此获取锁tryAcquire(arg)。如果成功就将头结点设置为当前节点（不管第一个结点是否是DUMP节点），返回中断位。否则进行2。</li><li>检测当前节点是否应该park()，如果应该park()就挂起当前线程并且返回当前线程中断位。进行操作1。</li></ol><p>一个节点是否该park()是关键，这是由方法java.util.concurrent.locks.AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire(Node, Node)实现的。</p><pre><code>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {    int s = pred.waitStatus;    if (s &lt; 0) return true;    if (s &gt; 0) {        do {            node.prev = pred = pred.prev;        } while (pred.waitStatus &gt; 0);        pred.next = node;    } else compareAndSetWaitStatus(pred, 0, Node.SIGNAL);    return false;}</code></pre><ol><li>如果前一个节点的等待状态waitStatus&lt;0，也就是前面的节点还没有获得到锁，那么返回true，表示当前节点（线程）就应该park()了。否则进行2。</li><li>如果前一个节点的等待状态waitStatus&gt;0，也就是前一个节点被CANCELLED了，那么就将前一个节点去掉，递归此操作直到所有前一个节点的waitStatus&lt;=0，进行4。否则进行3。</li><li>前一个节点等待状态waitStatus=0，修改前一个节点状态位为SINGAL，表示后面有节点等待你处理，需要根据它的等待状态来决定是否该park()。进行4。</li><li>返回false，表示线程不应该park()。</li></ol><p><strong>selfInterrupt()</strong></p><pre><code>private static void selfInterrupt() {    Thread.currentThread().interrupt();}</code></pre><p>如果线程曾经中断过（或者阻塞过）（比如手动interrupt()或者超时等等，那么就再中断一次，中断两次的意思就是清除中断位）。</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC 容器源码分析笔记 (一)</title>
      <link href="/2020/06/07/2020-6-7/"/>
      <url>/2020/06/07/2020-6-7/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-IOC源码分析笔记"><a href="#Spring-IOC源码分析笔记" class="headerlink" title="Spring IOC源码分析笔记"></a>Spring IOC源码分析笔记</h2><p><a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">Spring IOC 容器源码分析</a></p><p>IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean.</p><h3 id="1-最基本的Spring启动"><a href="#1-最基本的Spring启动" class="headerlink" title="1. 最基本的Spring启动"></a>1. 最基本的Spring启动</h3><pre><code>public static void main(String[] args) {    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;);}</code></pre><p>只需要简单的加载classpath下的application.properties配置文件就可以启动.<br>需要在pom文件里添加spring依赖.</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><blockquote><p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p></blockquote><h3 id="2-ApplicationContext的继承结构和其他IOC容器实现类"><a href="#2-ApplicationContext的继承结构和其他IOC容器实现类" class="headerlink" title="2. ApplicationContext的继承结构和其他IOC容器实现类"></a>2. ApplicationContext的继承结构和其他IOC容器实现类</h3><p>偷一张ApplicationContext的继承结构:<br><img src="/2020/06/07/2020-6-7/ApplicationContext%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt="ApplicationContext继承结构"></p><p>在最下层的实现类还有FileSystemXmlApplicationContext和AnnotationConfigApplicationContext</p><p>1、FileSystemXmlApplicationContext 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p><p>2、AnnotationConfigApplicationContext 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p><h3 id="3-一个QuickStart"><a href="#3-一个QuickStart" class="headerlink" title="3. 一个QuickStart"></a>3. 一个QuickStart</h3><h4 id="1-创建一个接口和他的实现类"><a href="#1-创建一个接口和他的实现类" class="headerlink" title="1) 创建一个接口和他的实现类:"></a>1) 创建一个接口和他的实现类:</h4><pre><code>public interface MessageService {    String getMessage();}public class MessageServiceImpl implements MessageService {    public String getMessage() {        return &quot;hello world&quot;;    }}</code></pre><h4 id="2-接下来-在resources目录下新建一个xml配置文件"><a href="#2-接下来-在resources目录下新建一个xml配置文件" class="headerlink" title="2) 接下来, 在resources目录下新建一个xml配置文件."></a>2) 接下来, 在resources目录下新建一个xml配置文件.</h4><p>名称随意,一般习惯叫application.xml 或 application-xxx.xml.</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot; default-autowire=&quot;byName&quot;&gt;    &lt;bean id=&quot;messageService&quot; class=&quot;com.echi.service.MessageServiceImpl&quot;/&gt;&lt;/beans&gt;</code></pre><h4 id="3-在IOC容器实例完成之后-从容器中获取bean"><a href="#3-在IOC容器实例完成之后-从容器中获取bean" class="headerlink" title="3) 在IOC容器实例完成之后, 从容器中获取bean"></a>3) 在IOC容器实例完成之后, 从容器中获取bean</h4><pre><code>public class ApplicationStarter {    public static void main(String[] args) {        ApplicationContext applicationContext =                 new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;);        System.out.println(&quot;context 启动成功&quot;);        // 从IOC容器中获取类型为MessageService的bean        MessageService messageService = applicationContext.getBean(MessageService.class);        // 调动bean的方法,确认实例成功        // 输出 hello world        System.out.println(messageService.getMessage());    }}</code></pre><p>这样就引出了主题, 为什么我们可以通过配置的方式就获取到bean.<br>ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p><h3 id="4-BeanFactory简介"><a href="#4-BeanFactory简介" class="headerlink" title="4. BeanFactory简介"></a>4. BeanFactory简介</h3><p>BeanFactory就是一个生产bean的工厂, 它负责生产和管理各个bean的实例.</p><h4 id="1-BeanFactory主要继承结构"><a href="#1-BeanFactory主要继承结构" class="headerlink" title="1) BeanFactory主要继承结构"></a>1) BeanFactory主要继承结构</h4><p><img src="/2020/06/07/2020-6-7/BeanFactory%E4%B8%BB%E8%A6%81%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt="BeanFactory主要继承结构"></p><p>ApplicationContext其实就是一个BeanFactory,</p><p>大概翻一下 BeanFactory , ListableBeanFactory , HierarchicalBeanFactory , AuthwireCapableBeanFactory , ApplicationContext 这几个接口的代码.</p><ul><li>BeanFactory中的方法大多都是getBean().</li><li>ListableBeanFactory中有返回Map的getBean方法, 这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean</li><li>HierarchicalBeanFactory 内容比较少, 有一个getParentBeanFactory()方法, 也就是说会有父容器和子容器关系.</li><li>AutowireCapableBeanFactory 比较眼熟autowire这个词, 里面有几个常量, AUTOWIRE_BY_NAME, BY_TYPE之类的, 就是用来自动装配bean的. 但是仔细看上面的继承图, ApplicationContext并没有继承他, 这个不要紧, 在ApplicationContext中有一个getAutowireCapableBeanFactory()方法,没有继承不代表不能组合使用.</li><li>还有一个ConfigurableListableBeanFactory , 继承了全部的三个BeanFactory接口.</li></ul><h4 id="2-启动过程分析"><a href="#2-启动过程分析" class="headerlink" title="2) 启动过程分析"></a>2) 启动过程分析</h4><p>先从ClasspathXMLApplicationContext的构造方法开始说起.</p><pre><code>// 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法public ClassPathXmlApplicationContext(ApplicationContext parent) {    super(parent);}public ClassPathXmlApplicationContext(String configLocation) throws BeansException {    this(new String[] {configLocation}, true, null);}public ClassPathXmlApplicationContext(String[] configLocations,                 boolean refresh, ApplicationContext parent) throws BeansException {    super(parent);    // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)    setConfigLocations(configLocations);    if (refresh) {        // 核心方法        refresh();    }}</code></pre><p><strong>接下来就是refresh()方法</strong></p><blockquote><p>这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p></blockquote><pre><code>@Overridepublic void refresh() throws BeansException, IllegalStateException {    // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛    synchronized (this.startupShutdownMonitor) {        // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符        prepareRefresh();        // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，        // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，        // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();        // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean        // 这块待会会展开说        prepareBeanFactory(beanFactory);        try {            // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，            // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】            // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化            // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事            postProcessBeanFactory(beanFactory);            // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法            invokeBeanFactoryPostProcessors(beanFactory);            // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别            // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization            // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化            registerBeanPostProcessors(beanFactory);            // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了            initMessageSource();            // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了            initApplicationEventMulticaster();            // 从方法名就可以知道，典型的模板方法(钩子方法)，            // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）            onRefresh();            // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过            registerListeners();            // 重点，重点，重点            // 初始化所有的 singleton beans            //（lazy-init 的除外）            finishBeanFactoryInitialization(beanFactory);            // 最后，广播事件，ApplicationContext 初始化完成            finishRefresh();        }        catch (BeansException ex) {            if (logger.isWarnEnabled()) {                logger.warn(&quot;Exception encountered during context initialization - &quot; +                        &quot;cancelling refresh attempt: &quot; + ex);            }            // Destroy already created singletons to avoid dangling resources.            // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源            destroyBeans();            // Reset &#39;active&#39; flag.            cancelRefresh(ex);            // 把异常往外抛            throw ex;        }        finally {            resetCommonCaches();        }    }}</code></pre><p>下面，开始一步步肢解这个 <code>refresh()</code> 方法。</p><p><strong>创建 Bean 容器前的准备工作</strong></p><p>这个比较简单，直接看代码中的几个注释即可。</p><pre><code>protected void prepareRefresh() {    // 记录启动时间，    // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型    this.startupDate = System.currentTimeMillis();    this.closed.set(false);    this.active.set(true);    if (logger.isInfoEnabled()) {        logger.info(&quot;Refreshing &quot; + this);    }    // Initialize any placeholder property sources in the context environment    initPropertySources();    // 校验 xml 配置文件    getEnvironment().validateRequiredProperties();    this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();}</code></pre><p><strong>创建Bean容器,加载并注册Bean</strong></p><p>回到<code>refresh()</code>方法的下一行, <code>obtainFreshBeanFactory()</code></p><p>这个方法是全文最重要的方法之一, 这里会初始化beanFactory, 加载Bean, 注册Bean等等.</p><p>当然,这步之后, bean并没有完成初始化.</p><pre><code>// AbstractApplicationContext.javaprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {    // 关闭旧的beanFactory(如果有), 创建新的beanFactory, 加载bean定义, 注册bean等...    refreshBeanFactory();    // 返回刚刚创建的beanFactory    ConfigurableListableBeanFactory beanFactory = getBeanFactory();    if (logger.isDebugEnabled()) {        logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);    }    return beanFactory;}// AbstractRefreshableApplicationContext.java 120@Overrideprotected final void refreshBeanFactory() throws BeansException {    // 如果ApplicationContext中已经加载了beanFactory, 销毁所有的bean, 关闭beanFactory    // 注意, 应用中beanFactory本来就是可以有多个的, 这里不是说应用全局是否有beanFactory,     // 而是当前ApplicationContext是否有beanFactory    if (hasBeanFactory()) {        destroyBeans();        closeBeanFactory();    }    try {        // 初始化一个DefaultListableBeanFactory, 为什么用这个等会再说.        DefaultListableBeanFactory beanFactory = createBeanFactory();        // 用于beanFactory序列化        beanFactory.setSerializationId(getId());        // 下面两个方法很重要        // 设置beanFactory的两个属性, 是否允许bean覆盖, 是否允许循环引用        customizeBeanFactory(beanFactory);        // 加载bean到beanFactory中        loadBeanDefinitions(beanFactory);        synchronized (this.beanFactoryMonitor) {            this.beanFactory = beanFactory;        }    }    catch (IOException ex) {        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; +             getDisplayName(), ex);    }}</code></pre><blockquote><p>ApplicationContext继承自BeanFactory, 但他不应该被理解为BeanFactory的实现类, 而是其内部有一个实例化的BeanFactory(<code>DefaultListableBeanFactory</code>). 以后所有的beanFactory操作其实是委托给这个实例处理的.</p></blockquote><p>为什么选择实例化DefaultListableBeanFactory, 之前我们看BeanFactory继承结构图的时候,提到一个接口<code>ConfigurableListableBeanFactory</code>, 他继承了BeanFactory下所有的接口, 而这个接口又有一个实现类 <code>DefaultListableBeanFactory</code>, 这个实现类还继承了右边的AbstractAutowireCapableBeanFactory. 所以 <code>DefaultListableBeanFactory</code>基本上是最牛的BeanFactory了,，这也是这边会使用这个类来实例化的原因。</p><p><img src="/2020/06/07/2020-6-7/DefaultListableBeanFactory%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt="DefaultListableBeanFactory继承结构"></p><blockquote><p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？<br>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。</p></blockquote><p>在继续往下之前, 需要了解一个概念,<code>BeanDefinition</code>. 我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</p><p>这里的BeanDefinition就是我们所说的Spring的Bean, 我们定义的各个Bean其实会转换成BeanDefinition存在于Spring的BeanFactory中.</p><p>所以, 如果有人问你Bean是什么的时候, 你要知道Bean在代码层面可以简单的认为是BeanDefinition的实例.</p><blockquote><p>BeanDefinition中保存了我们的Bean信息, 比如这个Bean指向哪个类, 是否是单例, 是否懒加载, 这个Bean依赖了哪些Bean等..</p></blockquote><p><strong>BeanDefinition接口定义</strong></p><pre><code>public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {    // 我们可以看到, 默认只提供singleton和prototype两种.    // 那我们还知道request, session, globalSession, application 这几种呢?    // 他们属于基于 web 的扩展    String SCOPE_SINGLETON = &quot;singleton&quot;;    String SCOPE_PROTOTYPE = &quot;prototype&quot;;    // 不太重要    int ROLE_APPLICATION = 0;    int ROLE_SUPPORT = 1;    int ROLE_INFRASTRUCTURE = 2;    // 设置父Bean, 这里涉及到Bean的继承, 不是java继承.    // 一句话就是: 继承父Bean的配置信息    void setParentName(String var1);    // 获取父Bean    String getParentName();    // 设置Bean的类名称, 将来要通过反射来生成实例.    void setBeanClassName(String var1);    // 获取Bean的类名    String getBeanClassName();    // 设置Bean的scope    void setScope(String var1);    String getScope();    // 设置是否懒加载    void setLazyInit(boolean var1);    boolean isLazyInit();    // 设置Bean所依赖的所有Bean, 注意, 这里的依赖不是指属性依赖 (如 @Autowire标记的)    // 是 depends-on=&quot;&quot; 属性设置的值    void setDependsOn(String... var1);    // 返回该bean的所有依赖    String[] getDependsOn();    // 设置该Bean是否可以注入到其他Bean中, 只对根据类型注入有效    // 如果根据名称注入, 即使这边设置false也是可以的.    void setAutowireCandidate(boolean var1);    // 该Bean是否可以注入到其他Bean中    boolean isAutowireCandidate();    // 主要的. 对于同一个接口的多个实现, 如果不指定名字的话,Spring会优先选择设置primary为true的bean    void setPrimary(boolean var1);    // 是否是primary的    boolean isPrimary();    // 如果该bean采用工厂方法生成, 指定工厂名称.    // 一句话的意思就是, 有些实例不是用反射创建的, 而是用工厂模式获取的.    void setFactoryBeanName(String var1);    // 获取工厂名称    String getFactoryBeanName();    // 指定工厂类中的 工厂方法名称    void setFactoryMethodName(String var1);    // 获取工厂类中的 工厂方法名称    String getFactoryMethodName();    // 构造器参数    ConstructorArgumentValues getConstructorArgumentValues();    // Bean中的属性值, 后面给Bean注入属性的时候会说到    MutablePropertyValues getPropertyValues();    // 是否singleton    boolean isSingleton();    // 是否prototype    boolean isPrototype();    // 如果这个Bean是被设置为abstract, 那么不能实例化.    // 常用作 父Bean 用于继承, 其实也很少用到    boolean isAbstract();    int getRole();    String getDescription();    String getResourceDescription();    BeanDefinition getOriginatingBeanDefinition();}</code></pre><blockquote><p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。<br>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p></blockquote><p>有了BeanDefinition的概念后, 我们继续往下看refreshBeanFactory中的内容.</p><pre><code>customizeBeanFactory(beanFactory);loadBeanDefinitions(beanFactory);</code></pre><p>虽然只有两个方法，但路还很长啊。。。</p><p><strong>customizeBeanFactory</strong><br>customizeBeanFactory(beanFactory)比较简单, 就是配置是否允许BeanDefinition覆盖,是否允许循环引用.</p><pre><code>protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {    if (this.allowBeanDefinitionOverriding != null) {        // 是否允许Bean定义覆盖        beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);    }    if (this.allowCircularReferences != null) {        // 是否允许Bean间循环引用        beanFactory.setAllowCircularReferences(this.allowCircularReferences);    }}</code></pre><p>BeanDefinition覆盖的问题可能好多开发者会碰到这个坑, 就是在配置文件中定义bean的时候,使用了相同的id或name, 默认情况下, allowBeanDefinitionOverriding属性为null, 如果同一配置文件中重复了, 会抛错, 但是如果不是同一配置文件中, 会发生覆盖.</p><p>循环引用也很好理解: A依赖B, B依赖A. 或A依赖B, B依赖C, C依赖A.</p><p>默认情况下, Spring允许依赖循环, 当然如果你在A的构造器中依赖B, B的构造器中依赖A是不行的.</p><p><strong>加载Bean: loadBeanDefinitions</strong></p><p>接下来是最重要的loadBeanDefinition(beanFactory)方法了, 这个方法将根据配置, 加载各个Bean, 然后放入BeanFactory中.</p><p>读取配置的操作在XmlBeanDefinitionReader中, 其负责加载配置, 解析.</p><pre><code>// AbstractXmlApplicationContext.java 80/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory)             throws BeansException, IOException {    // 给这个BeanFactory实例化一个XmlBeanDefinitionReader    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);    // Configure the bean definition reader with this context&#39;s    // resource loading environment.    beanDefinitionReader.setEnvironment(this.getEnvironment());    beanDefinitionReader.setResourceLoader(this);    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));    // 初始化BeanDefinitionReader, 其实是提供给子类覆写的.    // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧    initBeanDefinitionReader(beanDefinitionReader);    // 重点来了，继续往下    loadBeanDefinitions(beanDefinitionReader);}</code></pre><p>接下来用刚刚实例化的XMLBeanDefinitionReader来加载Xml配置,</p><pre><code>// AbstractXmlApplicationContext.java 120protected void loadBeanDefinitions(XmlBeanDefinitionReader reader)             throws BeansException, IOException {    Resource[] configResources = getConfigResources();    if (configResources != null) {        // 进入        reader.loadBeanDefinitions(configResources);    }    String[] configLocations = getConfigLocations();    if (configLocations != null) {        // 2        reader.loadBeanDefinitions(configLocations);    }}// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里@Overridepublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {    Assert.notNull(resources, &quot;Resource array must not be null&quot;);    int counter = 0;    // 这里是一个for循环, 也就是每一个文件是一个resource    for (Resource resource : resources) {        // 进入        counter += loadBeanDefinitions(resource);    }    //最后返回 counter，表示总共加载了多少的 BeanDefinition    return counter;}// XMLBeanDefinitionReader.java 302@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {    return loadBeanDefinitions(new EncodedResource(resource));}// XMLBeanDefinitionReader.java 314public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {    Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);    if (logger.isInfoEnabled()) {        logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());    }    // 用一个ThreadLocal来存放配置文件资源    Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();    if (currentResources == null) {        currentResources = new HashSet&lt;EncodedResource&gt;(4);        this.resourcesCurrentlyBeingLoaded.set(currentResources);    }    if (!currentResources.add(encodedResource)) {        throw new BeanDefinitionStoreException(                &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);    }    try {        InputStream inputStream = encodedResource.getResource().getInputStream();        try {            InputSource inputSource = new InputSource(inputStream);            if (encodedResource.getEncoding() != null) {                inputSource.setEncoding(encodedResource.getEncoding());            }            // 核心部分是这里，往下面看            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());        }        finally {            inputStream.close();        }    }    catch (IOException ex) {        throw new BeanDefinitionStoreException(                &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);    }    finally {        currentResources.remove(encodedResource);        if (currentResources.isEmpty()) {            this.resourcesCurrentlyBeingLoaded.remove();        }    }}protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)        throws BeanDefinitionStoreException {    try {        // 将xml转成Document对象        Document doc = doLoadDocument(inputSource, resource);        // 进入        return registerBeanDefinitions(doc, resource);    }    catch (BeanDefinitionStoreException ex) {        throw ex;    }    ...}public int registerBeanDefinitions(Document doc, Resource resource)             throws BeanDefinitionStoreException {    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();    int countBefore = getRegistry().getBeanDefinitionCount();    // 进入    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));    // 返回从当前配置文件加载了多少数量的 Bean    return getRegistry().getBeanDefinitionCount() - countBefore;}// DefaultBeanDefinitionDocumentReader.java 90@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {    this.readerContext = readerContext;    logger.debug(&quot;Loading bean definitions&quot;);    Element root = doc.getDocumentElement();    doRegisterBeanDefinitions(root);}</code></pre><p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p><pre><code>// DefaultBeanDefinitionDocumentReader.java 116protected void doRegisterBeanDefinitions(Element root) {    // BeanDefinitionParserDelegate 负责解析Bean定义    // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，    // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，    // 也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了    BeanDefinitionParserDelegate parent = this.delegate;    this.delegate = createDelegate(getReaderContext(), root, parent);    if (this.delegate.isDefaultNamespace(root)) {        // 这块说的是根节点 &lt;bean ... profile=&quot;dev&quot;&gt; 中的profile是否是当前环境需要的        // 如果当前环境配置的profile不包含此profile, 就直接return了, 不对此&lt;beans /&gt; 解析.        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);        if (StringUtils.hasText(profileSpec)) {            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {                if (logger.isInfoEnabled()) {                    logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; +                         profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource());                }                return;            }        }    }    // 钩子    preProcessXml(root);    // 进入    parseBeanDefinitions(root, this.delegate);    // 钩子    postProcessXml(root);    this.delegate = parent;}</code></pre><p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p><p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p><blockquote><p>profile就是多环境配置中, application-xxx.properties 中配置的环境.<br>即, 如果配置了 &lt;bean .. profile=”dev” /&gt; 那么只有在dev环境生效时, 才会加载这个bean </p></blockquote><p>接下来，看核心解析方法 <code>parseBeanDefinitions(root, this.delegate)</code> :</p><pre><code>protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {    // default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，    // 其他的属于 custom 的    if (delegate.isDefaultNamespace(root)) {        NodeList nl = root.getChildNodes();        for (int i = 0; i &lt; nl.getLength(); i++) {            Node node = nl.item(i);            if (node instanceof Element) {                Element ele = (Element) node;                if (delegate.isDefaultNamespace(ele)) {                    // 解析default namespace下面的元素                    parseDefaultElement(ele, delegate);                }                else {                    // 解析其他 namespace 下面的元素                    delegate.parseCustomElement(ele);                }            }        }    }    else {        delegate.parseCustomElement(root);    }}</code></pre><p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 <code>parseDefaultElement(ele, delegate);</code> 和 <code>delegate.parseCustomElement(ele);</code> 这两个分支了。</p><p><code>parseDefaultElement(ele, delegate);</code>解析的节点是 <code>&lt;import /&gt;</code>, <code>&lt;alias /&gt;</code>, <code>&lt;beans /&gt;</code>, <code>&lt;bean /&gt;</code> 这几个.</p><pre><code>private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {    // 处理 &lt;import /&gt;    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {        importBeanDefinitionResource(ele);    }    // 处理&lt;alias /&gt;    // &lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;    else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {        processAliasRegistration(ele);    }    // 处理 &lt;bean /&gt; ，这也算是我们的重点吧    else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {        processBeanDefinition(ele, delegate);    }    // 处理 &lt;beans /&gt;    else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {        // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归        doRegisterBeanDefinitions(ele);    }}</code></pre><p>我们重点说<bean>标签.</bean></p><p><strong>processBeanDefinition 解析 bean 标签</strong></p><pre><code>// DefaultBeanDefinitionDocumentReader 298protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {    // 将节点中的信息提取出来, 封装成一个BeanDefinitionHolder    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);    // 下面几行先跳过    if (bdHolder != null) {        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);        try {            // Register the final decorated instance.            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,                 getReaderContext().getRegistry());        }        catch (BeanDefinitionStoreException ex) {            getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +                    bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);        }        // Send registration event.        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));    }}</code></pre><p>继续往下看怎么解析之前，我们先看下 <bean> 标签中可以定义哪些属性：</bean></p><table><thead><tr><th align="left">Property</th><th align="left">&nbsp;</th></tr></thead><tbody><tr><td align="left">class</td><td align="left">类的全限定名</td></tr><tr><td align="left">name</td><td align="left">可指定 id、name(用逗号、分号、空格分隔)</td></tr><tr><td align="left">scope</td><td align="left">作用域</td></tr><tr><td align="left">constructor arguments</td><td align="left">指定构造参数</td></tr><tr><td align="left">properties</td><td align="left">设置属性的值</td></tr><tr><td align="left">autowiring mode</td><td align="left">no(默认值)、byName、byType、 constructor</td></tr><tr><td align="left">lazy-initialization mode</td><td align="left">是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td></tr><tr><td align="left">initialization method</td><td align="left">bean 属性设置完成后，会调用这个方法</td></tr><tr><td align="left">destruction method</td><td align="left">bean 销毁后的回调方法</td></tr></tbody></table><p>简单地说就是像下面这样子：</p><pre><code>&lt;bean id=&quot;exampleBean&quot; name=&quot;name1, name2, name3&quot; class=&quot;com.javadoop.ExampleBean&quot;      scope=&quot;singleton&quot; lazy-init=&quot;true&quot; init-method=&quot;init&quot; destroy-method=&quot;cleanup&quot;&gt;    &lt;!-- 可以用下面三种形式指定构造参数 --&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;    &lt;!-- property 的几种情况 --&gt;    &lt;property name=&quot;beanOne&quot;&gt;        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;    &lt;/property&gt;    &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt;    &lt;property name=&quot;integerProperty&quot; value=&quot;1&quot;/&gt;&lt;/bean&gt;</code></pre><p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<lockup-method>、<replaced-method>、<meta>、<qualifier> 这几个</qualifier></replaced-method></lockup-method></p><p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p><pre><code>// BeanDefinitionParserDelegate.java 428public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {    return parseBeanDefinitionElement(ele, null);}public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {    String id = ele.getAttribute(ID_ATTRIBUTE);    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);    // 将name属性的定义按照 &quot;逗号,分好,空格&quot;切分, 形成一个别名列表数组    // 如果没有定义name, 就为空.    List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();    if (StringUtils.hasLength(nameAttr)) {        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr,             MULTI_VALUE_ATTRIBUTE_DELIMITERS);        aliases.addAll(Arrays.asList(nameArr));    }    String beanName = id;    // 如果没有指定id, 那么就用别名列表的第一个名字作为beanName    if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {        beanName = aliases.remove(0);        if (logger.isDebugEnabled()) {            logger.debug(&quot;No XML &#39;id&#39; specified - using &#39;&quot; + beanName +                    &quot;&#39; as bean name and &quot; + aliases + &quot; as aliases&quot;);        }    }    if (containingBean == null) {        checkNameUniqueness(beanName, aliases, ele);    }    // 根据 &lt;bean ..&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition, 然后把配置中的信息都设置到实例中.    // 细节后面再说, 先知道这行过后就产生了一个BeanDefinition.    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);    // 到这里, 整个&lt;bean /&gt;标签就算解析结束了, 一个BeanDefinition也形成了.    if (beanDefinition != null) {        // 如果没有设置id和name的话, 就会进入下面这块代码        if (!StringUtils.hasText(beanName)) {            try {                // 按照我们的思路，这里 containingBean 是 null 的                if (containingBean != null) {                    beanName = BeanDefinitionReaderUtils.generateBeanName(                            beanDefinition, this.readerContext.getRegistry(), true);                }                else {                    // 如果我们不定义 id 和 name，那么我们引言里的那个例子：                    //   1. beanName 为：com.javadoop.example.MessageServiceImpl#0                    //   2. beanClassName 为：com.javadoop.example.MessageServiceImpl                    beanName = this.readerContext.generateBeanName(beanDefinition);                    String beanClassName = beanDefinition.getBeanClassName();                    if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName)  &amp;&amp;                             beanName.length() &gt; beanClassName.length() &amp;&amp;                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {                        // 把beanClassName设置成别名                        aliases.add(beanClassName);                    }                }                if (logger.isDebugEnabled()) {                    logger.debug(&quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &quot; +                            &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);                }            }            catch (Exception ex) {                error(ex.getMessage(), ele);                return null;            }        }        String[] aliasesArray = StringUtils.toStringArray(aliases);        // 返回 BeanDefinitionHolder        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);    }    return null;}</code></pre><p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p><pre><code>public AbstractBeanDefinition parseBeanDefinitionElement(        Element ele, String beanName, BeanDefinition containingBean) {    this.parseState.push(new BeanEntry(beanName));    String className = null;    if (ele.hasAttribute(CLASS_ATTRIBUTE)) {        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();    }    try {        String parent = null;        if (ele.hasAttribute(PARENT_ATTRIBUTE)) {            parent = ele.getAttribute(PARENT_ATTRIBUTE);        }        // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了        AbstractBeanDefinition bd = createBeanDefinition(className, parent);        // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));        // 解析 &lt;meta /&gt;        parseMetaElements(ele, bd);        // 解析 &lt;lookup-method /&gt;        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());        // 解析 &lt;replace-method /&gt;        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());        // 解析 &lt;cnostructor-arg /&gt;        parseConstructorArgElements(ele, bd);        // 解析 &lt;property /&gt;        parsePropertyElements(ele, bd);        // 解析 &lt;qualifier /&gt;        parseQualifierElements(ele, bd);        bd.setResource(this.readerContext.getResource());        bd.setSource(extractSource(ele));        return bd;    }    catch (ClassNotFoundException ex) {        error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);    }    catch (NoClassDefFoundError err) {        error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);    }    catch (Throwable ex) {        error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);    }    finally {        this.parseState.pop();    }    return null;}</code></pre><p>到这里, 我们已经根据<bean>配置创建了一个BeanDefinitionHodler实例. 注意, 是一个.</bean></p><p>我们回到解析 <bean>的入口方法</bean></p><pre><code>protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {    // 上面一大串就是创建了BeanDefinitionHolder    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);    if (bdHolder != null) {        // 如果有自定义属性的话, 先进行相关解析, 先忽略        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);        try {            // 我们把这一步叫做 注册Bean吧            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());        }        catch (BeanDefinitionStoreException ex) {            getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +                    bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);        }        // 注册完成后，发送事件，本文不展开说这个        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));    }}</code></pre><p>我们已经根据 <bean> 生成了一个BeanDefinitionHolder, 这个实例里也就BeanDefinition和他的beanName, aliases 的信息. 注意,我们的关注点始终在BeanDefinition上.</bean></p><pre><code>public class BeanDefinitionHolder implements BeanMetadataElement {    private final BeanDefinition beanDefinition;    private final String beanName;    private final String[] aliases;}</code></pre><p>然后我们准备注册这个BeanDefinition, 最后, 把这个注册时间发送出去</p><p>下面, 我们说说注册bean吧.</p><pre><code>// BeanDefinitionReaderUtils public static void registerBeanDefinition(        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)        throws BeanDefinitionStoreException {    String beanName = definitionHolder.getBeanName();    // 注册这个bean    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());    // 如果有别名的话, 也要把别名注册一下, 不然根据别名找不到bean了    String[] aliases = definitionHolder.getAliases();    if (aliases != null) {        for (String alias : aliases) {            // alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，            // 获取的时候, 会将alias转成 beanName, 然后再查找            registry.registerAlias(beanName, alias);        }    }}</code></pre><p>别名注册先放一边,毕竟他很简单. 我们先看看怎么注册Bean</p><pre><code>// DefaultListableBeanFactory.java 793@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)        throws BeanDefinitionStoreException {    Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);    Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);    if (beanDefinition instanceof AbstractBeanDefinition) {        try {            ((AbstractBeanDefinition) beanDefinition).validate();        }        catch (BeanDefinitionValidationException ex) {            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,                    &quot;Validation of bean definition failed&quot;, ex);        }    }    // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding    BeanDefinition oldBeanDefinition;    // 之后会看到, 所有的Bean注册后会放入到这个BeanDefinitionMap中    oldBeanDefinition = this.beanDefinitionMap.get(beanName);    // 处理重复名称 bean定义的情况.    if (oldBeanDefinition != null) {        if (!isAllowBeanDefinitionOverriding()) {            // 如果不允许覆盖的话, 抛异常            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,                    &quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &#39;&quot; + beanName +                    &quot;&#39;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);        }        else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) {            // 用框架  的bean覆盖用户自定义的bean            if (this.logger.isWarnEnabled()) {                this.logger.warn(&quot;Overriding user-defined bean definition for bean &#39;&quot; + beanName +                        &quot;&#39; with a framework-generated bean definition: replacing [&quot; +                        oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);            }        }        else if (!beanDefinition.equals(oldBeanDefinition)) {            // 用新的bean覆盖旧的bean            if (this.logger.isInfoEnabled()) {                this.logger.info(&quot;Overriding bean definition for bean &#39;&quot; + beanName +                        &quot;&#39; with a different definition: replacing [&quot; + oldBeanDefinition +                        &quot;] with [&quot; + beanDefinition + &quot;]&quot;);            }        }        else {            if (this.logger.isDebugEnabled()) {                this.logger.debug(&quot;Overriding bean definition for bean &#39;&quot; + beanName +                        &quot;&#39; with an equivalent definition: replacing [&quot; + oldBeanDefinition +                        &quot;] with [&quot; + beanDefinition + &quot;]&quot;);            }        }        // 覆盖beanDefinition        this.beanDefinitionMap.put(beanName, beanDefinition);    }    else {        // 判断有没有其他bean开始初始化了        // 注意, &quot;注册bean&quot; 这个动作结束,bean依赖还没有初始化, 我们后面会有大篇幅说初始化过程        // 在spring容器启动的最后, 会 预初始化 所有的singleton beans        if (hasBeanCreationStarted()) {            // Cannot modify startup-time collection elements anymore (for stable iteration)            synchronized (this.beanDefinitionMap) {                this.beanDefinitionMap.put(beanName, beanDefinition);                List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);                updatedDefinitions.addAll(this.beanDefinitionNames);                updatedDefinitions.add(beanName);                this.beanDefinitionNames = updatedDefinitions;                if (this.manualSingletonNames.contains(beanName)) {                    Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);                    updatedSingletons.remove(beanName);                    this.manualSingletonNames = updatedSingletons;                }            }        }        else {            // 正常应该是进入这个分支            // 将BeanDefinition放入这个map中, 这个map保存了所有的BeanDefinition            this.beanDefinitionMap.put(beanName, beanDefinition);            // 这是个ArrayList, 会按照bean配置的顺序保存每一个注册的bean的名字            this.beanDefinitionNames.add(beanName);            // 这是个LinkedHashSet, 代表的是手动注册 singleton bean            // 注意这里是remove方法, 到这里的bean当然不是手动注册的.            // 手动指的是通过以下方法注册的bean:            //      registerSingleton(String beanName, Object singletonObject)            // 这不是重点, Spring会在后面&quot;手动&quot;注册一些bean            // 如&quot;environment&quot;, &quot;systemProperties&quot;等bean, 我们自己也可以在运行时注册bean到容器中.            this.manualSingletonNames.remove(beanName);        }        // 这个不重要, 初始化的时候会用到. 不用管它        this.frozenBeanDefinitionNames = null;    }    if (oldBeanDefinition != null || containsSingleton(beanName)) {        resetBeanDefinition(beanName);    }}</code></pre><p>总结一下, 到这里已经初始化了Bean容器, <bean>配置也转换成了一个个BeanDefinition, 然后注册BeanDefinition到注册中心, 并且发送了注册事件.</bean></p><hr><p>一直到上面, 东西都还算简单, 只是比较繁琐.</p><p><strong>bean容器实例化完成之后</strong></p><p>说到这里, 我们回到refresh方法, 是的,我们才刚刚说完obtainFreshBeanFactory方法.</p><pre><code>@Overridepublic void refresh() throws BeansException, IllegalStateException {   // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛   synchronized (this.startupShutdownMonitor) {      // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符      prepareRefresh();      // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，      // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，      // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();      // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean      // 这块待会会展开说      prepareBeanFactory(beanFactory);      try {         // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，         // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】         // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化         // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事         postProcessBeanFactory(beanFactory);         // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法         invokeBeanFactoryPostProcessors(beanFactory);                   // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机         registerBeanPostProcessors(beanFactory);         // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了         initMessageSource();         // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了         initApplicationEventMulticaster();         // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说         // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）         onRefresh();         // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过         registerListeners();         // 重点，重点，重点         // 初始化所有的 singleton beans         //（lazy-init 的除外）         finishBeanFactoryInitialization(beanFactory);         // 最后，广播事件，ApplicationContext 初始化完成，不展开         finishRefresh();      }      catch (BeansException ex) {         if (logger.isWarnEnabled()) {            logger.warn(&quot;Exception encountered during context initialization - &quot; +                  &quot;cancelling refresh attempt: &quot; + ex);         }         // Destroy already created singletons to avoid dangling resources.         // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源         destroyBeans();         // Reset &#39;active&#39; flag.         cancelRefresh(ex);         // 把异常往外抛         throw ex;      }      finally {         // Reset common introspection caches in Spring&#39;s core, since we         // might not ever need metadata for singleton beans anymore...         resetCommonCaches();      }   }}</code></pre><p><strong>准备bean容器: prepareBeanFactory</strong></p><p>之前我们说过, Spring把我们在xml配置的bean都注册之后,或”手动”注册一些特殊的bean.</p><p>这里简单介绍一下prepareBeanFactory(factory)方法.</p><pre><code>protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {    // 设置beanFactory的类加载器, 我们知道beanFactory需要加载类, 也就需要类加载器    // 这里设置当前Application类的类加载器    beanFactory.setBeanClassLoader(getClassLoader());    // 设置BeanExpressResolver    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));    // 添加了一个BeanPostProcessor, 这个processor比较简单:    // 实现了 Aware 接口的beans 在初始化的时候, 这个processor负责回调    // 这个我们很常用, 比如为了获取ApplicationContext而 implements ApplicationContextAware    // 注意, 他不光会回调 ApplicationContextAware,    //      还会回调 EnvironmentAware, ResourceLoaderAware等, 看下源码就知道了    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));    // 下面几行的意思是, 如果某个bean依赖以下几个接口的实现类, 在自动装配的时候会忽略他们.    // Spring会通过其他方式来处理这些依赖.    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);    // 下面几行就是为几个特殊的bean赋值. 如果有bean依赖了以下几个, 会注入这边相应的值    // 之前我们说过, &quot;当前ApplicationContext持有一个BeanFactory&quot;, 这里解释了第一行    // ApplicationContext还继承了ResourceLoader, ApplicationEventPublisher, MessageSource    // 所以对于这几个依赖, 可以赋值为this, 注意,这里的this是一个 ApplicationContext    // 那这里为什么没看到MessageSource赋值呢? 那是因为MessageSource被注册成了一个普通的bean    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);    beanFactory.registerResolvableDependency(ResourceLoader.class, this);    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);    beanFactory.registerResolvableDependency(ApplicationContext.class, this);    // 这个BeanPostProcessor也很简单, 在Bean实例化之后, 如果是ApplicationListener的子类    // 那么将其添加到listener列表中, 可以理解为: 注册事件监听器    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));    // 这里涉及到的特殊bean, 名为 loadTimeWeaver, 这不是重点, 忽略他    // tips: ltw是AspectJ的概念, 指的是运行期进行织入, 和Spring的AOP不同    if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));        // Set a temporary ClassLoader for type matching.        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));    }    // 从下面几行我们可以看到, Spring往往看起来很智能, 就是因为他会帮我们默认注册一些有用的bean    // 当然我们也可以选择覆盖    // 如果我们没有定义&quot;environment&quot;这个bean, 那么Spring会手动注册一个    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());    }    // 如果我们没有定义&quot;systemProperties&quot;这个bean, 那么Spring会手动注册一个    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());    }    // 如果我们没有定义&quot;systemEnvironment&quot;这个bean, 那么Spring会手动注册一个    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());    }}</code></pre><p>在上面这块代码中, Spring对一些特殊的bean做了处理, 暂时看不懂也没关系.</p><p><strong>初始化所有的Singleton bean</strong></p><p>我们的重点是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个方法, 这里会负责初始化所有的singleton bean</p><p>注意,在后面会用<code>初始化</code>或<code>预初始化</code>来代表这个阶段, Spring会在这个阶段完成所有Singleton bean的实例化.</p><p>我们先总结一下, 到目前为止, BeanFactory已经创建完成, 并且所有实现了BeanFactoryPostProcessor接口的bean已经初始化, 并且postProcessBeanFactory(factory)方法已经得到回调. 而且Spring也手动注册了一些特殊的Bean, 如 environment, systemProperties等.</p><p>剩下的就是初始化 singleton bean 了, 我们知道他是单例的, 如果没有懒加载, spring会在接下来初始化所有的singleton bean.</p><pre><code>// AbstractApplicationContext.java 834// 初始化所有剩余的singleton beansprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {    // 首先, 初始化名字为 convertionService的bean, conversionService相关会贴在紧跟着这块代码后    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {        //什么，看代码这里没有初始化 Bean 啊！        // 初始化的动作包装在 beanFactory.getBean()中, 这里先不说细节        beanFactory.setConversionService(                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));    }    // Register a default embedded value resolver if no bean post-processor    // (such as a PropertyPlaceholderConfigurer bean) registered any before:    // at this point, primarily for resolution in annotation attribute values.    if (!beanFactory.hasEmbeddedValueResolver()) {        beanFactory.addEmbeddedValueResolver(new StringValueResolver() {            @Override            public String resolveStringValue(String strVal) {                return getEnvironment().resolvePlaceholders(strVal);            }        });    }    // 先初始化所有 LoadTimeWeaver 类型的bean,     // 之前也说过, 这是AspectJ的内容, 先跳过    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);    for (String weaverAwareName : weaverAwareNames) {        getBean(weaverAwareName);    }    // Stop using the temporary ClassLoader for type matching.    beanFactory.setTempClassLoader(null);    // 没有什么别的目的, 这时候Spring已经开始初始化所有Singleton Bean 了,     // 肯定不希望这时候还出现bean定义解析, 加载,注册    beanFactory.freezeConfiguration();    // 开始初始化    beanFactory.preInstantiateSingletons();}</code></pre><hr><p><strong>ConversionService</strong><br>ConversionService 最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p><p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p><pre><code>&lt;bean id=&quot;conversionService&quot;  class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;  &lt;property name=&quot;converters&quot;&gt;    &lt;list&gt;      &lt;bean class=&quot;com.javadoop.learning.utils.StringToEnumConverterFactory&quot;/&gt;    &lt;/list&gt;  &lt;/property&gt;&lt;/bean&gt;</code></pre><p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p><p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p><p>来看一个很简单的例子，这样比什么都管用。</p><pre><code>public class StringToDateConverter implements Converter&lt;String, Date&gt; {    @Override    public Date convert(String source) {        try {            return DateUtils.parseDate(source, &quot;yyyy-MM-dd&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd HH:mm&quot;, &quot;HH:mm:ss&quot;, &quot;HH:mm&quot;);        } catch (ParseException e) {            return null;        }    }}</code></pre><p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p><hr><p>从最后一行进入, 又到了 DefaultListableBeanFactory 类了, 这个类我们已经不陌生了 </p><p><strong>preInstantiateSingletons</strong></p><pre><code>// DefaultListableBeanFactory.java  728@Overridepublic void preInstantiateSingletons() throws BeansException {    if (this.logger.isDebugEnabled()) {        this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);    }    // this.beanDefinitionNames 保留了所有的beanNames    List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);    // 下面这个循环, 触发所有的非懒加载的singleton beans的初始化操作    for (String beanName : beanNames) {        // 合并父bean中的配置, 注意 &lt;bean id=&quot;&quot; class=&quot;&quot; parent=&quot;&quot; /&gt; 中的parent, 用的不多        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);        // 非抽象, 非懒加载的bean 如果配置了 abstract=true, 那就不需要初始化        if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {            // 处理FactoryBean            if (isFactoryBean(beanName)) {                // FactoryBean的话, 在beanName前面加上 &#39;&amp;&#39; 符号, 再调用getBean()方法, getBean()方法先不急                final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);                // 判断当前FactoryBean是否是SmartFactoryBean的实现, 此处忽略                boolean isEagerInit;                if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {                    isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {                        @Override                        public Boolean run() {                            return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();                        }                    }, getAccessControlContext());                }                else {                    isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;                            ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());                }                if (isEagerInit) {                    getBean(beanName);                }            }            else {                // 对于普通的bean, 只要调用getBean(beanName)这个方法就可以进行初始化了                getBean(beanName);            }        }    }    // 到这里, 所有的singleton beans都已经完成初始化    // 如果我们定义的bean是实现了SmartInitializingSingleton接口的话, 在这里进行回调. 忽略    for (String beanName : beanNames) {        Object singletonInstance = getSingleton(beanName);        if (singletonInstance instanceof SmartInitializingSingleton) {            final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;            if (System.getSecurityManager() != null) {                AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {                    @Override                    public Object run() {                        smartSingleton.afterSingletonsInstantiated();                        return null;                    }                }, getAccessControlContext());            }            else {                smartSingleton.afterSingletonsInstantiated();            }        }    }}</code></pre><p>接下来我们就进入到了getBean(beanName)方法中了, 这个方法我们经常用来从beanFactory中获取一个bean, 而初始化的方法也在封装在了这个方法里.</p><p><strong>getBean</strong><br>在继续前进之前，先看看 FactoryBean 的预备知识</p><hr><p><strong>FactoryBean</strong><br>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p><pre><code>public interface FactoryBean&lt;T&gt; {    T getObject() throws Exception;    Class&lt;T&gt; getObjectType();    boolean isSingleton();}</code></pre><pre><code>public class Person {     private Car car ;    private void setCar(Car car){ this.car = car;  }  }</code></pre><p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p><pre><code>public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;{    private String make;     private int year ;    public void setMake(String m){ this.make =m ; }    public void setYear(int y){ this.year = y; }    public Car getObject(){       // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种      CarBuilder cb = CarBuilder.car();      if(year!=0) cb.setYear(this.year);      if(StringUtils.hasText(this.make)) cb.setMake( this.make );       return cb.factory();     }    public Class&lt;Car&gt; getObjectType() { return Car.class ; }     public boolean isSingleton() { return false; }}</code></pre><p>我们看看装配的时候是怎么配置的：</p><pre><code>&lt;bean class = &quot;com.javadoop.MyCarFactoryBean&quot; id = &quot;car&quot;&gt;  &lt;property name = &quot;make&quot; value =&quot;Honda&quot;/&gt;  &lt;property name = &quot;year&quot; value =&quot;1984&quot;/&gt;&lt;/bean&gt;&lt;bean class = &quot;com.javadoop.Person&quot; id = &quot;josh&quot;&gt;  &lt;property name = &quot;car&quot; ref = &quot;car&quot;/&gt;&lt;/bean&gt;</code></pre><p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p><p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？</p><pre><code>@Configuration public class CarConfiguration {     @Bean     public MyCarFactoryBean carFactoryBean(){       MyCarFactoryBean cfb = new MyCarFactoryBean();      cfb.setMake(&quot;Honda&quot;);      cfb.setYear(1984);      return cfb;    }    @Bean    public Person aPerson(){     Person person = new Person();      // 注意这里的不同    person.setCar(carFactoryBean().getObject());    return person;     } }</code></pre><p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p><hr><pre><code>// AbstractBeanFactory.java 195@Overridepublic Object getBean(String name) throws BeansException {    return doGetBean(name, null, null, false);}// 我们剖析初始化bean的过程, 但是getBean方法我们经常是用来从容器中获取bean用的, 注意切换思路// 已经初始化的bean就从容器中直接获取, 否则就先初始化再返回protected &lt;T&gt; T doGetBean(        final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)        throws BeansException {    // 获取一个&quot;正统&quot;的beanName, 处理两种情况:    // 一种是前面说的FactoryBean(名称前加 &quot;&amp;&quot;)    // 另一种就是别名, 因为这个方法是getBean, 获取bean用的, 传入一个别名也是可以的    final String beanName = transformedBeanName(name);    // 注意这个, 这是返回值    Object bean;    // 检查一下是不是已经创建过了    Object sharedInstance = getSingleton(beanName);    // 这里说下args, 虽然看上去不重要. 前面我们一路进来都是getBean(beanName),    // 所以这里args是null, 但是如果args不为null的时候, 说明想要调用方不是希望获取bean, 而是创建bean    if (sharedInstance != null &amp;&amp; args == null) {        if (logger.isDebugEnabled()) {            if (isSingletonCurrentlyInCreation(beanName)) {                logger.debug(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +                        &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);            }            else {                logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);            }        }        // 下面这个方法, 如果是普通Bean的话, 直接返回这个 sharedInstance        // 如果是FactoryBean, 返回他创建的那个实例对象        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);    }    else {        // 如果创建了此beanName的prototype类型的bean, 直接抛错        // 往往是因此陷入了循环引用        if (isPrototypeCurrentlyInCreation(beanName)) {            throw new BeanCurrentlyInCreationException(beanName);        }        // 检查一下这个BeanDefinition是否存在容器中        BeanFactory parentBeanFactory = getParentBeanFactory();        if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {            // 如果当前容器中没有这个BeanDefinition, 看看父容器中有没有            String nameToLookup = originalBeanName(name);            if (args != null) {                // 返回父容器的查询结果                return (T) parentBeanFactory.getBean(nameToLookup, args);            }            else {                // No args -&gt; delegate to standard getBean method.                return parentBeanFactory.getBean(nameToLookup, requiredType);            }        }        // typeCheckOnly为false, 将当前beanName放入一个alreadyCreated的Set集合中        if (!typeCheckOnly) {            markBeanAsCreated(beanName);        }        // 到这里总结一下, 要准备创建bean了        // 对于Singleton的bean来说, 容器中还没有创建这个bean        // 对于prototype的bean来说, 本来就是要新创建一个bean        try {            final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);            checkMergedBeanDefinition(mbd, beanName, args);            // 先初始化所有依赖的bean            // 注意, 这里依赖的bean指的是 depends-on中定义的依赖            String[] dependsOn = mbd.getDependsOn();            if (dependsOn != null) {                for (String dep : dependsOn) {                    // 检查是否有依赖循环, 这里的依赖循环和我们之前说的依赖循环不一样, 这里是肯定不允许出现的, 不然就乱套了                    if (isDependent(beanName, dep)) {                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,                                &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);                    }                    // 注册一下依赖关系                    registerDependentBean(dep, beanName);                    // 先初始化被依赖的bean                    getBean(dep);                }            }            // 如果是Singleton scope , 创建Singleton实例            if (mbd.isSingleton()) {                sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {                    @Override                    public Object getObject() throws BeansException {                        try {                            // 执行创建bean, 详情后面说                            return createBean(beanName, mbd, args);                        }                        catch (BeansException ex) {                            destroySingleton(beanName);                            throw ex;                        }                    }                });                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);            }            // 如果是prototype scope的, 创建prototype实例            else if (mbd.isPrototype()) {                // It&#39;s a prototype -&gt; create a new instance.                Object prototypeInstance = null;                try {                    beforePrototypeCreation(beanName);                    // 执行创建bean                    prototypeInstance = createBean(beanName, mbd, args);                }                finally {                    afterPrototypeCreation(beanName);                }                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);            }            // 如果不是Singleton或prototype的话, 需要委托给相应实现类进行处理              else {                String scopeName = mbd.getScope();                final Scope scope = this.scopes.get(scopeName);                if (scope == null) {                    throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);                }                try {                    Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() {                        @Override                        public Object getObject() throws BeansException {                            beforePrototypeCreation(beanName);                            try {                                // 执行创建bean                                return createBean(beanName, mbd, args);                            }                            finally {                                afterPrototypeCreation(beanName);                            }                        }                    });                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);                }                catch (IllegalStateException ex) {                    throw new BeanCreationException(beanName,                            &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +                            &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,                            ex);                }            }        }        catch (BeansException ex) {            cleanupAfterBeanCreationFailure(beanName);            throw ex;        }    }    // 最后检查一下要返回的类型对不对, 不对的话抛异常, 对的话就返回了    if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) {        try {            return getTypeConverter().convertIfNecessary(bean, requiredType);        }        catch (TypeMismatchException ex) {            if (logger.isDebugEnabled()) {                logger.debug(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +                        ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);            }            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());        }    }    return (T) bean;}</code></pre><p>接下来是分析 createBean 方法：</p><pre><code>protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args)        throws BeanCreationException;</code></pre><p>第三个参数 args 代表的创建实例需要的参数, 就是给构造器的参数或者是给FactoryBean的参数. 不过在我们的初始化阶段, args为null</p><p>这会我们到了一个新的类了, AbstractAutowireCapableBeanFactory . 看类名, AutowireCapable, 类名是不是也说明了些问题? 自动装配的能力</p><p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p><pre><code>public class MessageServiceImpl implements MessageService {    @Autowired    private UserService userService;    public String getMessage() {        return userService.getMessage();    }}</code></pre><pre><code>&lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot; /&gt;</code></pre><p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p><pre><code>// AbstractAutowireCapableBeanFactory 447@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {    if (logger.isDebugEnabled()) {        logger.debug(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);    }    RootBeanDefinition mbdToUse = mbd;    // 确保BeanDefinition中的class被加载    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);    if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {        mbdToUse = new RootBeanDefinition(mbd);        mbdToUse.setBeanClass(resolvedClass);    }    // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt;     // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。    try {        mbdToUse.prepareMethodOverrides();    }    catch (BeanDefinitionValidationException ex) {        throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),                beanName, &quot;Validation of method overrides failed&quot;, ex);    }    try {        // 让 InstantiationAwareBeanPostProcessor  在这一步有机会返回代理        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);        if (bean != null) {            return bean;        }    }    catch (Throwable ex) {        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,                &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);    }    // 重头戏 创建bean    Object beanInstance = doCreateBean(beanName, mbdToUse, args);    if (logger.isDebugEnabled()) {        logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);    }    return beanInstance;}</code></pre><p><strong>创建 Bean</strong></p><p>我们继续往里看 doCreateBean 这个方法：</p><pre><code>protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)        throws BeanCreationException {    // Instantiate the bean.    BeanWrapper instanceWrapper = null;    if (mbd.isSingleton()) {        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);    }    if (instanceWrapper == null) {        // 说明不是FactoryBean, 这里实例化bean, 非常关键. 细节之后再说        instanceWrapper = createBeanInstance(beanName, mbd, args);    }    // 这里就是bean里面,我们定义的类的实例.    final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);    // 类型    Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);    mbd.resolvedTargetType = beanType;    // 直接跳过 涉及接口 MergedBeanDefinitionPostProcessor    synchronized (mbd.postProcessingLock) {        if (!mbd.postProcessed) {            try {                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);            }            catch (Throwable ex) {                throw new BeanCreationException(mbd.getResourceDescription(), beanName,                        &quot;Post-processing of merged bean definition failed&quot;, ex);            }            mbd.postProcessed = true;        }    }    // Eagerly cache singletons to be able to resolve circular references    // even when triggered by lifecycle interfaces like BeanFactoryAware.    // 下面这块代码是为了解决循环依赖的问题    boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;            isSingletonCurrentlyInCreation(beanName));    if (earlySingletonExposure) {        if (logger.isDebugEnabled()) {            logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +                    &quot;&#39; to allow for resolving potential circular references&quot;);        }        addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() {            @Override            public Object getObject() throws BeansException {                return getEarlyBeanReference(beanName, mbd, bean);            }        });    }    // Initialize the bean instance.    Object exposedObject = bean;    try {        // 这一步也是非常关键的, 这一步负责属性装配, 因为前面只是实例化了, 并没有设值. 在这里设置属性值        populateBean(beanName, mbd, instanceWrapper);        if (exposedObject != null) {            // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？            // 这里就是处理 bean 初始化完成后的各种回调            exposedObject = initializeBean(beanName, exposedObject, mbd);        }    }    catch (Throwable ex) {        if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {            throw (BeanCreationException) ex;        }        else {            throw new BeanCreationException(                    mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);        }    }    if (earlySingletonExposure) {        Object earlySingletonReference = getSingleton(beanName, false);        if (earlySingletonReference != null) {            if (exposedObject == bean) {                exposedObject = earlySingletonReference;            }            else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {                String[] dependentBeans = getDependentBeans(beanName);                Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);                for (String dependentBean : dependentBeans) {                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {                        actualDependentBeans.add(dependentBean);                    }                }                if (!actualDependentBeans.isEmpty()) {                    throw new BeanCurrentlyInCreationException(beanName,                            &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +                            &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +                            &quot;wrapped. This means that said other beans do not use the final version of the &quot; +                            &quot;bean. This is often the result of over-eager type matching - consider using &quot; +                            &quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);                }            }        }    }    // Register bean as disposable.    try {        registerDisposableBeanIfNecessary(beanName, bean, mbd);    }    catch (BeanDefinitionValidationException ex) {        throw new BeanCreationException(                mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);    }    return exposedObject;}</code></pre><p>到这里,我们已经分析完了 doCreateBean()方法, 总的来说, 我们已经说完了整个初始化流程</p><p>接下来说说doCreateBean方法的三个细节.<br>一个是创建Bean的createBeanInstance方法, 一个是依赖注入的populateBean方法, 还有一个是回调initializeBean方法</p><p><strong>创建bean实例</strong><br>我们先看createBeanInstance方法, 挑重点的说,这个方法就是实例化我们指定的类.</p><pre><code>protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {    // 确保已经加载了此类    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);    // 校验一下这个类的访问权限    if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {        throw new BeanCreationException(mbd.getResourceDescription(), beanName,                &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot; + beanClass.getName());    }    if (mbd.getFactoryMethodName() != null)  {        // 采用工厂方法实例化, 注意, 不是FactoryBean        return instantiateUsingFactoryMethod(beanName, mbd, args);    }    // 如果不是第一次创建, 比如prototype创建第二次    // 这种情况下, 我们可以从第一次创建知道, 采用无参构造方法,还是构造函数依赖注入 来完成实例化    boolean resolved = false;    boolean autowireNecessary = false;    if (args == null) {        synchronized (mbd.constructorArgumentLock) {            if (mbd.resolvedConstructorOrFactoryMethod != null) {                resolved = true;                autowireNecessary = mbd.constructorArgumentsResolved;            }        }    }    // 如果已经创建过, 就不用再去做构造函数判断了    if (resolved) {        if (autowireNecessary) {            // 构造函数 依赖注入            return autowireConstructor(beanName, mbd, null, null);        }        else {            // 无惨构造方法            return instantiateBean(beanName, mbd);        }    }    // 判断是否采用有参构造函数    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);    if (ctors != null ||            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {        // 构造函数依赖注入        return autowireConstructor(beanName, mbd, ctors, args);    }    // 调用无参构造函数    return instantiateBean(beanName, mbd);}</code></pre><p>挑个简单的无参构造函数构造实例来看看：</p><pre><code>protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {    try {        Object beanInstance;        final BeanFactory parent = this;        if (System.getSecurityManager() != null) {            beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {                @Override                public Object run() {                    return getInstantiationStrategy().instantiate(mbd, beanName, parent);                }            }, getAccessControlContext());        }        else {            // 实例化            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);        }        // 包装一下 , 返回        BeanWrapper bw = new BeanWrapperImpl(beanInstance);        initBeanWrapper(bw);        return bw;    }    catch (Throwable ex) {        throw new BeanCreationException(                mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);    }}</code></pre><p>我们可以看到, 关键地方在于 :</p><pre><code>beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</code></pre><p>这里会进行实际的实例化过程，我们进去看看:</p><pre><code>// SimpleInstantiationStrategy 59@Overridepublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {    // 如果不存在方法覆写, 就使用反射进行实例化. 否侧使用CGLIB    if (bd.getMethodOverrides().isEmpty()) {        Constructor&lt;?&gt; constructorToUse;        synchronized (bd.constructorArgumentLock) {            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;            if (constructorToUse == null) {                final Class&lt;?&gt; clazz = bd.getBeanClass();                if (clazz.isInterface()) {                    throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);                }                try {                    if (System.getSecurityManager() != null) {                        constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() {                            @Override                            public Constructor&lt;?&gt; run() throws Exception {                                return clazz.getDeclaredConstructor((Class[]) null);                            }                        });                    }                    else {                        constructorToUse =    clazz.getDeclaredConstructor((Class[]) null);                    }                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;                }                catch (Throwable ex) {                    throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);                }            }        }        // 利用构造方法进行实例化        return BeanUtils.instantiateClass(constructorToUse);    }    else {        // 存在方法覆写, 利用CGLIB来完成实例化, 需要依赖CGLIB生成子类        // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持        return instantiateWithMethodInjection(bd, beanName, owner);    }}</code></pre><p>到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。</p><p><strong>bean属性注入</strong></p><p>看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。</p><pre><code>protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {    // bean实例的所有属性都在这里了    PropertyValues pvs = mbd.getPropertyValues();    if (bw == null) {        if (!pvs.isEmpty()) {            throw new BeanCreationException(                    mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);        }        else {            // Skip property population phase for null instance.            return;        }    }    // 到这一步的时候, bean实例化完成 (通过工厂方法或构造函数) , 但是还没开始属性设值    // InstantiationAwareBeanPostProcessor 的实现类可以在这里对bean进行状态修改    // 我也没找到有实际的使用，所以我们暂且忽略这块吧    boolean continueWithPropertyPopulation = true;    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {        for (BeanPostProcessor bp : getBeanPostProcessors()) {            if (bp instanceof InstantiationAwareBeanPostProcessor) {                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                // 如果返回false, 代表不需要 进行后续的属性修改也不需要再经过其他的BeanPostProcessor处理                if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {                    continueWithPropertyPopulation = false;                    break;                }            }        }    }    if (!continueWithPropertyPopulation) {        return;    }    if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);        // 通过名字找到所有的属性值, 如果是bean依赖, 先初始化依赖的bean, 记录依赖关系        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {            autowireByName(beanName, mbd, bw, newPvs);        }        // 通过类型装配, 复杂一些        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {            autowireByType(beanName, mbd, bw, newPvs);        }        pvs = newPvs;    }    boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();    boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);    if (hasInstAwareBpps || needsDepCheck) {        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);        if (hasInstAwareBpps) {            for (BeanPostProcessor bp : getBeanPostProcessors()) {                if (bp instanceof InstantiationAwareBeanPostProcessor) {                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                    // 这里有个非常有用的BeanPostProcessor进到这里 : AutowiredAnnotationBeanPostProcessor                    // 对采用@Autowire, @Value注解的进行设值                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);                    if (pvs == null) {                        return;                    }                }            }        }        if (needsDepCheck) {            checkDependencies(beanName, mbd, filteredPds, pvs);        }    }    // 设置 bean 实例的属性值    applyPropertyValues(beanName, mbd, bw, pvs);}</code></pre><p><strong>initializeBean</strong></p><p>属性注入完成之后, 这一步其实就是处理回调了.这块代码比较简单</p><pre><code>protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {    if (System.getSecurityManager() != null) {        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {            @Override            public Object run() {                invokeAwareMethods(beanName, bean);                return null;            }        }, getAccessControlContext());    }    else {        // 如果Bean实现了BeanNameAware, BeanClassLoaderAware, 或 BeanFactoryAware接口, 回调        invokeAwareMethods(beanName, bean);    }    Object wrappedBean = bean;    if (mbd == null || !mbd.isSynthetic()) {        // BeanPostProcessor的postProcessorBeforeInitialization回调        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);    }    try {        // 处理bean中定义的 init-method        // 或者如果bean实现了InitializingBean , 调用 afterPropertiesSet()方法        invokeInitMethods(beanName, wrappedBean, mbd);    }    catch (Throwable ex) {        throw new BeanCreationException(                (mbd != null ? mbd.getResourceDescription() : null),                beanName, &quot;Invocation of init method failed&quot;, ex);    }    if (mbd == null || !mbd.isSynthetic()) {        // BeanPostProcessor的postProcessorAfterInitialization回调        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);    }    return wrappedBean;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 思而不学则殆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的最大容量是多少.</title>
      <link href="/2020/06/06/2020-06-06/"/>
      <url>/2020/06/06/2020-06-06/</url>
      
        <content type="html"><![CDATA[<h3 id="HashMap的最大容量是多少"><a href="#HashMap的最大容量是多少" class="headerlink" title="HashMap的最大容量是多少."></a>HashMap的最大容量是多少.</h3><p>首先, HashMap底层是数组+链表, 所以HashMap的容量约等于 <code>数组长度 * 链表长度</code>.<br>因为链表长度不固定,甚至可能链表会是树结构, 所以我们主要讨论数组长度.</p><p>那么, 数组的最大长度是多长呢? 仔细想想, 好像这么多年也没去看过数组的源码(笑).</p><pre><code>一是规范隐含的限制。Java数组的length必须是非负的int，所以它的理论最大值就是java.lang.Integer.MAX_VALUE = 2^31-1 = 2147483647。二是具体的实现带来的限制。这会使得实际的JVM不一定能支持上面说的理论上的最大length。例如说如果有JVM使用uint32_t来记录对象大小的话，那可以允许的最大的数组长度（按元素的个数计算）就会是：(uint32_t的最大值 - 数组对象的对象头大小) / 数组元素大小</code></pre><p>嗯..数组长度理论上可以达到 2^31-1 这么长, 那么HashMap的最大长度也是这么了?</p><p>不, 在HashMap中规定HashMap底层数组的元素最大为 1&lt;&lt;30</p><pre><code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></pre><p>为啥呢? 理论上不是可以更长吗?</p><p>还记得我们以前提到过的HashMap会把容量定为输入容量的最近的2次幂.</p><pre><code>static final int tableSizeFor(int cap) {    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}</code></pre><p>这串是干嘛呢?</p><p>现在想象一个场景, <code>new HashMap(9);</code><br>我想初始化一个长度为9的HashMap</p><pre><code>cap: 00000000 00000000 00000000 00001001int n = cap - 1:00000000 00000000 00000000 00001000n &gt;&gt;&gt; 1:00000000 00000000 00000000 00000100n |= n &gt;&gt;&gt; 1:00000000 00000000 00000000 00001100n &gt;&gt;&gt; 2:00000000 00000000 00000000 00000011n |= n &gt;&gt;&gt; 2:00000000 00000000 00000000 00001111n &gt;&gt;&gt; 4:00000000 00000000 00000000 00001111n |= n &gt;&gt;&gt; 4:00000000 00000000 00000000 00001111n &gt;&gt;&gt; 8:00000000 00000000 00000000 00001111n |= n &gt;&gt;&gt; 8:00000000 00000000 00000000 00001111n &gt;&gt;&gt; 16:00000000 00000000 00000000 00001111n |= n &gt;&gt;&gt; 16:00000000 00000000 00000000 00001111</code></pre><p>这边计算了什么呢</p><pre><code>00000000 00000000 00000000 00001111 = 15</code></pre><p>也就是将原本最高的一位后面全部变成1<br>也即, 变成了 <code>2^n -1</code><br>这样只要最后结果加1, 就会变成离他最近的2次幂.</p><p>那这些有什么用呢?</p><p><code>00000000 00000000 00000000 00000001</code> 左边不是31个位置吗? 为什么最大容量不是 1 &lt;&lt; 31 ?</p><p>如果左移31, 就会变成<code>10000000 00000000 00000000 00000000</code>,<br>而最高位, 即最左边的位是符号位, 1为负数.</p><pre><code>// 运行这条System.out.println(0b10000000_00000000_00000000_00000000);// 输出-2147483648</code></pre><p>数组长度总不能是负数吧. 所以HashMap的数组长度最长是 1&lt;&lt;30</p><hr><p>尝试了一下添加1&lt;&lt;30个数进HashMap</p><pre><code>public static void main(String[] args) {    int times = 1&lt;&lt;30;    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; times; i++) {        map.put(i, i);        System.out.println(i);    }}</code></pre><p>可以看到, 我没有设置HashMap初始大小, 因此默认大小是16, 因为我们知道, HashMap在一定条件下会扩容, 扩容导致的问题就是数据迁移.</p><p>所以在运行到 1486699 的时候第一次出现明显卡顿,时间很短 大概一秒左右, 再往后的输出停顿时间越来越久.</p><p>因此小伙伴们如果预先知道要装多少数据, 或者大概数据, 不妨精心计算一下HashMap的初始大小.我认为 总数据量 / (3|4|5|6) 都可以.</p><p>因为按照同一节点下链表的数据多少规律, 同一个节点下挂载多个数据的概率是逐渐减少的.(而且没有哪个map会装这么多数据吧</p><pre><code>0:    0.606530661:    0.303265332:    0.075816333:    0.012636064:    0.001579525:    0.000157956:    0.000013167:    0.000000948:    0.00000006</code></pre><p>在 23739181 的时候就OOM了, 或许下次把堆内存调大点再试试(逃</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS同步器原理</title>
      <link href="/2020/02/26/2020-2-27/"/>
      <url>/2020/02/26/2020-2-27/</url>
      
        <content type="html"><![CDATA[<p>总所周知,java是支持多线程的.<br>在多线程情况下,可能会出现多个线程同时访问同一个<code>共享</code>,<code>可变</code>资源的情况;这种资源可能是:对象,变量,文件等.<br>共享:资源可以由多个线程同时访问<br>可变:资源可以在其生命周期内被修改</p><h3 id="为什么需要同步器"><a href="#为什么需要同步器" class="headerlink" title="为什么需要同步器"></a>为什么需要同步器</h3><p>先来个栗子</p><pre><code>    public void decStock(){        Integer stock;        stock = getStock();        if (stock == null || stock &lt;= 0){            System.out.println(&quot;下单失败,库存不足&quot;);            return;        }        stock--;        writeStock(stock);        System.out.println(&quot;下单成功,当前剩余库存 : &quot; + stock);    }</code></pre><p>这是一个下订单的场景,为了防止超卖的问题,所以做了<br>先读取库存 -&gt; 判断库存是否充足 -&gt; 减少库存 -&gt; 将修改后的库存写回数据库<br>这种操作.</p><p>那就来测试一下,库存初始设置为5,同时发送30个请求.</p><pre><code>下单成功,当前剩余库存 : 4下单成功,当前剩余库存 : 4下单成功,当前剩余库存 : 4下单成功,当前剩余库存 : 4下单成功,当前剩余库存 : 4下单成功,当前剩余库存 : 4下单成功,当前剩余库存 : 4下单成功,当前剩余库存 : 3下单成功,当前剩余库存 : 2下单成功,当前剩余库存 : 1下单成功,当前剩余库存 : 0下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足</code></pre><p>可以看出,明显是发生了多次超卖的情况,订单超过了库存数量. </p><p>那么,为什么呢?<br>因为 读取库存,写回库存这是两个操作,并不是原子性的.<br>也就满足了上面所说的<code>共享</code>,<code>可变</code>的情况.<br>在多线程情况下,可能会发生,线程1在读取库存之后停下,将cpu让给线程2的情况.导致线程1和线程2获取到的库存数量是相同的,导致超卖.</p><h3 id="如何解决呢"><a href="#如何解决呢" class="headerlink" title="如何解决呢?"></a>如何解决呢?</h3><p>在方法上加一个synchronized关键词即可.</p><pre><code>    synchronized public void decStock(){        Integer stock;        stock = getStock();        if (stock == null || stock &lt;= 0){            System.out.println(&quot;下单失败,库存不足&quot;);            return;        }        stock--;        writeStock(stock);        System.out.println(&quot;下单成功,当前剩余库存 : &quot; + stock);    }</code></pre><p>结果:</p><pre><code>下单成功,当前剩余库存 : 4下单成功,当前剩余库存 : 3下单成功,当前剩余库存 : 2下单成功,当前剩余库存 : 1下单成功,当前剩余库存 : 0下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足</code></pre><p>这么简单?<br>此处讨论单机情况下,在服务器只部署一个实例时,就是这么简单.他将这个方法变成了一个不可分割,不可中断的原子操作,每一次线程读取的数据都会是前一个线程确保已经写完了的数据.<br>但是单纯会使用synchronized关键词并不是目的,我想要知道synchronized到底做了什么可以保证不超卖.</p><h3 id="AQS同步器"><a href="#AQS同步器" class="headerlink" title="AQS同步器"></a>AQS同步器</h3><p>synchronized是基于底层C++语言实现的同步机制,而AQS同步器是纯java实现的.<br>因此这个东西放在<code>java.util.concurrent</code>包下,是一个抽象类 <code>AbstractQueuedSynchronizer</code>.<br>AQS核心有三种东西: CAS,自旋,LockSupport</p><h3 id="自己写一个AQS同步器"><a href="#自己写一个AQS同步器" class="headerlink" title="自己写一个AQS同步器"></a>自己写一个AQS同步器</h3><pre><code>public class MyLock {    // 用于记录当前锁的状态    @Getter    @Setter    private volatile int state = 0;    // 当前持有锁的线程    @Getter    @Setter    private Thread lockHolder;    private static final Unsafe UNSAFE = UnsafeInstance.reflectGetUnsafe();    private static final long stateOffset;    // 用于保存对排队状态的线程的引用    // 必须保证该队列的线程安全    private ConcurrentLinkedQueue&lt;Thread&gt; waiters = new ConcurrentLinkedQueue&lt;&gt;();    static {        try {            stateOffset = UNSAFE.objectFieldOffset(MyLock.class.getDeclaredField(&quot;state&quot;));        }catch (Exception e){            throw new Error();        }    }    public final boolean compareAndSwapState(int expect, int update){        // cas  compare and swap 原子操作        return UNSAFE.compareAndSwapInt(this, stateOffset, expect, update);    }    private boolean aquire(){        Thread current = Thread.currentThread();        int currentState = getState();        // currentState等于0,锁还没被持有,这时可以加锁        if (currentState == 0){            // 线程存放队列如果是空,或者当前线程是队列的队首的话,允许该线程进行加锁.否则加锁失败            if ((waiters.size() == 0 || current == waiters.peek()) &amp;&amp; compareAndSwapState(currentState, 1)){                // 在加锁成功后,要将锁持有者改为当前线程                setLockHolder(current);                return true;            }        }        // 如果尝试加锁失败,返回false        return false;    }    public void lock(){        // 刚开始开始尝试加锁        if (aquire()){            // 如果首次加锁成功,直接返回            return;        }        // 首次加锁失败,将该线程存放到队列中进行排队        Thread current = Thread.currentThread();        waiters.add(current);        // 进行自旋        for (;;){            // 在死循环中尝试进行加锁.            // 只有队首线程可以尝试加锁,其他线程使用park让出cpu资源.            if (current == waiters.peek() &amp;&amp; aquire()){                // 如果队首线程加锁成功,将该线程出队列.                waiters.poll();                return;            }            // 将该线程阻塞以让出cpu使用权.等待后续唤醒.            LockSupport.park(current);        }    }    public void unlock(){        // 只有锁持有者才可以进行解锁        if (Thread.currentThread() != lockHolder){            throw new RuntimeException(&quot;lockHolder is not current thread&quot;);        }        int state = getState();        // 进行解锁,将state设置为0以便下个线程加锁        if (compareAndSwapState(state, 0)){            // 已经进行解锁,将斥锁人改为null            setLockHolder(null);            // 唤醒队首的线程            Thread first = waiters.peek();            if (first != null){                LockSupport.unpark(first);            }        }    }}public class UnsafeInstance {    public static Unsafe reflectGetUnsafe(){        try {            // 使用反射去获取Unsafe类,因为Unsafe这个魔法类可以绕过虚拟机直接操作内存. 视为危险操作.            Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);            field.setAccessible(true);            return (Unsafe) field.get(null);        } catch (NoSuchFieldException e) {            e.printStackTrace();        } catch (IllegalAccessException e) {            e.printStackTrace();        }        return null;    }}</code></pre><p>使用我们完成的Lock类对方法进行加锁</p><pre><code>    private MyLock sync = new MyLock();    public void decStock(){        sync.lock();        Integer stock;        stock = getStock();        if (stock == null || stock &lt;= 0){            System.out.println(&quot;下单失败,库存不足&quot;);            sync.unlock();            return;        }        stock--;        writeStock(stock);        System.out.println(&quot;下单成功,当前剩余库存 : &quot; + stock);        sync.unlock();    }</code></pre><p>结果显示:</p><pre><code>下单成功,当前剩余库存 : 4下单成功,当前剩余库存 : 3下单成功,当前剩余库存 : 2下单成功,当前剩余库存 : 1下单成功,当前剩余库存 : 0下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足下单失败,库存不足</code></pre><p>当然,AQS并没有仅仅是上面这么简单,他还加入了一些其他的特性如:</p><ul><li>阻塞等待队列</li><li>共享/独占</li><li>公平/非公平</li><li>可重入</li><li>允许中断</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring如何getBean</title>
      <link href="/2020/01/13/2020-1-13/"/>
      <url>/2020/01/13/2020-1-13/</url>
      
        <content type="html"><![CDATA[<p>spring总是有一种神奇的魔力,让人想要去探究他到底是做了什么.</p><h4 id="提前搭建好工程"><a href="#提前搭建好工程" class="headerlink" title="提前搭建好工程"></a>提前搭建好工程</h4><p><img src="/2020/01/13/2020-1-13/selectSpringStruct.jpg" alt="在IDEA中选择Spring"></p><ul><li>不要选择Spring Initializr, 那是使用SpringBoot的,不利于学习使用.</li></ul><p>一路下一步, 填写项目名称, finish.</p><p>可以看到,在项目目录下的lib中,IDEA会帮我们把包导好.<br><img src="/2020/01/13/2020-1-13/springJars.jpg" alt="lib"></p><p>直接开始代码<br><img src="/2020/01/13/2020-1-13/projectLibrary.jpg" alt="项目目录结构"></p><blockquote><p>启动类放置的位置是按照SpringBoot的习惯,实际放在哪里都可以.</p></blockquote><pre><code>// Hello类中的代码public class Hello {    private String message = &quot;&quot;;    public String getMessage(){        return message;    }    public void setMessage(String message){        this.message = message;    }    public Hello(){}    public Hello(String message){        this.message = message;    }}// HelloConfig类中的代码@Configuration@ComponentScan(basePackages = &quot;com.echi.demo&quot;)public class HelloConfig {    @Bean    public Hello hello(){        return new Hello(&quot;hello world&quot;);    }}// 主启动类的代码public class MainClass {    public static void main(String[] args) {        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(HelloConfig.class);        Hello hello = (Hello)applicationContext.getBean(&quot;hello&quot;);        System.out.println(hello.getMessage());    }}</code></pre><p>因为是学习,所以没有加入SpringMvc中关于父子容器,路径拦截的配置, 简简单单创建一个容器将bean放进去再取出来就好了.</p><h4 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h4><p>因为是要看看spring是获取bean的,所以直接将断点打在getBean()这行.<br><img src="/2020/01/13/2020-1-13/mainInterupt.jpg" alt></p><p>从下面将spring中的代码贴上来<br>spring代码好看的一点就是,名字都很长, 可以做到见名知意</p><h5 id="bean没有标注-Lazy"><a href="#bean没有标注-Lazy" class="headerlink" title="bean没有标注@Lazy"></a>bean没有标注@Lazy</h5><pre><code>    // 类名 AbstractApplicationContext    @Override    public Object getBean(String name) throws BeansException {        // 看看这个beanFactory是不是还活着        // 如果已经死亡抛出一个IllegalStateException         assertBeanFactoryActive();        // 根据名称去获取bean        return getBeanFactory().getBean(name);    }    // 类名 AbstractBeanFactory    @Override    public Object getBean(String name) throws BeansException {        return doGetBean(name, null, null, false);    }    protected &lt;T&gt; T doGetBean(            final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)            throws BeansException {        // 这句和返回值没关系可以不看, 是处理bean的名称的.         // bean可以拥有别名,也可能是由factoryBean导致的名称干扰        final String beanName = transformedBeanName(name);        Object bean;        // Eagerly check singleton cache for manually registered singletons.        // 这句已经有注释, 是 直接去单例缓存池中获取bean.        // 因为我们没有配置懒加载,所以这边会获取到bean        // 返回值就是我们在config中配置的Hello对象        Object sharedInstance = getSingleton(beanName);         if (sharedInstance != null &amp;&amp; args == null) {            // 省略部分是一些log            ...            // 此处是做一些判断,因为bean已经取出来了.但是取出来的有可能是factoryBean            // 如果是factoryBean,是不能直接用的,还要通过factoryBean来获取bean            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);        }        else {            // 这部分代码是没取到时的处理,稍后再展开            ...        }        // Check if required type matches the type of the actual bean instance.        // 做最后的检查        if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) {            // 检查代码省略            ...        }        // 已经获取到bean, 也已经做过检查, 确认没问题了 将bean返回        return (T) bean;    }</code></pre><p>在上面这段代码可以看到,成功获取到bean.<br>但是只有get()的动作,那什么时候放进去的呢?</p><p>既然在getBean()的时候没有看到在哪里放进去,那断点就往前打一句<br><img src="/2020/01/13/2020-1-13/ApplicationInterrupt.jpg" alt></p><pre><code>    // 类名 AnnotationConfigApplicationContext    public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {        // 做一些初始化的工作        // 在这里初始化了        // - beanFactory        // - AnnotatedBeanDefinitionReader        // - ClassPathBeanDefinitionScanner        this();        register(annotatedClasses);        // 主要内容在这个方法内        refresh();    }    // 类名 AbstractApplicationContext    // 这个方法里全是调用,调用链很深,就不深入进去了.    @Override    public void refresh() throws BeansException, IllegalStateException {        synchronized (this.startupShutdownMonitor) {            // 省略部分代码            ...            try {                ...                // 在这一个方法内,将Hello类的BeanDefinition装入beanDefinitionMap中.                invokeBeanFactoryPostProcessors(beanFactory);                ...                // 在这个方法内将Hello类装入到单例缓存池中.                finishBeanFactoryInitialization(beanFactory);                ...            }            catch (BeansException ex) {                // 省略不必要的代码                ...            }            finally {                ...            }        }    }    // 类名 AbstractApplicationContext    protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {        // 省略代码        ...        // 调用了beanFactory的方法将类装载进单例缓存池        beanFactory.preInstantiateSingletons();    }    // 类名 DefaultListableBeanFactory    @Override    public void preInstantiateSingletons() throws BeansException {        ...        // 获取bean定义的名称        List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);        // 循环去挨个实例化        for (String beanName : beanNames) {            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);            if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {                // 如果是factoryBean, 有factoryBean的实例化方式                if (isFactoryBean(beanName)) {                    // 使用factoryBean的方式创建bean                    ...                }                // 如果是单纯的bean,直接走上面getBean时省略的步骤.                // 在getBean()中会创建bean                else {                    getBean(beanName);                }            }        }        for (String beanName : beanNames) {            // 调用bean初始化后的回调            ...        }    }</code></pre><p>仔细看一下getBean中创建bean的方式</p><pre><code>    protected &lt;T&gt; T doGetBean(            final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)            throws BeansException {        final String beanName = transformedBeanName(name);        Object bean;        // 因此这里讨论的是使用该方法创建bean,所以单例缓存池中应该是没有缓存该bean的.        Object sharedInstance = getSingleton(beanName); // 返回null        if (sharedInstance != null &amp;&amp; args == null) {            // 不讨论此处            ...        }        else {            // 在单例缓存池中没有找到bean, 进入该判断分支            // 判断是否有依赖循环的情况            if (isPrototypeCurrentlyInCreation(beanName)) {                throw new BeanCurrentlyInCreationException(beanName);            }            // 看看有没有父容器,是不是在父容器中已经有该bean            BeanFactory parentBeanFactory = getParentBeanFactory();            if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {                // 没有父容器, 此处不讨论                ...            }            if (!typeCheckOnly) {                // 将该bean标记为已创建, 防止多线程竞争时创建多次. 内部使用的是双重检查                markBeanAsCreated(beanName);            }            try {                // 开始创建bean的流程                // 先获取beanDefinition                final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);                checkMergedBeanDefinition(mbd, beanName, args);                // 检查该bean有没有依赖其他bean, 如果有需要将依赖的bean先解决                String[] dependsOn = mbd.getDependsOn();                if (dependsOn != null) {                    // 解决依赖bean                    ...                }                // 正式开始创建bean                // 如果是单例bean,进入该分支                if (mbd.isSingleton()) {                    sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {                        @Override                        public Object getObject() throws BeansException {                            try {                                // 再内部就是一堆很深的调用,不再深入.                                return createBean(beanName, mbd, args);                            }                            catch (BeansException ex) {                                destroySingleton(beanName);                                throw ex;                            }                        }                    });                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);                }                // 创建prototype的bean进入该分支                // prototype就是每次获取都是一个全新的bean                else if (mbd.isPrototype()) {                    // It&#39;s a prototype -&gt; create a new instance.                    Object prototypeInstance = null;                    try {                        beforePrototypeCreation(beanName);                        prototypeInstance = createBean(beanName, mbd, args);                    }                    finally {                        afterPrototypeCreation(beanName);                    }                    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);                }                else {                    String scopeName = mbd.getScope();                    final Scope scope = this.scopes.get(scopeName);                    // 如果不是单例也不是原型模式, 说明是其他的 request ,session和global session                    // 这几种scope都是和web请求相关的                }            }            catch (BeansException ex) {                cleanupAfterBeanCreationFailure(beanName);                throw ex;            }        }        if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) {            ...        }        return (T) bean;    }</code></pre><h5 id="bean标注-Lazy的情况"><a href="#bean标注-Lazy的情况" class="headerlink" title="bean标注@Lazy的情况"></a>bean标注@Lazy的情况</h5><p>@Lazy表示懒加载,只有在使用的情况才会去加载.<br>在上面的例子中,bean的创建是在<code>ApplicationContext applicationContext = new AnnotationConfigApplicationContext(HelloConfig.class);</code>这一行执行时创建的,在getBean()时直接可以取到.<br>加了@Lazy注解之后,bean的创建的在getBean()的时候去创建并放入单例缓存池中的.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot(二) SpringBoot如何实现自动配置</title>
      <link href="/2020/01/10/2020-1-10/"/>
      <url>/2020/01/10/2020-1-10/</url>
      
        <content type="html"><![CDATA[<p>springboot也用了很久了,用的时候只知道他很好用,不需要再额外的配置乱七八糟的东西,那么到底是怎么做到的呢?<br>以前我只会回答:SpringBoot中已经帮助我们配置了.<br>现在回过来看看这个问题, 配置千奇百怪,SpringBoot是怎么满足所有人的需求呢?</p><h2 id="Servlet3-x"><a href="#Servlet3-x" class="headerlink" title="Servlet3.x"></a>Servlet3.x</h2><p>在开始SpringBoot之前,要先引入Servlet3.x<br>JavaWeb中怎么导入三大组件呢?</p><ul><li>web.xml</li><li>@WebServlet/@WebFilter/@WebListener</li><li>SPI机制</li></ul><h3 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h3><p>SPI即Service Provider Interface.<br>在之前,如果有两个发送短信的供应商,阿里和腾讯.分别要实现两个服务商的接口调用</p><pre><code>public interface SmsService {    void sendSms(String mobile, String message);}public class AliSmsService implements SmsService {    @Override    public void sendSms(String mobile, String message) {        System.out.println(&quot;ali send message&quot;);    }}public class TencentSmsService implements SmsService {    @Override    public void sendSms(String mobile, String message) {        System.out.println(&quot;tencent send message&quot;);    }}</code></pre><p>在使用的时候呢?想要用哪个就要将哪个服务实例化.</p><pre><code>public class MainClass {    public static void main(String[] args) {        SmsService smsService = new AliSmsService();        smsService.sendSms(&quot;13111111111&quot;, &quot;message content&quot;);    }}</code></pre><p>这样执行输出结果就是AliSmsService中的结果.</p><pre><code>ali send message</code></pre><p>那产品提需求了,我不想要让阿里的服务商发送,他们的短信到达率没有腾讯高.<br>这种实现就只能去修改代码,将AliSmsService修改为TencentSmsService.</p><p>而使用SPI机制, 只需要在项目的META-INF/services中添加一个文件.<br>这个文件的文件名为借口的全类名,内容为实现了这个接口的实现类.<br><img src="/2020/01/10/2020-1-10/SPIDemo.jpg" alt></p><pre><code>// 文件名: com.example.repository.SmsService// 文件内容: com.example.repository.AliSmsServicepublic class MainClass {    public static void main(String[] args) {        ServiceLoader&lt;SmsService&gt; smsServices = ServiceLoader.load(SmsService.class);        Iterator&lt;SmsService&gt; iterator = smsServices.iterator();        while (iterator.hasNext()){            iterator.next().sendSms(&quot;13111111111&quot;, &quot;message content&quot;);        }    }}</code></pre><p>输出结果</p><pre><code>ali send message</code></pre><p>如果想要将AliService改为TencentService, 只需要将内容改为</p><pre><code>com.example.repository.TencentSmsService// 输出tencent send message</code></pre><p>看起来很复杂,不要紧重点不在这里.</p><p>结合之前在<a href="https://echi1995.github.io/2019/12/10/2019-12-10/">SpringBoot(一)</a>中提到的<code>@Import</code>注解.</p><h2 id="SpringBoot做了什么"><a href="#SpringBoot做了什么" class="headerlink" title="SpringBoot做了什么"></a>SpringBoot做了什么</h2><ul><li>内置Tomcat</li><li>启动时自动配置</li></ul><h3 id="内置Tomcat"><a href="#内置Tomcat" class="headerlink" title="内置Tomcat"></a>内置Tomcat</h3><p>记得以前使用spring框架的时候,启动时需要选择一下tomcat容器,整个项目也没有一个启动类.<br>在使用SpringBoot之后,有了一个主启动类,也不需要再选择tomcat了.<br>但是项目运行的时候,又会打出tomcat已经开始运行的log</p><pre><code>[main] Tomcat initialized with port(s): 8080 (http)[main] Starting service [Tomcat][main] Starting Servlet engine: [Apache Tomcat/9.0.29][main] Initializing Spring embedded WebApplicationContext[main] Root WebApplicationContext: initialization completed in 959 ms[main] Initializing ExecutorService &#39;applicationTaskExecutor&#39;[main] Tomcat started on port(s): 8080 (http) with context path &#39;&#39;</code></pre><p>因此我们去找一下tomcat藏在哪里.</p><pre><code>@SpringBootApplicationpublic class DemoApplication {    public static void main(String[] args) {        // 进入run()        SpringApplication.run(DemoApplication.class, args);    }}    // 索引到SpringApplication.run(String... args)方法中    public ConfigurableApplicationContext run(String... args) {        ...        try {            ...            // 定位到该方法处.            refreshContext(context);            ...        }        catch (Throwable ex) {            ...        }        ...        return context;    }    private void refreshContext(ConfigurableApplicationContext context) {        refresh(context);        ...    }        protected void refresh(ApplicationContext applicationContext) {        Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);        // 进入refresh方法        ((AbstractApplicationContext) applicationContext).refresh();    }    @Override    public void refresh() throws BeansException, IllegalStateException {        synchronized (this.startupShutdownMonitor) {            ...            try {                ...                // 进入该方法                // Initialize other special beans in specific context subclasses.                onRefresh();                ...            }            catch (BeansException ex) {                ...            }finally {                ...            }        }    }    // 找到onRefresh()方法, 他的默认实现是不做任何事.     // 找到他的子类ServletWebServerApplicationContext中的实现    protected void onRefresh() throws BeansException {        // For subclasses: do nothing by default.    }    @Override    protected void onRefresh() {        super.onRefresh();        try {            // 进入该方法            createWebServer();        }        catch (Throwable ex) {            throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);        }    }    private void createWebServer() {        ...        if (webServer == null &amp;&amp; servletContext == null) {            // 创建tomcat工厂            ServletWebServerFactory factory = getWebServerFactory();            // 创建tomcat            // 进入 getWebServer()            this.webServer = factory.getWebServer(getSelfInitializer());        }        else if (servletContext != null) {            ...        }        ...    }    // ServletWebServerFactory接口中的方法    // 找到他的子类TomcatServletWebServerFactory    WebServer getWebServer(ServletContextInitializer... initializers);    // TomcatServletWebServerFactory中创建tomcat的方法    @Override    public WebServer getWebServer(ServletContextInitializer... initializers) {        ...        // 创建了tomcat        Tomcat tomcat = new Tomcat();        // 对tomcat做一些设置 ex. setPort()        ...        // 进入该方法        return getTomcatWebServer(tomcat);    }    protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {        // 进入TomcatWebServer的构造器        return new TomcatWebServer(tomcat, getPort() &gt;= 0);    }    public TomcatWebServer(Tomcat tomcat, boolean autoStart) {        Assert.notNull(tomcat, &quot;Tomcat Server must not be null&quot;);        this.tomcat = tomcat;        this.autoStart = autoStart;        // 进入该方法        initialize();    }    private void initialize() throws WebServerException {        synchronized (this.monitor) {            try {                ...                // Start the server to trigger initialization listeners                // 启动tomcat                this.tomcat.start();                ...            }            catch (Exception ex) {                ...            }        }    }</code></pre><p>因此,SpringBoot不需要再放到tomcat中是因为他内部已经帮助我们启动好了tomcat<br>因此只要把整个项目达成jar包, 用java -jar xxx.jar 就可以启动了.</p><p>接下来找找tomcat放在那里了. </p><pre><code>&lt;!--在项目下的pom.xml中内容--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;!--进入--&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--spring-boot-starter-2.2.2.RELEASE.pom 中内容--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;!--进入--&gt;  &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;  &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;  &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;!--spring-boot-autoconfigure-2.2.2.RELEASE.pom 中内容--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;    &lt;!--内置tomcat--&gt;  &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;  &lt;version&gt;9.0.29&lt;/version&gt;  &lt;scope&gt;compile&lt;/scope&gt;  &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>这部分要从@SpringBootApplication注解开始讲起, 这个注解很眼熟啊. SpringBoot的启动类上都会写,他内部都有什么呢?<br>主要有三部分</p><ul><li><p>@SpringBootConfiguration</p></li><li><p>@ComponentScan</p></li><li><p>@EnableAutoConfiguration</p><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>@SpringBootConfiguration有啥作用呢?</p><pre><code>@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration {  @AliasFor(annotation = Configuration.class)  boolean proxyBeanMethods() default true;}</code></pre><p>好像没看到什么有用的东西, 实际他就是一个@Configuration, 这么标注意味着在主启动类中也可以配置bean</p><pre><code>@SpringBootApplicationpublic class DemoApplication {  public static void main(String[] args) {      SpringApplication.run(DemoApplication.class, args);  }  // 意味着这样写这个@Bean是生效的.  @Bean  public User user(){      return new User();  }}</code></pre><p>但是因为这些东西可以写在其他配置文件中,为了避免污染启动类,所以一般不这么写.</p></li></ul><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>这个注解是配置包扫描的范围, 这个范围是主启动类所在的包及其子包.<br>比如我当前主启动类是在com.example.demo下,那么就只会扫描com.example.demo*的包.<br>如果有其他的类放在如com.example.foo下面,就不会进行扫描<br>会扫描范围内所有被@Repository,@Service,@Controller,@Component注解修饰的类.</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>在这个注解中, 有一个<code>@Import(AutoConfigurationImportSelector.class)</code>.<br>这是之前提到的@Import的一种用法,导入一个ImportSelector,</p><pre><code>    @Override    public String[] selectImports(AnnotationMetadata annotationMetadata) {        if (!isEnabled(annotationMetadata)) {            return NO_IMPORTS;        }        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader                .loadMetadata(this.beanClassLoader);        // 进入该方法        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,                annotationMetadata);        // 得到的返回值 就是所有使用到的,需要自动配置的类的全类名.        // 再由ImportSelector的使用,由全类名开始实例化.        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());    }    protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,            AnnotationMetadata annotationMetadata) {        if (!isEnabled(annotationMetadata)) {            return EMPTY_ENTRY;        }        AnnotationAttributes attributes = getAttributes(annotationMetadata);        // 进入该方法        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);        // 在读取完全部配置之后,将重复的去除.        configurations = removeDuplicates(configurations);        // 去除@ComponentScan中 exclude 中指定的值        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);        checkExcludedClasses(configurations, exclusions);        configurations.removeAll(exclusions);        configurations = filter(configurations, autoConfigurationMetadata);        // 将没有导入jar包的类去除        fireAutoConfigurationImportEvents(configurations, exclusions);        return new AutoConfigurationEntry(configurations, exclusions);    }    protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {        // 此处传入的是@EnableAutoConfiguration的全类名        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),                getBeanClassLoader());        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;                + &quot;are using a custom packaging, make sure that file is correct.&quot;);        return configurations;    }    //     public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) {        String factoryTypeName = factoryType.getName();        // 进入该方法        return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());    }    private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {        MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);        if (result != null) {            return result;        }        try {            // public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;            // 去读取META-INF/spring.factories中            // org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的value            Enumeration&lt;URL&gt; urls = (classLoader != null ?                    classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :                    ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));            result = new LinkedMultiValueMap&lt;&gt;();            while (urls.hasMoreElements()) {                URL url = urls.nextElement();                UrlResource resource = new UrlResource(url);                // 实际也是用properties的方式                Properties properties = PropertiesLoaderUtils.loadProperties(resource);                for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {                    String factoryTypeName = ((String) entry.getKey()).trim();                    for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {                        result.add(factoryTypeName, factoryImplementationName.trim());                    }                }            }            cache.put(classLoader, result);            return result;        }        catch (IOException ex) {            throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +                    FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);        }    }</code></pre><p>这样SpringBoot就把需要自动配置的类,以及哪些需要配置哪些不需要配置给加载好了.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springIOC</title>
      <link href="/2020/01/03/2020-1-3/"/>
      <url>/2020/01/03/2020-1-3/</url>
      
        <content type="html"><![CDATA[<p>以前学习spring的时候总是说spring的特点是IOC和AOP,那具体是什么呢?<br>要是让我回答,我可能只知道IOC是一个管理bean的容器,需要使用bean的时候可以由IOC容器自动注入.<br>现在想想,通俗一点说: 我想要吃一些水果,因此有了水果这个类.</p><pre><code>public class Fruit {}public class Apple extends Fruit {}public class Orange extends Fruit {}public class Person {    Fruit fruit;}</code></pre><h4 id="不使用IOC"><a href="#不使用IOC" class="headerlink" title="不使用IOC"></a>不使用IOC</h4><p>如果不使用IOC, 那我需要自己去开辟一块地将水果种出来</p><pre><code>public class Person {    Fruit fruit = new Apple();}</code></pre><p>当我今天不想吃苹果,想吃橘子的时候,必须去修改Person类中的Fruit实现类.</p><pre><code>public class Person {    Fruit fruit = new Orange();}</code></pre><h4 id="使用IOC"><a href="#使用IOC" class="headerlink" title="使用IOC"></a>使用IOC</h4><p>如果使用IOC, 只要去水果店告诉店员一声,我需要水果, 水果店提供什么水果就可以吃什么水果</p><pre><code>public class Person {    @Autowired    Fruit fruit;}@Configurationpublic class Supermarket {    @Bean    public Fruit supply(){        return new Apple();    }}</code></pre><p>如果不想吃苹果,只要让水果店提供的水果改成另一种就可以了.<br>当然也有可能水果店会提供多种水果, 那只要声明一下想要哪种水果.</p><pre><code>@Configurationpublic class Supermarket {    @Bean    public Fruit apple(){        return new Apple();    }    @Bean    public Fruit orange(){        return new Orange();    }}public class Person {    @Autowired    @Qualifier(&quot;orange&quot;)    Fruit fruit;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java - spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile如何实现有序性</title>
      <link href="/2020/01/02/2020-1-2/"/>
      <url>/2020/01/02/2020-1-2/</url>
      
        <content type="html"><![CDATA[<p>之前在java内存模型中提到过volatile,这次更深入一些探究一些volatile到底是怎么实现有序性.</p><p>我们分成五个部分来看</p><ul><li>java源码</li><li>ByteCode字节码</li><li>JVM虚拟机规范</li><li>JVM虚拟机实现</li><li>CPU级别</li></ul><p><img src="/2020/01/02/2020-1-2/volatile5Part.jpg" alt="volatile五个部分"></p><h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><p>源码中使用的volatile关键字在字节码中会被添加一个ACC_VOLATILE的前缀标识</p><pre><code>public class VolatileT {    volatile int i;}</code></pre><p>使用  <code>javap -verbose VolatileT.class</code>  指令进行反编译</p><pre><code>  volatile int i;    descriptor: I    flags: ACC_VOLATILE</code></pre><p>看到,在i的flags中添加了<code>ACC_VOLATILE</code>这个标签,并没有多余的操作</p><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>JVM虚拟机规范规定了四种内存屏障</p><ul><li>LoadLoad屏障: 在后续load前,保证之前load要读取的数据读取完毕</li><li>StroeStroe屏障: 在后续store前, 保证之前要store的数据存储完毕</li><li>LoadStore屏障: 在后续stroe钱,保证之前load要读取的数据读取完毕</li><li>StroeLoad屏障: 在后续load钱, 保证之前要stroe存储完毕</li></ul><p><img src="/2020/01/02/2020-1-2/protective.jpg" alt><br>如果两条指令想要操作同一块内存的话,加一层屏障,不允许这两条指令之间进行重排.</p><p><img src="/2020/01/02/2020-1-2/volatileJvm.jpg" alt="volatile在JVM层面的实现"><br>volatile在写操作的时候,要求前面指令的写完之后再写,后面的指令等待写完之后再读.<br>volatile在读操作的时候,要求前面的指令读完之后再读,后面的指令等待读完之后再写.</p><blockquote><p>这是JVM规范,具体要看不同虚拟机的实现.</p></blockquote><p>HotSpot实现内存屏障实际使用汇编语言的Lock指令实现的.</p><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>要想实现在一个CPU中修改完,另一个CPU立刻可以感知到,这需要使用缓存一致性协议.</p><p>X86CPU内存屏障</p><ul><li>sfence: 在sfence指令前的写操作必须在sfence指令后的写操作前完成</li><li>lfence: 在lfence指令前的读操作必须在lfence指令后的读操作前完成</li><li>mfence: 在mfence指令前的读写操作必须在mfence指令后的读写操作前完成</li></ul><p>fence: 栅栏<br>s: save<br>l: load<br>m: memory</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis核心数据结构</title>
      <link href="/2019/12/30/2019-12-30/"/>
      <url>/2019/12/30/2019-12-30/</url>
      
        <content type="html"><![CDATA[<p>之前项目中使用redis就是很简单的将值以键值对的形式放进去,顶多设个过期时间.<br>现在去看了一下redis实际上也提供了很多有用的功能,学习一下以备以后用得上.</p><h3 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>string就是平常用的键值对,没有太多好说的,很简单.</p><h5 id="string的常用操作"><a href="#string的常用操作" class="headerlink" title="string的常用操作"></a>string的常用操作</h5><blockquote><p>SET key value<br>MSET key value [key value…]<br>SETNX key value                    // 存入一个不存在的键值对 (可以用作cas)<br>GET key<br>MGET key [key…]<br>DEL key [key…]<br>EXPIRE key seconds              // 设置key的过期时间</p></blockquote><p>一些原子操作</p><blockquote><p>INC key                         // 将key中对应的值加1<br>DECR key                        // 将key中对应的值减1<br>INCRBY key increment            // 将key中对应的值加[increment]<br>DECRBY key decrement            // 将key中对应的值减[increment]</p></blockquote><h5 id="string指令可以用来做什么"><a href="#string指令可以用来做什么" class="headerlink" title="string指令可以用来做什么"></a>string指令可以用来做什么</h5><p>在这里,<code>SETNX</code>命令是只有当key不存在的时候才生效, <code>SETNX actually means &quot;SET if Not eXists&quot;.</code><br>可以用于:<br>当多线程竞争,先写入且写成功的那个线程成功加锁, 在执行完毕后将该key删除, 后续的线程可以继续争夺该锁.</p><pre><code>public void doSomethingWithCAS(String key) {    try (Jedis client = getClient()) {        client.select(dbId);        while (true){            Long setnx = client.setnx(key, &quot;&quot;);            if (setnx &gt; 0){                // 获取锁成功                // doSomething                // 释放锁                client.del(key);            }else {                // 如果获取锁没成功, 将线程阻塞或者休眠                // 这里简单处理                Thread.sleep(20);                //如果是选择将线程阻塞,需要在释放锁的地方将阻塞的线程重新唤醒                //LockSupport.park();            }            break;        }    } catch (Exception e) {        logger.error(e);    }}</code></pre><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>hash就不再是一个key对应一个value, 他更像是一个key对应一个Map.<br><img src="/2019/12/30/2019-12-30/hashStruct.jpg" alt="hash结构示意图"></p><h5 id="hash常用操作"><a href="#hash常用操作" class="headerlink" title="hash常用操作"></a>hash常用操作</h5><blockquote><p>HSET key field value<br>HSETNX key field value                  // 不存在时才会存储成功<br>HMSET key field value [key value…]<br>HGET key field<br>HMGET key field [field..]<br>HDEL key field [field…]<br>HLEN key                                // 返回key中所有field的总数<br>HGETALL key                                // 返回key中所有的键值</p></blockquote><p>原子操作</p><blockquote><p>HINCRBY key field increment             // 为field的值增加[increment]</p></blockquote><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list代表一个key对应一系列的value<br><img src="/2019/12/30/2019-12-30/listStruct.jpg" alt="list结果示意图"></p><h5 id="list常用操作"><a href="#list常用操作" class="headerlink" title="list常用操作"></a>list常用操作</h5><blockquote><p>LPUSH key value [value…]  // 从list列表的表头插入(左边)<br>RPUSH key value [value…]  // 从list列表的表尾插入(右边)<br>LPOP key                    // 移除并返回list的表头<br>RPOP key                    // 移除并返回list的表尾<br>LRANGE key start stop       // 返回list指定区间的元素, 以[start]和[stop]定位区间<br>BLPOP key [key…] timeout  // 从表头获取一个元素,如果列表中没有元素则阻塞. 如果timeout=0,则一直阻塞<br>BRPOP key [key…] timeout  // 从表尾获取一个元素, 如果列表中没有元素则阻塞.</p></blockquote><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><h5 id="set常用操作"><a href="#set常用操作" class="headerlink" title="set常用操作"></a>set常用操作</h5><blockquote><p>SADD key member [member…]<br>SREM key member [member…]     // 从set中删除远古三<br>SMEMBERS key                    // 获取set中的元素<br>SCARD key                       // 获取set的元素个数<br>SISMEMBER key member            // 判断[member]是否存在set集合中<br>SRANDMEMBER key [count]         // 从set中随机选出[count]个元素, 元素不从set中删除<br>SPOP key [count]                // 从set中随机选出[count]个元素, 元素从set中删除</p></blockquote><h5 id="set运算操作"><a href="#set运算操作" class="headerlink" title="set运算操作"></a>set运算操作</h5><blockquote><p>SINTER key [key…]                     // 取交集<br>SINTERSTORE destination key [key…]    // 将交集结果存入新的[destination]集合中<br>SUNION key [key…]                     // 取并集<br>SUNIONSTORE destination key [key…]    // 将并集结果存入新的[destination]集合中<br>SDIFF key [key…]                      // 取差集<br>SDIFFSTORE destination key [key…]     // 将差集结果存入新的[destination]集合中</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2019/12/18/2019-12-18/"/>
      <url>/2019/12/18/2019-12-18/</url>
      
        <content type="html"><![CDATA[<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>先贴一张从网上偷来的图<br><img src="/2019/12/18/2019-12-18/HashMapFlow.png" alt="HashMap添加元素流程"></p><h4 id="HashMap核心数据结构"><a href="#HashMap核心数据结构" class="headerlink" title="HashMap核心数据结构"></a>HashMap核心数据结构</h4><p>Hash表 = 数组 + 线性链表 + 红黑树</p><h4 id="为什么初始容量是2的指数幂"><a href="#为什么初始容量是2的指数幂" class="headerlink" title="为什么初始容量是2的指数幂?"></a>为什么初始容量是2的指数幂?</h4><p>如果创建HashMap时指定的大小不是2的指数就会报错吗?</p><pre><code>Map map = new HashMap&lt;&gt;(13);</code></pre><p>这行代码在编译的时候也不会报错,那为什么说初始容量是2的指数呢?</p><p>看一下HashMap的构造器</p><pre><code>public HashMap(int initialCapacity, float loadFactor) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                           initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                           loadFactor);    this.loadFactor = loadFactor;    // 调用了tableSizeFor()方法    this.threshold = tableSizeFor(initialCapacity);}static final int tableSizeFor(int cap) {    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}</code></pre><p>tableSizeFor写的奇奇怪怪的嘞, 这一长串是干嘛呢?</p><blockquote><p>因为initCapacity必定大于等于0, 所以在他的二进制数中,首位必然是1.而且initCapacity最大值又小于32位.<br>因此,先将他右移一位取或,结果的前两位必然也是1,依次将后续的所有位数全部变成1, 得到的就是他所在的,距离值最近的2^n-1. 最后将该值 +1 就得到了比initCapacity大,且距离最近的2的指数值.</p></blockquote><p>那为什么呢? 为什么一定要将容量设置为2的指数呢?初始容量给多少就是多少不行吗?<br>先提一些题外话, 哈希值可以很大也可以很小,如何将这个很大范围的哈希值塞进很小的一个数组里呢?<br>很容易想到的方法就是对这个值取余,这样不管多大的数值,散布在这个数组各个索引的概率也差不多相等.<br>在HashMap中,计算索引的方法是</p><pre><code>// n = table.length// hash = hash(key)i = (n - 1) &amp; hashstatic final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>因为n都被置为2的指数,n = 0000 0000 0100 0000, n - 1 = 0000 0000 0011 1111,这样做且运算时,hash值前面的位数和0做&amp;计算都是0,直接取hash后几位就可以了,而且这个结果的范围就在0 ~ n-1之间.</p><h4 id="加载因子为什么是0-75"><a href="#加载因子为什么是0-75" class="headerlink" title="加载因子为什么是0.75?"></a>加载因子为什么是0.75?</h4><pre><code>/* * &lt;p&gt;As a general rule, the default load factor (.75) offers a good * tradeoff between time and space costs.  Higher values decrease the * space overhead but increase the lookup cost (reflected in most of * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number of entries in * the map and its load factor should be taken into account when * setting its initial capacity, so as to minimize the number of * rehash operations.  If the initial capacity is greater than the * maximum number of entries divided by the load factor, no rehash * operations will ever occur. */</code></pre><p>从HashMap中摘下来的一段注释, 加载因子决定了当数组填充多少时,才开始扩容.<br>理论上来说数组的每个位置都是有均等的可能放入元素的,那是不是填个1,当所有的位置都占满了才去扩容呢?<br>理论是这样的,但是会有可能发生 有一个位置就是没有数据,其他格子下链的数据已经堆积起来了. 这样去get(key)的时候会花费更长的时间.<br>同样的道理,基于空间上考虑,在尽量数组装的差不多的时候才去考虑扩容.毕竟每个位置放入元素的机会都是均等的.<br>因此,<code>the default load factor (.75) offers a good tradeoff between time and space costs</code>.</p><h4 id="为什么链表长度为8的时候-会去转为红黑树"><a href="#为什么链表长度为8的时候-会去转为红黑树" class="headerlink" title="为什么链表长度为8的时候,会去转为红黑树?"></a>为什么链表长度为8的时候,会去转为红黑树?</h4><p>这里要引入一个泊松分布的概念<br><a href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html" target="_blank" rel="noopener">泊松分布和指数分布：10分钟教程</a><br>在HashMap的源码中也有相应的概率显示</p><pre><code>* 0:    0.60653066* 1:    0.30326533* 2:    0.07581633* 3:    0.01263606* 4:    0.00157952* 5:    0.00015795* 6:    0.00001316* 7:    0.00000094* 8:    0.00000006* more: less than 1 in ten million</code></pre><p>可以看到,在链表长度为8的时候概率已经非常小了, 已经小于千万分之一.所以即使在长度超过8的情况下链表会转成红黑树,树的出现依然很少见.<br><code>Because TreeNodes are about twice the size of regular nodes.</code></p><h4 id="JAVA7的HashMap扩容出现的问题"><a href="#JAVA7的HashMap扩容出现的问题" class="headerlink" title="JAVA7的HashMap扩容出现的问题"></a>JAVA7的HashMap扩容出现的问题</h4><p>JAVA7中扩容的代码主要是下面这段. 当然,中间还有一段重新计算索引的被我删掉, 考虑的是扩容后链表内存放的数据重新计算数组下标依然一样的情况.</p><pre><code>for (Entry&lt;K, V&gt; e : table){    while (null != e){        Entry&lt;K, V&gt; next = e.next;        e.next = newTable[i];        newTable[i] = e;        e = next;    }}</code></pre><p>如果进行扩容,扩容后的结果<br><img src="/2019/12/18/2019-12-18/beforeResize.jpg" alt="扩容前"><br><img src="/2019/12/18/2019-12-18/afterResize.jpg" alt="扩容后"><br>可以看到,扩容后链表是顺序倒了过来.</p><p>如果是两个线程同时遇到扩容问题,<br>t1为线程1, e1,next1为t1中的e和next对象.<br>t2为线程2, e2,next2为t2中的e和next对象.<br>若t2在<code>Entry&lt;K, V&gt; next = e.next;</code>时挂起,由t1执行,t1执行结束后:<br><img src="/2019/12/18/2019-12-18/t2Park.jpg" alt="t2挂起"><br>根据我们上面看到的扩容后链表顺序返过来,<br><img src="/2019/12/18/2019-12-18/t1Finish.jpg" alt="t1执行结束"></p><p><img src="/2019/12/18/2019-12-18/t2FirstLoop.jpg" alt="t2第一次循环后"><br><img src="/2019/12/18/2019-12-18/eEqNext.jpg" alt="t2第二次循环结束"><br>第二次循环执行完毕, 在t1时,两次循环后就已经跳出循环. 但是在t2这里, e仍然非空,所以要继续执行.</p><p>第三次循环执行到<code>e.next = newTable[i];</code>时,出现了一个问题<br><img src="/2019/12/18/2019-12-18/loop3Bug.jpg" alt="n1.next = n2; n2.next = n1;"><br><img src="/2019/12/18/2019-12-18/loop3End.jpg" alt="第三次循环结束时"><br>第三次循环结束时,e == null 结束循环.<br>但是t2线程中的链表已经形成了一个环状.</p><h4 id="JAVA8的HashMap扩容"><a href="#JAVA8的HashMap扩容" class="headerlink" title="JAVA8的HashMap扩容"></a>JAVA8的HashMap扩容</h4><p>JAVA8中,HashMap的扩容不再使用重新计算数组下标,挨个移动. 这样就避免了next的指来指去导致链表形成环状的情况.</p><pre><code>Node&lt;K,V&gt; loHead = null, loTail = null;Node&lt;K,V&gt; hiHead = null, hiTail = null;Node&lt;K,V&gt; next;do {    next = e.next;    if ((e.hash &amp; oldCap) == 0) {        if (loTail == null)            loHead = e;        else            loTail.next = e;        loTail = e;    }    else {        if (hiTail == null)            hiHead = e;        else            hiTail.next = e;        hiTail = e;    }} while ((e = next) != null);if (loTail != null) {    loTail.next = null;    newTab[j] = loHead;}if (hiTail != null) {    hiTail.next = null;    newTab[j + oldCap] = hiHead;}</code></pre><p>在JAVA8中, 使用的是四个指针,高低位指针,将链表直接分成两段. 低位将低位链表放入新数组的原索引位置, 高位将高位链表放入扩容出的新空间中,相应位置.<br>这样处理避免了挨个元素移动,并且将链表的长度减少.<br><img src="/2019/12/18/2019-12-18/java8HashMap.jpg" alt><br>假设有这么一个数组, n1,n3计算结果为低位, n2,n4计算结果为高位.<br><img src="/2019/12/18/2019-12-18/loHiLink.jpg" alt><br>将loHead放到原来的3位置,hiHead放入3+16位置<br><img src="/2019/12/18/2019-12-18/java8AfterResize.jpg" alt><br>这样就避免了环状的情况,因为hash值和容量做计算的时候,结果始终是一样的.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发</title>
      <link href="/2019/12/16/2019-12-16/"/>
      <url>/2019/12/16/2019-12-16/</url>
      
        <content type="html"><![CDATA[<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>在java里,同步控制怎么做?<br>加锁. 专业术语叫同步器</p><ul><li>synchronize(基于JVM底层,基于C++, 底层行为不可控)</li><li>AbstractQueueSynchronizer(不利用任何JVM内置锁), 基于java可变行为去实现同步</li></ul><h3 id="j-u-c"><a href="#j-u-c" class="headerlink" title="j.u.c."></a>j.u.c.</h3><p>为了实现并发访问的控制, 在Java 5版本添加了<code>java.utils.concurrent</code>包</p><table><thead><tr><th>非线程安全</th><th>线程安全</th></tr></thead><tbody><tr><td>HashMap</td><td>ConcurrentHashMap</td></tr><tr><td>ArrayList</td><td>CopyOnWriteArrayList</td></tr><tr><td>HashSet</td><td>CopyOnWriteArraySet</td></tr><tr><td>priorityQueue</td><td>PriorityBlockingQueue</td></tr></tbody></table><h4 id="核心三部分"><a href="#核心三部分" class="headerlink" title="核心三部分"></a>核心三部分</h4><ul><li>CAS</li><li>自旋</li><li>LockSupport</li></ul><p>用CAS保证状态修改的原子性<br>用自旋阻塞<br>在自旋到一定程度时,使用LockSupport将线程阻塞,让出cpu使用权</p><p>下面做一个简单的并发情况 : </p><pre><code>// 在一个秒杀场景下, 库存是有限的. 需要保证没有超卖的情况public class TradeService {    private static int stock = 5;    public void decStockNoLock() throws InterruptedException {        Thread current = Thread.currentThread();        if (stock &gt; 0){            System.out.println(current.getName() + &quot; : 购买成功&quot; );            Thread.sleep(1);            stock = stock - 1;            System.out.println(current.getName() + &quot; : 库存还剩 &quot; + stock);            System.out.println();        }else {            System.out.println(&quot;购买失败, 库存不足&quot;);        }    }}public class MainTest {    public static void main(String[] args) throws InterruptedException {        TradeService tradeService = new TradeService();        Thread[] threads = new Thread[10];        for (int i = 0; i &lt; 10; i++) {            Thread thread = new Thread(new Runnable() {                @Override                public void run() {                    try {                        tradeService.decStockNoLock();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            });            thread.setName(&quot;thread - &quot; + i);            threads[i] = thread;        }        for (Thread thread : threads) {            thread.start();            thread.join();        }    }}</code></pre><p>输出结果 : </p><pre><code>thread - 0 : 购买成功thread - 0 : 库存还剩 4thread - 4 : 购买成功thread - 9 : 购买成功thread - 2 : 购买成功thread - 1 : 购买成功thread - 3 : 购买成功thread - 5 : 购买成功thread - 4 : 库存还剩 3thread - 3 : 库存还剩 2thread - 7 : 购买成功thread - 1 : 库存还剩 0thread - 9 : 库存还剩 1购买失败, 库存不足thread - 2 : 库存还剩 -1购买失败, 库存不足thread - 7 : 库存还剩 -2thread - 5 : 库存还剩 -3</code></pre><p>可以看到, 原本库存只有5个的商品,但是卖出去了8个. 这是因为线程在争夺CPU资源的时候可能会被挂起, 这个挂起可能会出现在判断库存之后减少库存之前. 在这之间其他的线程使用未减少的库存过了if判断导致超卖的情况出现.</p><p>哪怕将库存的修饰由static改成volatile也解决不了这种问题.</p><p>这种情况下是因为获取库存数量进行判断和减少库存没有保持原子性.<br>要想多个操作之间保持原子性,就要将这几个操作锁在一起.即,同一时刻仅允许一个线程做该操作,将其他想要进入该锁块内的线程挂起,在操作全部做完之后再进行唤醒.</p><p>那就可以使用上面提到的同步器核心三个部分,</p><pre><code>public class TradeService {    private volatile int state = 0;    private static final Unsafe UNSAFE = UnSafeInstance.reflectGetUnsafe();    private final static long staticOffset;    private Thread lockHolder;    private volatile int stock = 5;    private Queue&lt;Thread&gt; threadQueue = new ConcurrentLinkedDeque&lt;&gt;();    static {        try {            // 找到&quot;state&quot;在类内的偏移量            staticOffset = UNSAFE.objectFieldOffset(TradeService.class.getDeclaredField(&quot;state&quot;));        } catch (Exception e) {            throw new Error(e);        }    }    // 进行一次 cas原子修改    public boolean compareAndSwapState(int expect, int update){        //(要修改的对象, 修改的字段在类内的偏移量, 预期值, 修改值)        return UNSAFE.compareAndSwapInt(this, staticOffset, expect, update);    }    public int getState(){        return state;    }    public void decStockNoLock() throws InterruptedException {        Thread current = Thread.currentThread();        for (;;){            int state = getState();            if (state == 0){                if (compareAndSwapState(0, 1)){                    // 如果加锁成功                    lockHolder = current;                    break;                }            }            // 如果加锁失败,把当前线程阻塞住, 释放CPU资源            // 阻塞之前需要把线程保存起来.            // 需要FIFO这样的队列, 避免像synchronized唤醒所有有阻塞停留在管程对象上的线程            threadQueue.add(current);            LockSupport.park();        }        // 已经加锁成功        // todo 做一些操作        if (stock &gt; 0){            System.out.println(current.getName() + &quot; : 购买成功&quot; );            Thread.sleep(1);            stock = stock - 1;            System.out.println(current.getName() + &quot; : 库存还剩 &quot; + stock);            System.out.println();        }else {            System.out.println(&quot;购买失败, 库存不足&quot;);        }        // 解锁        for (;;){            int state = getState();            if (state != 0 &amp;&amp; lockHolder == current){                compareAndSwapState(state, 0);                // 释放锁需要通知被阻塞的线程.                if (threadQueue.size() &gt; 0){                    Thread thread = threadQueue.poll();                    LockSupport.unpark(thread);                }                break;            }        }    }}</code></pre><p>输出结果 : </p><pre><code>thread - 1 : 购买成功thread - 1 : 库存还剩 4thread - 3 : 购买成功thread - 3 : 库存还剩 3thread - 0 : 购买成功thread - 0 : 库存还剩 2thread - 4 : 购买成功thread - 4 : 库存还剩 1thread - 8 : 购买成功thread - 8 : 库存还剩 0购买失败, 库存不足购买失败, 库存不足购买失败, 库存不足购买失败, 库存不足购买失败, 库存不足</code></pre><p>这么看是解决了超卖的问题, 但是为什么要这么麻烦呢? 使用synchronized不也是一样的效果吗?</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>先来看一下synchronized,可以怎么用</p><h4 id="synchronizad有三种使用方法"><a href="#synchronizad有三种使用方法" class="headerlink" title="synchronizad有三种使用方法"></a>synchronizad有三种使用方法</h4><ul><li>同步实例方法, 锁是当前实例对象</li><li>同步类方法, 锁是当前类对象</li><li>同步代码块, 锁是括号里面的对象</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>JVM内置锁, 通过内部对象<code>Monitor</code>(监视器锁)实现,基于进入与退出Monitor对象实现方法与代码块同步, 监视器锁的实现依赖底层操作系统的<code>Mutex Lock</code>(互斥锁)实现, 它是一个重量级锁性能较低.<br><img src="/2019/12/16/2019-12-16/synchronized.jpg" alt="synchronized"></p><p>在JAVA 1.5和以前, synchronized性能非常低,在JAVA 1.6之后, JVM对synchronized进行了大量的优化,引入了偏向锁和轻量级锁.<br>锁的切换只能升级,不能进行降级.<br><img src="/2019/12/16/2019-12-16/locks.jpg" alt="锁之间的关系"></p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA内存模型</title>
      <link href="/2019/12/12/2019-12-12/"/>
      <url>/2019/12/12/2019-12-12/</url>
      
        <content type="html"><![CDATA[<h3 id="JMM-java内存模型"><a href="#JMM-java内存模型" class="headerlink" title="JMM java内存模型"></a>JMM java内存模型</h3><h4 id="多核CPU并发缓存架构"><a href="#多核CPU并发缓存架构" class="headerlink" title="多核CPU并发缓存架构"></a>多核CPU并发缓存架构</h4><p><img src="/2019/12/12/2019-12-12/cpu.jpg" alt="CPU和内存之间的交互是有多级缓存的"><br>CPU和主存之间会有高速缓存,这个缓存速度非常快,空间也非常小.<br>在使用时,先把数据从主存存放到高速缓存,CPU使用时主要和高速缓存做交互.</p><h4 id="JAVA线程内存模型"><a href="#JAVA线程内存模型" class="headerlink" title="JAVA线程内存模型"></a>JAVA线程内存模型</h4><p>JAVA的线程内存模型跟CPU缓存类似,是基于CPU缓存模型来建立的.<br><img src="/2019/12/12/2019-12-12/jmm.jpg" alt="JAVA内存模型"></p><p>看一段代码 :</p><pre><code>public class VolatileVisibilityTest {    // 设置一个共享变量,供两个线程使用    private static Boolean initFlag = false;    public static void main(String[] args) throws InterruptedException {        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(&quot;waiting data...&quot;);                // 只有当initFlag为true时, 即第二个线程修改数据结束时,才会停止循环                while (!initFlag){}                // 停止循环的标志就是打印出这行日志                System.out.println(&quot;------ success --------&quot;);            }        }).start();        // 确保第一个线程已经开始进入准备循环        Thread.sleep(1000);        new Thread(new Runnable() {            @Override            public void run() {                // 将initFlag改为true                prepareData();            }        }).start();    }    public static void prepareData(){        System.out.println(&quot;prepare data...&quot;);        initFlag = true;        System.out.println(&quot;prepare data end...&quot;);    }}</code></pre><p>这个运行结果不是很明显吗, 在线程1等待的时候, 线程2将initFlag改为true, 线程1获取到的值为true跳出循环打印success日志.</p><p>但是实际情况是 : </p><pre><code>waiting data...prepare data...prepare data end...</code></pre><p>然后程序就停在这里,没有退出也没有下次日志的输出.</p><p>我们回头看一下, JAVA线程内存模型那张图. 线程2将initFlag改为true后, 同步到主存中. 但是线程1中保存的共享变量值仍然是false, 这就导致了两个线程使用的共享变量值不一样.</p><p>那怎么解决这个问题呢?<br>使用volatile关键字修饰initFlag</p><pre><code>private static volatile Boolean initFlag = false;</code></pre><p>输出结果 :</p><pre><code>waiting data...prepare data...prepare data end...------ success --------</code></pre><p>volataile是保证线程之间可以感知共享变量的修改的.</p><h4 id="JMM数据原子操作"><a href="#JMM数据原子操作" class="headerlink" title="JMM数据原子操作"></a>JMM数据原子操作</h4><ul><li>read(读取) : 从主存读取数据</li><li>load(载入) : 将主存读取到的数据写入工作内存</li><li>use(使用) : 从工作内存读取数据来计算</li><li>assign(赋值) : 将计算好的值重新赋值到工作内存中</li><li>store(存储) : 将工作内存数据写入主存</li><li>write(写入) : 将store过去的变量值赋值给主存中的变量</li><li>lock(锁定) : 将主存变量枷锁,标识为线程独占状态</li><li>unlock(解锁) : 将主存变量解锁,解锁后其他线程可以锁定该变量</li></ul><p>结合上面的例子, 看看都做了哪些原子操作<br><img src="/2019/12/12/2019-12-12/threadVisiable.gif" alt="没有加volatile时所做的原子操作"></p><h4 id="JMM缓存不一致性问题"><a href="#JMM缓存不一致性问题" class="headerlink" title="JMM缓存不一致性问题"></a>JMM缓存不一致性问题</h4><p>早期CPU为了解决不一致的问题采用的是总线加锁的方法.</p><ul><li><p>总线加锁<br>CPU从主存读取数据到高速缓存,会在总线对这个数据加锁,这样其他的CPU没法去读或写这个数据, 直到这个CPU使用完数据释放锁之后其他CPU才能读取该数据.即,将并行的程序,让他串行执行.</p></li><li><p>MESI缓存一致性协议<br>多个CPU从主存读取同一个数据到各自的高速缓存, 当其中某个CPU修改了缓存里的数据,该数据会马上同步会主存,其他CPU通过<code>总线嗅探机制</code>可以感知到数据的变化从而将自己缓存里的数据失效.</p></li></ul><h4 id="volatile可见性原理"><a href="#volatile可见性原理" class="headerlink" title="volatile可见性原理"></a>volatile可见性原理</h4><p>底层实现主要是通过汇编<code>lock前缀指令</code>, 它会锁定这块内存区域的缓存并回写到主内存</p><ul><li>会将当前处理器缓存行的数据<code>立即</code>写回到系统内存</li><li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效(MESI协议)</li></ul><p>如果volatile没有使用lock将主存中的共享变量锁定,其他CPU会有可能在共享变量修改前再次读取变量<br><img src="/2019/12/12/2019-12-12/ifVolatileNotLock.gif" alt="如果volatile没有使用lock"></p><p>所以volatile在写入到工作内存的时候,提前给共享变量加锁.这样其他CPU察觉到共享变量失效时来取的时候只能等待共享变量修改完成.<br><img src="/2019/12/12/2019-12-12/volatile.gif" alt="加锁以防止在还没有修改完成时被读取"></p><h4 id="volatile原子性问题"><a href="#volatile原子性问题" class="headerlink" title="volatile原子性问题"></a>volatile原子性问题</h4><p>先举个栗子:</p><pre><code>public class VolatileAtomicTest {    private static volatile long num = 0;    private static void increase(){        num++;    }    public static void main(String[] args) throws InterruptedException {        Thread[] threads = new Thread[10];        for (int i = 0; i &lt; threads.length; i++) {            threads[i] = new Thread(new Runnable() {                @Override                public void run() {                    for (int j = 0; j &lt; 1000; j++) {                        increase();                    }                }            });            threads[i].start();        }        for (Thread thread : threads) {            thread.join();        }        System.out.println(num); // num = 10 * 1000 ?    }}</code></pre><p>最终输出应该是多少呢?<br>运行五次,分别是 10000, 9997, 9980, 10000, 10000<br>可以看到, 最终结果应该是小于等于10000的.<br>为什么会这样呢? 不是通过volatile将线程间的数值同步了吗.</p><p>我们模拟一下两个线程之间做i++的情况</p><table><thead><tr><th>线程</th><th>操作</th><th>主存i值</th><th>工作内存i值</th></tr></thead><tbody><tr><td>t1</td><td>i++</td><td>0</td><td>1</td></tr><tr><td>t2</td><td>i++</td><td>0</td><td>1</td></tr><tr><td>t1</td><td>sotre</td><td>1</td><td>1</td></tr><tr><td>t2</td><td>i失效</td><td>1</td><td>1(失效)</td></tr><tr><td>t2</td><td>read</td><td>1</td><td>1</td></tr></tbody></table><p>这是两个线程互相失效的情况下出现的问题, 可以看到i++操作做了两次. 主存中的i本应该的2的, 但是因为t1在存储之前,t2已经做了i++操作导致t2的结果被失效,因此结果也就比预期的2少.</p><h4 id="volatile有序性原理"><a href="#volatile有序性原理" class="headerlink" title="volatile有序性原理"></a>volatile有序性原理</h4><p>先看问题:</p><pre><code>public class VolatileSerialTest {    private static int x = 0, y = 0;    public static void main(String[] args) throws InterruptedException {        Set&lt;String&gt; resultSet = new HashSet&lt;&gt;();        Map&lt;String, Integer&gt; resultMap = new HashMap&lt;&gt;();        for (int i = 0; i &lt; 10000000; i++) {            x = 0;            y = 0;            resultMap.clear();            Thread t1 = new Thread(new Runnable() {                @Override                public void run() {                    int a = y;                    x = 1;                    resultMap.put(&quot;a&quot;, a);                }            });            Thread t2 = new Thread(new Runnable() {                @Override                public void run() {                    int b = x;                    y = 1;                    resultMap.put(&quot;b&quot;, b);                }            });            t1.start();            t2.start();            t1.join();            t2.join();            resultSet.add(&quot;[a=&quot; + resultMap.get(&quot;a&quot;) + &quot;, b=&quot; + resultMap.get(&quot;b&quot;) + &quot;]&quot;);        }        System.out.println(resultSet);    }}</code></pre><p>最后输出结果应该会是什么呢?<br>期初我认为 [a=1,b=0] [a=0,b=1] [a=0,b=0]都是可能会出现的.<br>那么运行结果:</p><pre><code>[[a=1, b=0], [a=1, b=1], [a=0, b=0], [a=0, b=1]]</code></pre><p>可以看到中间出现了[a=1, b=1]. 这是我们预料之外的输出,为什么会有这个输出呢? 按照执行顺序,想要<code>a=1</code>就必须先执行<code>y = 1;</code>再之前的<code>int b = x;</code>也应该已经被执行了,同时执行<code>int a = y;</code>时<code>x = 1;</code>还没开始,也就是怎么看都不会出现[a=1, b=1]结果.</p><p>CPU编译过程中会对程序进行<code>重排序</code>,在执行过程中可能会出现下面这种执行顺序 :</p><pre><code>x = 1;y = 1;int a = y;int b = x;</code></pre><p>如果想要杜绝这种方法出现, 就在x,y之前加上volatile修饰.<br>volatile会给语句加上lock这种内存屏障的语义.cpu在执行具有内存屏障的语义时不会进行重排序.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jmm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String.contains()的实现</title>
      <link href="/2019/12/11/2019-12-11/"/>
      <url>/2019/12/11/2019-12-11/</url>
      
        <content type="html"><![CDATA[<p>前段时间有一个需求是, 有一个二进制文件, 在二进制文件中有一段是一张png图片. 现在已经有png文件二进制文件头和文件尾, 需要做的是在读取的byte[]数组中查找到这个文件头和文件尾的位置,并截出这段数组.</p><p>思前想后也想不到什么好的方法,因为文件可能会过大,byte数组是分批读入进来,没法直接全文去搜索, 况且数组过大的情况下这种搜索也太耗时间.</p><p>想到了String类底层也是个char数组, 有个方法是contains(), 可以接收另一个String类型的数据进行比较.<br>这就是两个char数组进行比较查找位置啊, 可能不是很符合我的需求,但是最近没什么事也就去看看他的源码吧.</p><pre><code>// contains内部使用indexOf实现的public boolean contains(CharSequence s) {    return indexOf(s.toString()) &gt; -1;}// 只把主要的indexOf贴上来public int indexOf(char[] source, int sourceOffset, int sourceCount,                    char[] target, int targetOffset, int targetCount,                    int fromIndex) {    // 做一些判错处理    if (fromIndex &gt;= sourceCount) {        return (targetCount == 0 ? sourceCount : -1);    }    if (fromIndex &lt; 0) {        fromIndex = 0;    }    // 如果被contains的字符串是空串,    if (targetCount == 0) {        return fromIndex;    }    // 获取target中开始匹配的位置, 一般target都是从第一个就开始匹配    char first = target[targetOffset];    // 这里很巧, 比如source长度是5, target长度是3 那么判断只要到index到2就够了,再往后匹配的话target长度就超过source了    int max = sourceOffset + (sourceCount - targetCount);    // 开始匹配, i的初始值是由source中开始位置和from开始的. 默认情况下就是从第一个开始    for (int i = sourceOffset + fromIndex; i &lt;= max; i++) {        /* Look for first character. */        // 获取source中第一个和target中第一个元素匹配的index        if (source[i] != first) {            // 如果不匹配index向后移, 直到找到第一个.            while (++i &lt;= max &amp;&amp; source[i] != first);            // 如果找不到, 因为是++i,所以i&gt;max, 跳过下一句判断直接返回-1        }        /* Found first character, now look at the rest of v2 */        if (i &lt;= max) {            // 因为i代表第一个元素匹配, 上面已经做过判断了. 所以直接从第二个元素开始比            // source中索引            int j = i + 1;            // end为 target结束的位置, -1 是因为j其实是target中第二个元素            int end = j + targetCount - 1;            // 现在有两个指针 j,k 只要依次比较这两个指针所指的元素,相同就指针后移            for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j]                    == target[k]; j++, k++);            // 如果找到了那么指针所指的位置应该和target结束的位置一致            // 如果前一个循环提前跳出的话, 这里是不一致的, 那么应该进行下次循环查找后面的字符串            if (j == end) {                /* Found whole string. */                return i - sourceOffset;            }        }    }    return -1;}</code></pre><p>看完之后比较失望, java中的String.contains()实现也是通过循环去比较的. 只是循环中一些写法比我想的好得多. 也不算全无收获,但至少没有解决我的疑问.</p><hr><p>后来咨询了同事, 他是一次性把这个文件load到内存. 如果我分批load进来,需要解决的一个问题就是: 如果刚好文件头或文件尾从中间被截断了,需要对这种情况做处理.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot(一)</title>
      <link href="/2019/12/10/2019-12-10/"/>
      <url>/2019/12/10/2019-12-10/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringBoot-一"><a href="#SpringBoot-一" class="headerlink" title="SpringBoot(一)"></a>SpringBoot(一)</h3><p>最开始使用spring时,配置bean使用的都是xml格式, 在xml中写<bean>标签,属性也要用ref去指定.<br>后来接触到使用注解进行配置, 只要使用@Bean注解修饰这个方法,在扫包的时候扫到,该方法的返回值就会放到ioc容器中交给spring管理.</bean></p><hr><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>BeanDefinition, 即Bean定义.<br>可以通过@ComponentScan扫描的@Repository,@Service,@Component,@Controller和@Bean形式注入.会被spring识别出来后形成一个个的BeanDefinition, 这些BeanDefinition就是用来描述这个bean的一些属性.<br><code>BeanDefinition就类似于图纸, ioc会凭借图纸将对象new出来.</code></p><h4 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h4><p>BeanFactoryPostProcessor,是用来<code>扩展</code>的.在bean还没有实例化之前,可以用来修改beanDefinition的属性.<br>比如可以修改BeanDefinition的lazyInit属性</p><pre><code>public class DemoApplication {    public static void main(String[] args) {        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(&quot;com.example&quot;);        System.out.println(&quot;---------&quot;);        User user = annotationConfigApplicationContext.getBean(&quot;user&quot;, User.class);        System.out.println(user.getName());    }}@Componentpublic class User {    private String name;    public User (){        System.out.println(&quot;user init&quot;);    }    public User (String name){        this.name = name;        System.out.println(&quot;user init&quot;);    }}</code></pre><p>运行结果是</p><pre><code>user init---------null</code></pre><p>添加BeanFactoryPostProcessor实现类将该bean改成懒加载</p><pre><code>@Componentpublic class UserBeanFactoryPostProcessor implements BeanFactoryPostProcessor {    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {        BeanDefinition userDefinition = configurableListableBeanFactory.getBeanDefinition(&quot;user&quot;);        userDefinition.setLazyInit(true);    }}</code></pre><p>运行输出:</p><pre><code>---------16:11:13.688 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;user&#39;user initnull</code></pre><p>可以看到,分割线打在创建ioc容器之后,获取bean之前.在没有使用BeanFactoryPostProcessor扩展之前,user类的实例在创建ioc容器的时候就已经创建出来了,在使用BeanFactoryPostProcessor扩展之后,当使用到了user这个bean才会去创建.</p><p>同样, BeanFactoryPostProcessor也可以用来修改bean的实现类.</p><pre><code>// 添加两个user的实现类,并将ZhangSan设置为自动扫描public class LiSi extends User {    public LiSi(){        setName(&quot;lisi&quot;);        System.out.println(&quot;lisi init&quot;);    }}// 在BeanFactoryPostProcessor中将user的改为实现类李四@Componentpublic class UserBeanFactoryPostProcessor implements BeanFactoryPostProcessor {    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {        BeanDefinition userDefinition = configurableListableBeanFactory.getBeanDefinition(&quot;user&quot;);        userDefinition.setBeanClassName(LiSi.class.getName());    }}// 在main方法中获取zhangSan对应的bean并输出类名public class DemoApplication {    public static void main(String[] args) {        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(&quot;com.example&quot;);        System.out.println(&quot;---------&quot;);        User user = annotationConfigApplicationContext.getBean(&quot;user&quot;, User.class);        System.out.println(user.getClass().getName());    }}</code></pre><p>输出结果:</p><pre><code>user initlisi init---------com.example.repository.LiSi</code></pre><p>我们知道,在@ComponentScan扫描的bean,会默认调用该类的无参构造器.那么也可以通过BeanFactoryPostProcessor来改变调用的构造器.</p><pre><code>@Componentpublic class UserBeanFactoryPostProcessor implements BeanFactoryPostProcessor {    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {        GenericBeanDefinition userDefinition = (GenericBeanDefinition)configurableListableBeanFactory.getBeanDefinition(&quot;user&quot;);        // 修改User类实例化时调用的构造器, 将&quot;zhangsan&quot;作为构造器参数传入        ConstructorArgumentValues constructorArgumentValues = new ConstructorArgumentValues();        constructorArgumentValues.addIndexedArgumentValue(0, &quot;zhangsan&quot;);        userDefinition.setConstructorArgumentValues(constructorArgumentValues);    }}// 添加User类含参构造器@Data@Componentpublic class User {    private String name;    public User (){        System.out.println(&quot;user init&quot;);    }    public User(String name){        this.name = name;        System.out.println(&quot;user init with args&quot;);    }}</code></pre><p>输出结果:</p><pre><code>user init with args---------com.example.repository.Userzhangsan</code></pre><h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><ul><li>直接导入一个类</li></ul><pre><code>public class DemoApplication {    public static void main(String[] args) {        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MainConfig.class);    }}@ComponentScan(basePackages = {&quot;com.example&quot;})@Import(value = {User.class})public class MainConfig {}</code></pre><p>输出结果 :</p><pre><code>user init</code></pre><p>@Import将User的BeanDefinition导入到BeanDefinitionMap中.</p><ul><li>导入BeanDefinitionRegister</li></ul><pre><code>@ComponentScan(basePackages = {&quot;com.example&quot;})//@Import(value = {User.class})@Import(value = {MainImportBeanDefinitionRegister.class})public class MainConfig {}public class MainImportBeanDefinitionRegister implements ImportBeanDefinitionRegistrar {    @Override    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(User.class);        registry.registerBeanDefinition(&quot;user&quot;, rootBeanDefinition);    }}</code></pre><p>输出结果 : </p><pre><code>user init</code></pre><ul><li>通过ImportSelector导入</li></ul><blockquote><p><code>*</code>这种方法可以批量加载.(自动装配原理的核心)</p></blockquote><pre><code>public class MainImportSelector implements ImportSelector {    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) {        // 会返回一个数组, 数组的内容是类的全类名        return new String[]{&quot;com.example.repository.User&quot;};    }}</code></pre><p>输出结果 : </p><pre><code>user init</code></pre><p>搜索ImportSelector,在org.springframework.boot.autoconfigure.cache包下有一个CacheAutoConfiguration类中, 静态内部类实现了这个接口CacheConfigurationImportSelector.</p><pre><code>static class CacheConfigurationImportSelector implements ImportSelector {    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) {        CacheType[] types = CacheType.values();        String[] imports = new String[types.length];        for (int i = 0; i &lt; types.length; i++) {            imports[i] = CacheConfigurations.getConfigurationClass(types[i]);        }        return imports;    }}</code></pre><p>缓存了CacheType这个枚举,会根据<code>CacheConfigurations.getConfigurationClass(types[i]);</code>依次去取缓存类的全类名.<br><img src="/2019/12/10/2019-12-10/CacheConfigurationImportSelector.jpg" alt="CacheConfigurationImportSelector.class"></p><p><img src="/2019/12/10/2019-12-10/getConfigurationClass.jpg" alt="CacheConfigurations中缓存的mapping"></p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm的运行机制(二) 栈详解</title>
      <link href="/2019/12/06/2019-12-6/"/>
      <url>/2019/12/06/2019-12-6/</url>
      
        <content type="html"><![CDATA[<p>栈<br>实际叫<code>线程栈</code><br>当main线程开始时,jvm就在jvm的内存区中,分配一块内存.存放主线程运行时的局部变量.</p><p>看一段代码 : </p><pre><code>public class Main {    public static void main(String[] args) {        Main main = new Main();        main.calculate();    }    public int calculate(){        int a = 2;        int b = 4;        int c = (a + b) * 10;        return c;    }}</code></pre><p>当main线程开始时,jvm就在jvm的内存区中,分配一块内存.存放主线程运行时的局部变量.<br>在main()方法开始时,有一块main()方法对应的栈帧进入main线程中.<br><img src="/2019/12/06/2019-12-6/mainStackFrame.jpg" alt="mian方法开始时,对应的栈帧进入线程"></p><pre><code>Main main = new Main();</code></pre><p>之后,在main栈帧的局部变量表中,出现了一个对象指向堆.<br>在main()方法进入compute()方法时, 栈中压入calculate()方法的栈帧.开始执行calculate()方法的代码.<br><img src="/2019/12/06/2019-12-6/calculateStackFrame.jpg" alt="calculate()方法开始时"></p><hr><p>在java中有个工具可以将.class文件反编译<code>javap</code><br><img src="/2019/12/06/2019-12-6/javap.jpg" alt="javap"><br>一般使用<code>-c</code>.<br><img src="/2019/12/06/2019-12-6/javapMain.jpg" alt="对Main.class进行反编译"></p><p>接下来主要对calculate()进行解析<br><img src="/2019/12/06/2019-12-6/calculate.gif" alt="calculate()方法执行过程"></p><hr><p>栈帧中主要组成部分:</p><ul><li>局部变量表<br>局部变量表主要存储该方法内使用的局部变量</li><li>操作数栈<br>操作数栈存放用于计算的数据.</li><li>动态链接<br>动态链接的作用目前不是很明确,通过最后两个字<code>链接</code>可以知道大概是个找什么东西的.后续会继续查询和学习动态链接的作用.</li><li>方法出口<br>方法执行完,返回的位置.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2019/12/03/2019-12-3/"/>
      <url>/2019/12/03/2019-12-3/</url>
      
        <content type="html"><![CDATA[<p>索引是帮助mysql高效获取数据的排好序的数据结构</p><h3 id="使用索引的几种数据结构"><a href="#使用索引的几种数据结构" class="headerlink" title="使用索引的几种数据结构"></a>使用索引的几种数据结构</h3><ul><li>二叉树</li><li>红黑树</li><li>B树</li><li>B+树</li></ul><p><code>*</code> 首先记录一个数据结构可视化的网站.<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">Data Structure Visualizations</a></p><h4 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1) 二叉树"></a>1) 二叉树</h4><p>使用二叉树，对索引字段进行排序. 查找的时候每次过滤一半, 效率比遍历的去查找自然是快的多.<br><img src="/2019/12/03/2019-12-3/binarySearch.gif" alt="折半查找"></p><p>但使用二叉树做索引时, 当索引数据依次递增时, 结果和直接轮询数据是一样的.<br><img src="/2019/12/03/2019-12-3/binaryAscSearch.gif" alt="索引数据递增时查找"></p><h4 id="2-红黑树"><a href="#2-红黑树" class="headerlink" title="2) 红黑树"></a>2) 红黑树</h4><p>使用红黑树,使二叉树变得平衡.<br><img src="/2019/12/03/2019-12-3/redBlack.gif" alt="红黑树"><br>但此时存在的问题是, 红黑树毕竟还是二叉树, 当数据库中数据太多时, 树的层级也会过深. 如果要查询叶子节点会经过非常多次查询.比如 100万条数据, 最坏情况要经过20次的查询才能找到索引位置.</p><h4 id="3-B树"><a href="#3-B树" class="headerlink" title="3) B树"></a>3) B树</h4><p>B树, 在每个节点横向扩展. 每个节点均为以他为根节点的新的树,形成多叉的树.<br><img src="/2019/12/03/2019-12-3/bTree.gif" alt="B树"></p><h4 id="4-B-树"><a href="#4-B-树" class="headerlink" title="4) B+树"></a>4) B+树</h4><p>B+树, 在B树基础上, </p><ul><li>非叶子节点不存储data, 只存储索引(冗余),可以放更多的索引</li><li>叶子节点包含所有索引字段</li><li>叶子节点用指针连接,提高区间访问的性能<br><img src="/2019/12/03/2019-12-3/bPlusTree.gif" alt="B+树"></li></ul><blockquote><p>可以看到,B+树比B树的元素多,那么为什么会更高级呢?不应该存储的东西越少效率越高吗?<br>原因在于,B树中存放的元素,到了B+树中便只存了索引元素. 所有索引以外的数据都存在叶子节点中.<br>这样的好处在于,MySQL对每个节点的大小是有限制的.<br>可以使用 <code>SHOW GLOBAL STATUS LIKE &#39;Innodb_page_size&#39;;</code>查询每个节点的大小.<br><img src="/2019/12/03/2019-12-3/innodbPageSize.png" alt="innodb page size"><br>可以看到每个节点只有16kb的大小存放数据, 因此只要每个节点元素小一些,便可以存放更多数据.<br>因此看起来是多了冗余数据占据不必要的额外空间,但是实际上MySQL可以一个页节点一个页节点的分别加载到内存中去查找,而找到索引元素后再通过索引对应的文件磁盘地址或值取出想要的那条记录.</p></blockquote><h3 id="MySQL中的两种引擎"><a href="#MySQL中的两种引擎" class="headerlink" title="MySQL中的两种引擎"></a>MySQL中的两种引擎</h3><h4 id="1-MyISAM引擎"><a href="#1-MyISAM引擎" class="headerlink" title="1) MyISAM引擎"></a>1) MyISAM引擎</h4><p>MyISAM引擎, 在B+树中,查询到索引对应节点, 节点对应的vaue就是索引所在那一行磁盘文件地址指针<br>MyISAM索引文件和数据文件是分离的(非聚集)<br><img src="/2019/12/03/2019-12-3/myisamBPlusTree.png" alt="MyISAM结构示意"></p><h4 id="2-InnoDB引擎"><a href="#2-InnoDB引擎" class="headerlink" title="2) InnoDB引擎"></a>2) InnoDB引擎</h4><p>表数据文件本身就是按B+树组织的一个索引结构文件<br>聚集索引-叶节点包含了完整的数据记录<br><img src="/2019/12/03/2019-12-3/innodbBPlusTree.png" alt="innodb结构示意"></p><blockquote><p>为什么InnoDB表必须有主键, 并且推荐使用整形的自增主键?<br>MySQL设计时是按照B+树设计的,即 必须要有主键. 如果没有设置主键, MySQL会从表中找可以建唯一索引的列默认建一个主键. 如果找不到可以建立唯一索引的列,会在表中默认加一列,由MySQL默默维护这个索引. </p></blockquote><blockquote><p>叶子节点之间的指针有什么用?<br>当范围查找的时候, … where id &gt; 200 , 此时直接查询这个页节点后面所有的节点即可.</p></blockquote><blockquote><p>为什么索引推荐自增<br>如果不自增, 当叶子节点这个页满了的时候,又有一个数据需要插入进来.这时要重新计算索引存放的位置<br><img src="/2019/12/03/2019-12-3/bPlusTreeRetrieve.gif" alt="为什么索引推荐自增"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net core 3.0踩坑日记</title>
      <link href="/2019/11/01/2019-11-1/"/>
      <url>/2019/11/01/2019-11-1/</url>
      
        <content type="html"><![CDATA[<p>.net core 3.0 踩坑日记</p><h2 id="三天前，老大要求把一个项目从java改到-net。因为没碰过-net，便开始了磕磕绊绊的踩坑之旅。"><a href="#三天前，老大要求把一个项目从java改到-net。因为没碰过-net，便开始了磕磕绊绊的踩坑之旅。" class="headerlink" title="三天前，老大要求把一个项目从java改到.net。因为没碰过.net，便开始了磕磕绊绊的踩坑之旅。"></a>三天前，老大要求把一个项目从java改到.net。因为没碰过.net，便开始了磕磕绊绊的踩坑之旅。</h2><h3 id="1-https问题。"><a href="#1-https问题。" class="headerlink" title="1. https问题。"></a>1. https问题。</h3><p>在刚开始熟悉.net时，使用vs自动生成了一个webapi的项目，但是问题出现了，使用浏览器可以调用接口，但是postman调用就不会有返回。<br>后来发现vs会默认把<code>为https配置</code>勾选，vs会自己生成一个证书，但是postman不认这个证书。 后来将该配置项取消得以解决。</p><h3 id="2-使用-net-core-3。"><a href="#2-使用-net-core-3。" class="headerlink" title="2. 使用.net core 3。"></a>2. 使用.net core 3。</h3><p> 原先使用vs2017，但是查找的时候，怎么也找不到.net core 3，只有2.1，找了好久发现篇博客<a href="https://www.cnblogs.com/Vulpers/p/10893735.html" target="_blank" rel="noopener">安装.NET Core 3.0预览版后VS项目目标框架中不显示的解决方法</a>。 试过后发现不行，还是找不到。 后来换成vs2019得到解决。</p><h3 id="3-net-core使用DI。"><a href="#3-net-core使用DI。" class="headerlink" title="3. .net core使用DI。"></a>3. .net core使用DI。</h3><p>因为是从java项目转过来的，在java中习惯使用spring的我，第一时间想找到一个.net的依赖注入的库。 在这里先感谢一位b站up主 <code>solenovex</code> ，他的<a href="https://www.bilibili.com/video/av33728783" target="_blank" rel="noopener">ASP.NET Core MVC 入门教程 (共9集)</a>对我帮助很大。其中讲了一些启动时，默认的配置，其中就包括默认的DI。使用起来也很简单，在<code>Startup.cs</code>类的<code>ConfigureServices</code>方法中，将类添加到IOC容器中，使用时在构造方法中声名该类型即可注入。</p><pre><code>// Startup.cspublic void ConfigureServices(IServiceCollection services){    services.AddControllers();    // 将WeatherForecastService添加到IOC容器中    services.AddSingleton&lt;WeatherForecastService&gt;();}// WeatherForecastController.csprivate WeatherForecastService _weatherForecastService;public WeatherForecastController(WeatherForecastService weatherForecastService){    // 在构造函数中直接注入    _weatherForecastService = weatherForecastService;}</code></pre><h3 id="4-分环境生效的配置文件"><a href="#4-分环境生效的配置文件" class="headerlink" title="4. 分环境生效的配置文件"></a>4. 分环境生效的配置文件</h3><p>在Properties下的<code>launchSettings.json</code>中，有个叫<code>ASPNETCORE_ENVIRONMENT</code>的参数，这个参数控制生效的配置文件。<br>在项目启动时，默认会加载<code>appsetting.json</code>和<code>appsetting.{env}.json</code>，结果取两个json合并后的结果，如果有key值相同，appsetting.{env}.json会覆盖appsetting.json。</p><h3 id="5-获取配置文件"><a href="#5-获取配置文件" class="headerlink" title="5. 获取配置文件"></a>5. 获取配置文件</h3><p>获取appsetting.json中的配置信息，将想要的格式建好一个类之后，在<code>Startup.cs</code>中将该配置注册一下就可以在想要使用时将该配置注入进来。</p><pre><code>// appsetting中的配置信息/*{  &quot;Build&quot;: {    &quot;Number&quot;:  1,    &quot;Env&quot;:  &quot;Local&quot;  }}*/// Startup.cs 中将想要注册的配置放进services中，并指明类型public void ConfigureServices(IServiceCollection services){    services.Configure&lt;Build&gt;(Configuration.GetSection(&quot;Build&quot;));}// WeatherForecastController.cs中在构造器中直接注入private IOptions&lt;Build&gt; _buildConf;public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger,     WeatherForecastService weatherForecastService,     IOptions&lt;Build&gt; buildConf){    _logger = logger;    this.weatherForecastService = weatherForecastService;    _buildConf = buildConf;}[HttpGet]public IEnumerable&lt;WeatherForecast&gt; Get(){    // 想要使用时，直接可以获取到一个强类型的对象，从中取配置即可    Build buildConf = _buildConf.Value;    string env = buildConf.Env;    int number = buildConf.Number;    Console.WriteLine(&quot;env : &quot; + env + &quot; buildNum : &quot; + number);    return weatherForecastService.GetForecasts();}// 输出结果：// env : Local buildNum : 1</code></pre><p><del>这种获取配置的方法要求必须有个实体类和配置文件对应，过于繁琐。 后续会寻找更方便的方法获取配置。</del></p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .net core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在spring整个服务启动后做一些事</title>
      <link href="/2019/10/23/2019-10-23/"/>
      <url>/2019/10/23/2019-10-23/</url>
      
        <content type="html"><![CDATA[<hr><p>起因: 因为服务器启动时，保存的数据和node层保存的数据不一致。虽然有定时同步的功能，但是启动后到第一次同步之间有段真空期，所有这个问题最后评估下来是要修复的。</p><h2 id="经过思考后，决定服务器启动时，向redis里推送一条消息提示前端要同步数据。因此使用了以前用过的-PostConstruct试图解决这个问题。"><a href="#经过思考后，决定服务器启动时，向redis里推送一条消息提示前端要同步数据。因此使用了以前用过的-PostConstruct试图解决这个问题。" class="headerlink" title="经过思考后，决定服务器启动时，向redis里推送一条消息提示前端要同步数据。因此使用了以前用过的@PostConstruct试图解决这个问题。"></a>经过思考后，决定服务器启动时，向redis里推送一条消息提示前端要同步数据。因此使用了以前用过的@PostConstruct试图解决这个问题。</h2><p>代码如下:</p><pre><code>@Configurationpublic class TransferSecretKeySyncConfig {    private static final String CHANNEL = &quot;iot_restart&quot;;    private static final String RESTART_MESSAGE = &quot;{\&quot;type\&quot;:\&quot;restart\&quot;}&quot;;    @Autowired    private RedisAgent redisAgent;    @PostConstruct    public void syncTransferSecretLKey(){        redisAgent.publish(CHANNEL, RESTART_MESSAGE);    }}</code></pre><p>但是和前端一起测试时发现问题: 服务器启动时发送的消息没有生效， 后来去查看log发现，前端确实发送了请求，但是请求结果返回是502。<br>后枉然大悟，使用@PostConstract往redis里发送消息时，服务器还没完全启动，这时调用接口返回502也是意料之中的事。 因此便去寻找在服务器完全启动后做一些事的方法。</p><p>修改后</p><pre><code>@Component@Slf4jpublic class TransferSecretKeySyncConfig implements CommandLineRunner {    private static final String CHANNEL = &quot;iot_restart&quot;;    private static final String RESTART_MESSAGE = &quot;{\&quot;type\&quot;:\&quot;restart\&quot;}&quot;;    @Autowired    private RedisAgent redisAgent;    @Override    public void run(String... args) throws Exception {        log.info(&quot;send sync transfer secret key to redis...&quot;);        redisAgent.publish(CHANNEL, RESTART_MESSAGE);    }}</code></pre><p>得以解决</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>drools使用过程中遇到的坑 (零)</title>
      <link href="/2019/09/22/2019-9-22/"/>
      <url>/2019/09/22/2019-9-22/</url>
      
        <content type="html"><![CDATA[<p>最近公司的开发任务是<code>规则引擎</code>这个东西。 大概想要做成的东西是这个亚子。<br><img src="/2019/09/22/2019-9-22/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="规则引擎示意"></p><p>于是领导调查了一下，让我去看drools这个框架。<br>具体drools怎么用网上很多博客都有讲，我会把参考到的几个写的比较清楚的帖子贴在下面。</p><h3 id="初识drools"><a href="#初识drools" class="headerlink" title="初识drools"></a>初识drools</h3><p>第一次去看的时候，仅仅只是跟着demo走了一下，跟着写了一下drl，发现这个框架需要用到他自己的语法。一时间很难接受，于是草率的得出结论： 想要使用这个规则引擎，必须事先写好drl文件，而这个文件又很难生成。 因此这个框架不实用。</p><h3 id="再遇drools"><a href="#再遇drools" class="headerlink" title="再遇drools"></a>再遇drools</h3><p>第二次去看的时候，深入理解了一下drl语法，也自己试着实现了一些自己的规则，期间踩了很多坑。像 遍历List、 when…then…有没有else啊 这些问题。在这里简单记录一下，等到上班去公司看着代码回忆一下有哪些问题是怎么解决的。</p><h3 id="和drools的爱恨纠缠"><a href="#和drools的爱恨纠缠" class="headerlink" title="和drools的爱恨纠缠"></a>和drools的爱恨纠缠</h3><p>在上面完成之后，我做出一个很怪的规则出来， 因为命题的链接都是<code>or</code>因此我认为，只要有一个为<code>true</code>整个命题就是ture，所以我使用了loop来轮询的判断每个命题，如果发现了一个true，就将结果置为true，并结束循环。<br>但是这种操作导致了只能做全<code>or</code>或者全<code>and</code>的命题连接， 如果出现and和or混用的情况，这是没法做的。<br>而且在执行的过程中发现了一个致命bug：每当规则执行到第22次的时候，都会报一个严重的错误。以前从来都没见过，而且去问领导，领导也说没见过。产生原因我并不清楚，但是我是将一个判断去除了以后解决的这个问题。所以我猜测可能是条件没写好导致无限循环，使得drools这个框架处理不过来导致的错误。</p><h3 id="心满意足的接受drools的服务"><a href="#心满意足的接受drools的服务" class="headerlink" title="心满意足的接受drools的服务"></a>心满意足的接受drools的服务</h3><p>再往后，想要支持and和or混用的这种情况，甚至想要支持带括号，有先后优先级的这种情况。我想了好多办法，都不可能做到动态的去判断。 最后只能使用拼接字符串的方法，将条件和逻辑运算符直接写在drl文件里。 将这条规则动态的加入到规则引擎中。</p><hr><p>参考文章：<br><a href="https://blog.csdn.net/mn960mn/article/details/47778423" target="_blank" rel="noopener">drools6入门例子(二)</a><br><a href="https://blog.csdn.net/u010952582/article/details/91986942" target="_blank" rel="noopener">Drools 7 遍历List集合</a><br><a href="https://zhengkai.blog.csdn.net/article/details/98061651" target="_blank" rel="noopener">springboot2整合drools规则引擎（kie-spring+drools-core）</a><br><a href="https://github.com/ityouknow/drools-examples" target="_blank" rel="noopener">drools集成spring boot</a><br><a href="https://www.jianshu.com/p/371d4a2a5866" target="_blank" rel="noopener">drools 如何动态加载规则</a></p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> drools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm的运行机制(一) java虚拟机示意图</title>
      <link href="/2019/09/20/2019-9-20/"/>
      <url>/2019/09/20/2019-9-20/</url>
      
        <content type="html"><![CDATA[<p>今天去看了一下jvm的机制， 在B站上看一个叫<code>程序员诸葛</code>讲的<a href="https://www.bilibili.com/video/av62480910/?p=1" target="_blank" rel="noopener">8月最新java虚拟机JVM运行机制讲解视频全集</a><br>目前学到第6p， 会一点一点的将老师讲的课， 和在听课过程中记得笔记分享上来。 这篇博客的内容主要是jvm的结构，将画出示意图。</p><p>假设目前代码是这个亚子。 </p><pre><code>public class Main {    public static void main(String[] args) {        Main main = new Main();        main.calculate();    }    public int calculate(){        int a = 2;        int b = 4;        int c = (2 + 4) * 5;        return c;    }}</code></pre><p><img src="/2019/09/20/2019-9-20/jvm%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="jvm模型"><br>众所周知， java执行时，并非直接运行.java文件。 而是先翻译成.class文件，再将.class加入到jvm中执行。<br>jvm分为哪几块呢， 并非仅仅是我们常说的堆、栈这些。 而是分为类装载子系统， 运行时数据区， 执行引擎三个部分。<br>如图，在执行一个Math.class时， 先由类加载子系统将该文件加载到jvm的运行时数据区(后称内存区)中的方法区中。完成装载后，再由字节码装载引擎执行代码。</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 内存分析</title>
      <link href="/2019/09/16/2019-9-16/"/>
      <url>/2019/09/16/2019-9-16/</url>
      
        <content type="html"><![CDATA[<p>java 内存分析</p><hr><p>2019年9月20日18:55:50 更新<br>今天主要去看了一下jvm解析,感觉这篇博客写的很片面,很多东西都说对不对说错不错.<br>也不进行删除了,留待给自己一个警醒. 后续我会先把jvm解析的课程看完,一部分一部分的将jvm的部分写出来.</p><hr><p>最近感觉java基础知识不是很牢固,所以又返回去着重看了一些java的基础知识.<br>目标主要是两个: </p><ol><li>搞懂java中的内存是怎么分配的 </li><li>搞清楚API的实现,如 String/数组/Map等API的实现.</li></ol><p>这篇是关于java中的内存分析</p><h2 id="1-运行时内存划分大致区块"><a href="#1-运行时内存划分大致区块" class="headerlink" title="1. 运行时内存划分大致区块:"></a>1. 运行时内存划分大致区块:</h2><blockquote><p>根据《Java虚拟机规范》的规定，运行时数据区通常包括这几个部分：程序计数器(Program Counter Register)、Java栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)。<br>实际关注主要集中在栈区和堆区</p></blockquote><p><img src="/2019/09/16/2019-9-16/%E5%86%85%E5%AD%98%E5%8C%BA%E5%88%92%E5%88%86.png" alt="内存区划分"></p><h2 id="2-各种类型内存分析"><a href="#2-各种类型内存分析" class="headerlink" title="2. 各种类型内存分析"></a>2. 各种类型内存分析</h2><h3 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1. 基本数据类型"></a>2.1. 基本数据类型</h3><p>基本数据类型直接存放在栈区,栈中存放的值就等于基本数据类型的值,如 </p><pre><code>char a1 = &#39;a&#39;;byte a2 = 1;short a3 = 1;int a4 = 1;long a5 = 1L;float a6 = 0.1f;double a7 = 0.1;boolean a8 = true;</code></pre><p><img src="/2019/09/16/2019-9-16/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98.png" alt="基本数据类型内存"></p><h3 id="2-2-引用类型"><a href="#2-2-引用类型" class="headerlink" title="2.2. 引用类型"></a>2.2. 引用类型</h3><p>引用类型分两部分,一部分是引用,一部分是对象.<br>引用部分存放在栈区,值为对象的内存地址.(实际不是,只是根据这个值可以找到对象)<br>对象实际存在堆区.<br>如, Person person = new Person();<br>在栈区存在一小块内存,存放的是该对象在堆区中的地址.</p><p><img src="/2019/09/16/2019-9-16/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98.png" alt="引用类型内存"></p><h3 id="2-3-String"><a href="#2-3-String" class="headerlink" title="2.3. String"></a>2.3. String</h3><p>String比较特殊,String有两种方式实例化</p><pre><code>String s1 = &quot;hello world&quot;;String s2 = new String(&quot;hello world&quot;);</code></pre><p>这两种实例化方式对应不同的内存分配情况.<br>① 通过字符串常量的方法实例化一个字符串对象: 字符串引用会直接指向字符串常量池.<br>② 通过new的方式实例化一个字符串对象: 字符串引用会先指向堆中的string对象,由对象指向字符串常量池.<br>因此s1直接指向方法区的字符串常量池,而s2指向堆区.两种方法指向的都是同一个字符串.<br>关于String的内存分配情况下面还会细讲.</p><p><img src="/2019/09/16/2019-9-16/String%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98.png" alt="String类型内存"></p><h3 id="2-4-数组"><a href="#2-4-数组" class="headerlink" title="2.4. 数组"></a>2.4. 数组</h3><p>数组类型也是一个引用,指向内存中连续的一片空间.</p><pre><code>int[] arr1;int[] arr2 = new int[5];</code></pre><p><img src="/2019/09/16/2019-9-16/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%86%85%E5%AD%98.png" alt="数组类内存"></p><h2 id="3-一些具体情况"><a href="#3-一些具体情况" class="headerlink" title="3. 一些具体情况"></a>3. 一些具体情况</h2><pre><code>@Testpublic void test01(){    String string = &quot;hello&quot;;    System.out.println(string);// hello    change(string);    System.out.println(string);// hello}public String change(String string){    string = &quot;world&quot;;    return string;}</code></pre><p>初始化一个String,赋值为”hello”,将string传入一个方法里,在这个方法里对string重新赋值,最后输出结果没有改变.<br>原因是,在对象传值到另一个方法中时,传入的并非引用本身,而是引用存的地址值.<br>test01.string传入到change()中后,栈区中出现了一个新的引用姑且叫他change.string, change.string也指向”<code>hello</code>“.在change方法中对change.string重新赋值,使change.string指向”<code>world</code>“,test01.string并没有改变指向.<br><img src="/2019/09/16/2019-9-16/%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E9%87%8D%E6%96%B0%E7%BB%99string%E8%B5%8B%E5%80%BC.png" alt="在方法中重新给string赋值"></p><hr><p>String类中重写了equals()方法,只要两个字符串值相等equals()就返回true. 而<code>==</code>操作符比较的是两个对象的内存地址.</p><pre><code>@Testpublic void test02(){    String s1 = &quot;hello&quot;;    String s2 = &quot;hello&quot;;    System.out.println(s1 == s2); // true    System.out.println(s1.equals(s2)); // true}</code></pre><p>因为两个字符串对象都是通过字符串常量的方式实例化出来的,他们均指向字符串常量池.因此下面两个输出都是true</p><p><img src="/2019/09/16/2019-9-16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="字符串常量的比较"></p><pre><code>@Testpublic void test03(){    String s1 = new String(&quot;hello&quot;);    String s2 = new String(&quot;hello&quot;);    System.out.println(s1 == s2); // false    System.out.println(s1.equals(s2)); // true}</code></pre><p>因为两个字符串都是通过new的方式实例化出来的,因此两个字符串分别指向堆中的两个对象,两个对象均指向字符串常量池.<br>因此比较两个字符串时,比较的是两个堆中的对象的地址值. 因为是两个不同的对象,所以使用<code>==</code>比较结果是false.<br><img src="/2019/09/16/2019-9-16/new%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="new创建字符串的比较"></p><hr><pre><code>@Testpublic void test04(){    String s1 = &quot;hello&quot;;    String s2 = &quot;world&quot;;    String s3 = &quot;helloworld&quot;;    String s4 = &quot;hello&quot; + &quot;world&quot;;    String s5 = s1 + &quot;world&quot;;    System.out.println(s3 == s4); // true    System.out.println(s3 == s5); // false}</code></pre><p>为什么这次输出不一样? 明明”hello” + “world”拼接起来和原字符串相等, 为什么s1拼接后的字符串就不相等了呢?s1不也是指向字符串常量池吗?<br>字符串的拼接如果只有常量参与,那么拼接后的结果还是指向常量池.<br>一旦有变量参与字符串的拼接,那拼接后的结果就会指向堆区,由堆区指向常量池.<br><img src="/2019/09/16/2019-9-16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5.png" alt="字符串拼接"></p><hr><p>在最后抛出一个疑问. 数组是引用类型,字符串也是引用类型, 为什么int[].length而string.length().</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在spring中获取applicationContext.</title>
      <link href="/2019/08/17/2019-8-17/"/>
      <url>/2019/08/17/2019-8-17/</url>
      
        <content type="html"><![CDATA[<p>以前想要获取applicationContext, 在网上搜索后也很麻烦,不好用.<br>今天在看spring文档时, 发现文档上写了一种很简单的获取方法(Spring Framework Version: 4.3.21.RELEASE): </p><blockquote><p>您还可以将 @Autowired 用于众所周知的可解析依赖项的接口： BeanFactory ， ApplicationContext ， Environment ， ResourceLoader ， ApplicationEventPublisher 和 MessageSource 。这些接口及其扩展接口（如 ConfigurableApplicationContext 或 ResourcePatternResolver ）将自动解析，无需特殊设置。</p></blockquote><pre><code>public class MovieRecommender {    @Autowired    private ApplicationContext context;    public MovieRecommender() {    }    // ...}</code></pre><p>下面还有一行小注释:</p><blockquote><p>@ Autowired，@ Inject，@ Resource和@Value注释由Spring BeanPostProcessor实现处理，这反过来意味着您不能在自己的BeanPostProcessor或BeanFactoryPostProcessor类型（如果有）中应用这些注释。必须通过XML或使用Spring @Bean方法显式地“连接”这些类型。</p></blockquote><p>不能自动装配<code>BeanPostProcessor</code>和<code>BeanFactoryPostProcessor</code>类型, 不过问题不大, 反正我也不认识这两个类型.(逃</p><hr><p>直接@Autowired就可以获取到了, 以前只知道ApplicationContext是IOC容器, 现在知道其竟然可以被自动装配. 这种方法确实要简单很多, 也好记很多.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用@PostConstruct修饰的方法执行顺序</title>
      <link href="/2019/08/12/2019-8-12-2/"/>
      <url>/2019/08/12/2019-8-12-2/</url>
      
        <content type="html"><![CDATA[<p>看到JSR-250,搜了一下.<a href="http://wiki.jikexueyuan.com/project/spring/annotation-based-configuration/spring-jsr250-annotation.html" target="_blank" rel="noopener">Spring JSR-250 注释</a><br>包含三个注释<code>@PostConstruct</code>, <code>@PreDestroy</code>和 <code>@Resource</code>.  先不看@Resource, 单看前两个.<br>在使用过程中,曾有过疑问, <code>@PostConstruct</code>在什么时候会执行.<br>java本身的顺序 静态代码块 -&gt; 非静态代码块 -&gt; 构造方法 .<br>那么加了一个<code>@PostConstruct</code>之后,这个注解修饰的方法会处在什么顺序执行呢.<br>从网上摘下来一个例子: </p><ol><li><p>有这么一个类, 包含静态代码块, 非静态代码块, 构造方法, <code>@PostConstruct</code>修饰的方法, <code>@PreDestroy</code>修饰的方法  </p><pre><code>public class Hello { private String message ; public String getMessage() {     System.out.println(&quot;message : &quot; + message);     return message; } public void setMessage(String message) {     this.message = message; } static {     System.out.println(&quot;static block&quot;); } {     System.out.println(&quot;block&quot;); } public Hello(){     System.out.println(&quot;construction&quot;); } @PostConstruct public void init(){     System.out.println(&quot;PostConstruct&quot;); } @PreDestroy public void destroy(){     System.out.println(&quot;PreDestroy&quot;); }}</code></pre></li><li><p>将这个bean加入到spring ioc容器中.</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></pre></li></ol><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemalocation="http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context-3.0.xsd"></beans></p><pre><code>&lt;context:annotation-config/&gt;&lt;bean id=&quot;hello&quot; class=&quot;com.example.jsr250.Hello&quot;&gt;    &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;&lt;/bean&gt;</code></pre>~~~<ol start="3"><li><p>在main方法中获取这个bean</p><pre><code>public class MainApp { public static void main(String[] args) {     AbstractApplicationContext abstractContext = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);     Hello obj = (Hello) abstractContext.getBean(&quot;hello&quot;);     obj.getMessage();     abstractContext.registerShutdownHook(); }}</code></pre></li><li><p>输出如下:</p><blockquote><p>static block<br>block<br>construction<br>PostConstruct<br>message : Hello World!<br>PreDestroy</p></blockquote></li></ol><hr><p>可以看出, <code>@PostConstruct</code>修饰的方法是在构造函数执行完之后运行的.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初见cglib</title>
      <link href="/2019/08/12/2019-8-12-1/"/>
      <url>/2019/08/12/2019-8-12-1/</url>
      
        <content type="html"><![CDATA[<p>今天在看spring文档的时候看到了cglib代理. 出于好奇,就去搜索了一下.<br><a href="https://www.jianshu.com/p/9a61af393e41?isappinstalled=0" target="_blank" rel="noopener">深入理解CGLIB动态代理机制</a><br>并没有很深入的去了解这个代理机制,只是简单的看了一下怎么用. 毕竟现在主要还是学习spring文档.  </p><p>之前也看过java中的动态代理, 感觉有点复杂. 需要被代理类实现一个预定好的接口.<br>虽然很容易理解,但是毕竟多出一个接口需要定义, 阅读起来也不是那么方便.<br>先贴一下cglib中的代码:</p><ol><li><p>引入cglib</p><pre><code>&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>定义被代理类:</p><pre><code>public class HelloServiceImpl { public void sayHello(){     System.out.println(&quot;Hello cglib&quot;); }}</code></pre></li><li><p>定义代理类:</p><pre><code>public class HelloMethodInterceptor implements MethodInterceptor { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {     System.out.println(&quot;Before : &quot; + method.getName());     Object object = methodProxy.invokeSuper(o, objects);     System.out.println(&quot;After : &quot; + method.getName());     return object; }}</code></pre></li><li><p>生成对象并调用方法: </p><pre><code>public class Client { public static void main(String[] args) {     Enhancer enhancer = new Enhancer();     enhancer.setSuperclass(HelloServiceImpl.class);     enhancer.setCallback(new HelloMethodInterceptor());     HelloServiceImpl helloServiceImpl = (HelloServiceImpl) enhancer.create();     helloServiceImpl.sayHello(); }}</code></pre></li><li><p>输出:</p><blockquote><p>Before : sayHello<br>Hello cglib<br>After : sayHello</p></blockquote></li></ol><hr><p>并没有很深入的了解,只是简单的跟着敲了一下demo. 等到实际用的时候再来补充体验吧.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unable to store Job:&#39;todoJobGroup.1183894449946624&#39;, because one already exists with this identification.</title>
      <link href="/2019/08/02/2019-8-2/"/>
      <url>/2019/08/02/2019-8-2/</url>
      
        <content type="html"><![CDATA[<p>在今天迭代上线后,测试突然发现了一个bug.去pro环境看了一下log</p><pre><code>2019-08-02 17:52:40.756 ERROR 18408 --- [nio-8084-exec-2] c.g.common.eventbus.EventBus.default     : Exception thrown by subscriber method onEvent(com.decobim.todo.job.InAddTriggerEvent) on subscriber com.decobim.ops.quartz.QuartzEvent@6e9ea96d when dispatching event: InAddTriggerEvent(todoItemId=1183894449946624, reminderTime=1564743006000)org.quartz.ObjectAlreadyExistsException: Unable to store Job : &#39;todoJobGroup.1183894449946624&#39;, because one already exists with this identification.    at org.quartz.impl.jdbcjobstore.JobStoreSupport.storeJob(JobStoreSupport.java:1113) ~[quartz-2.3.0.jar:na]    at org.quartz.impl.jdbcjobstore.JobStoreSupport$2.executeVoid(JobStoreSupport.java:1067) ~[quartz-2.3.0.jar:na]    at org.quartz.impl.jdbcjobstore.JobStoreSupport$VoidTransactionCallback.execute(JobStoreSupport.java:3765) ~[quartz-2.3.0.jar:na]    at org.quartz.impl.jdbcjobstore.JobStoreSupport$VoidTransactionCallback.execute(JobStoreSupport.java:3763) ~[quartz-2.3.0.jar:na]    at org.quartz.impl.jdbcjobstore.JobStoreCMT.executeInLock(JobStoreCMT.java:245) ~[quartz-2.3.0.jar:na]    at org.quartz.impl.jdbcjobstore.JobStoreSupport.storeJobAndTrigger(JobStoreSupport.java:1063) ~[quartz-2.3.0.jar:na]    at org.quartz.core.QuartzScheduler.scheduleJob(QuartzScheduler.java:855) ~[quartz-2.3.0.jar:na]    at org.quartz.impl.StdScheduler.scheduleJob(StdScheduler.java:249) ~[quartz-2.3.0.jar:na]    at com.decobim.ops.quartz.QuartzEvent.onEvent(QuartzEvent.java:56) ~[classes/:na]</code></pre><p>错误描述是 <code>org.quartz.ObjectAlreadyExistsException: Unable to store Job : &#39;todoJobGroup.1183894449946624&#39;, because one already exists with this identification.</code><br>不能存储job,因为相同的job已经存在了.</p><p>那就很容易解决,问题出现在这行:</p><pre><code>//at com.decobim.ops.quartz.QuartzEvent.onEvent(QuartzEvent.java:56) ~[classes/:na]//相应代码为: scheduler.scheduleJob(job, trigger);</code></pre><p>因为相同的job名已经存在,所以要做的就是删除之前的该名称的job. 问题出现在,本应该被删除的job,实际是被暂停了.又去翻了一下Scheduler的代码,看了一下注释(注释写的真的挺全的)</p><pre><code>/** * Pause the &lt;code&gt;{@link Trigger}&lt;/code&gt; with the given key. *  * @see #resumeTrigger(TriggerKey) */void pauseTrigger(TriggerKey triggerKey)    throws SchedulerException;/** * Remove the indicated &lt;code&gt;{@link Trigger}&lt;/code&gt; from the scheduler. *  * &lt;p&gt;If the related job does not have any other triggers, and the job is * not durable, then the job will also be deleted.&lt;/p&gt; */boolean unscheduleJob(TriggerKey triggerKey)    throws SchedulerException;</code></pre><p>之前用的是<code>pauseTrigger</code> 作用只是暂停这个trigger,实际应该用<code>unscheduleJob</code></p><pre><code>//scheduler.pauseTrigger(new TriggerKey(todoItemId, TODO_TRIGGER_GROUP));// 修改为// 从pause改为unSchedule pause只是暂停,unSchedule是从数据库中删除scheduler.unscheduleJob(new TriggerKey(todoItemId, TODO_TRIGGER_GROUP));</code></pre><p>在scheduleJob这边也做个防范:</p><pre><code>/** * Remove (delete) the &lt;code&gt;{@link org.quartz.Trigger}&lt;/code&gt; with the * given key, and store the new given one - which must be associated * with the same job (the new trigger must have the job name &amp; group specified)  * - however, the new trigger need not have the same name as the old trigger. *  * @param triggerKey identity of the trigger to replace * @param newTrigger *          The new &lt;code&gt;Trigger&lt;/code&gt; to be stored. *  * @return &lt;code&gt;null&lt;/code&gt; if a &lt;code&gt;Trigger&lt;/code&gt; with the given *         name &amp; group was not found and removed from the store (and the  *         new trigger is therefore not stored), otherwise *         the first fire time of the newly scheduled trigger is returned. */Date rescheduleJob(TriggerKey triggerKey, Trigger newTrigger)     throws SchedulerException;</code></pre><pre><code>//scheduler.scheduleJob(job, trigger);// 修改为:try {    scheduler.scheduleJob(job, trigger);}catch (ObjectAlreadyExistsException e){    // 放置出现triggerKey相同的情况,无论如何 后添加的trigger要覆盖老trigger    TriggerKey triggerKey = new TriggerKey(todoItemId, TODO_TRIGGER_GROUP);    scheduler.rescheduleJob(triggerKey,trigger);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot启动时,不想连接mysql</title>
      <link href="/2019/07/27/2019-7-27/"/>
      <url>/2019/07/27/2019-7-27/</url>
      
        <content type="html"><![CDATA[<p>在拆分服务的时候，因为当前服务没有使用到mysql数据库。便把mysql配置文件删除。结果报错：</p><pre><code>***************************APPLICATION FAILED TO START***************************Description:Cannot determine embedded database driver class for database type NONEAction:If you want an embedded database please put a supported one on the classpath. If you have database settings to be loaded from a particular profile you may need to active it (the profiles &quot;local&quot; are currently active).</code></pre><p>这个问题以前也碰到过，那时候没有开始写博客，纪录一下。 因为SpringBoot启动时会默认加载<code>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</code>，而mysql的配置文件又被删掉了。spring找不到datasource注入因此报错。</p><p>解决方法是： <a href="https://blog.csdn.net/u012240455/article/details/82356075" target="_blank" rel="noopener">spring boot 不连接数据库启动</a><br>在启动类上加上注解 <code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})})</code></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想使用Set去重,又想保持插入顺序</title>
      <link href="/2019/07/23/2019-7-23/"/>
      <url>/2019/07/23/2019-7-23/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="###问题描述  "></a>###问题描述  </h2><p>今天在做项目时,老大过来瞄了一眼代码,对其中使用Set表示不满.他认为,应该使用ArrayList,自己手动去去重以保证插入时的顺序.</p><p>当场我第一个想到的是使用TreeSet保证顺序.但是TreeSet是按自然顺序排序的,没有办法满足我的需求. </p><p>在下班后骑上我的明智小chei子之后<del>(总觉得骑车的时候自己安静的思考很容易想到各种乱七八糟的方法)</del>,突然想到Java中有一个数据结构自从学了之后就从没用过 <code>LinkedHashSet</code>.</p><p>仔细回想了一下LinkedHashSet,是Set类型,同时使用链表来维护集合中的顺序. 会去重又维护了插入顺序,就他了!</p><hr><p>记录一下Set各个实现的区别:<br> <a href="https://www.cnblogs.com/Terry-greener/archive/2011/12/02/2271707.html" target="_blank" rel="noopener">HashSet,TreeSet和LinkedHashSet的区别</a></p><hr><p>看来以后不光要学习框架知识,基础知识也要兼顾.话说回来,int类型占几个字节来的.</p><hr><p>2019年8月10日13:02:15<br>最后还是使用了ArrayList,完全没有合适的理由. 只是因为<code>没见过有人用过</code>.</p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一下自己觉得实用的帖子 (持续更新)</title>
      <link href="/2019/07/17/2017-7-17-1/"/>
      <url>/2019/07/17/2017-7-17-1/</url>
      
        <content type="html"><![CDATA[<ol><li>使用MongoDB时,因为是使用spring整合,基本是用Criteria类进行查询.有时会出现一些Criteria类不能支持的情况,帖子里介绍了BasicQuery类使用起来和直接用MongoDB差不多.<br><a href="https://blog.csdn.net/congcong68/article/details/47183209" target="_blank" rel="noopener">Spring Data MongoDB 三：基本文档查询（Query、BasicQuery）（一）</a></li><li>一个网站,是一般开发用到文档的翻译. 因为之前找了很久spring的文档,中文基本是翻译到一半弃坑,英文阅读难度太大,看了后面忘前面.<br><a href="https://www.docs4dev.com/" target="_blank" rel="noopener">Docs4Dev</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 思而不学则殆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartz修改代码后仍运行老代码的问题</title>
      <link href="/2019/07/17/2019-7-17/"/>
      <url>/2019/07/17/2019-7-17/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>今天在使用quartz时,因为一个疏忽,错误的将一个job加入了scheduler中.<br>之后不管怎么改代码都是老的结果,并没有细想原因而是单方面认为是缓存的原因.导致不管是清class文件还是重启都无法解决.直到下班都没有解决.<br>带着疑惑,想着明天再过来说不定就好了.就在下楼骑上车刚上路没几步时,突然想起来:  __ quartz支持使用数据库持久化保存定时任务的状态和信息.__<br>破案了! 难怪不管怎么清缓存都不会生效,在项目重启时,quartz自己去数据库读取任务执行,当然不会收代码的影响.<br>这次事件记录在问题发生的晚上.先记录下来明天到公司去验证猜想.<br>也给了我一些思考:  </p><blockquote></blockquote><ol><li>对quartz的持久化没有做出充分全局的认识,以前在做的过程中只是做<code>代码的搬运工</code>而没有深入了解到底是为什么.  </li><li>quartz框架的持久化似乎更新有问题,如果相同id的定时任务,第二次应该更新数据库中的信息才对.而实际并没有更新,这点并没有做出验证,要等到有时间再好好看看.</li></ol><p>附上quartz中文文档,今天粗粗的瞄了一眼似乎写的挺全的 : <a href="https://www.w3cschool.cn/quartz_doc/quartz_doc-2put2clm.html" target="_blank" rel="noopener">Quartz快速入门指南</a></p>]]></content>
      
      
      <categories>
          
          <category> 学而不思则罔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在使用@Async情况下，子线程访问父线程中@RequestScope注解修饰的对象</title>
      <link href="/2019/07/14/2019.7.14/"/>
      <url>/2019/07/14/2019.7.14/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><blockquote><p>在开发过程中，发现使用@Async修饰的方法，一旦使用到@RequestScope修饰的对象时，就会出现异常。<br>大致意思是当前线程没有request scope。  </p></blockquote><h2 id="搜索过程"><a href="#搜索过程" class="headerlink" title="搜索过程:"></a>搜索过程:</h2><p>在搜索问题的过程中，发现似乎所有的线索都在指向：<a href="https://stackoverflow.com/questions/23732089/how-to-enable-request-scope-in-async-task-executor" target="_blank" rel="noopener">How to enable request scope in async task executor</a><br>帖子描述问题和我碰到的问题一模一样。既然找到同病相怜的人，那就看怎么解决的吧。于是： </p><pre><code>public class ContextAwarePoolExecutor extends ThreadPoolTaskExecutor {    @Override    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {        return super.submit(new ContextAwareCallable(task, RequestContextHolder.currentRequestAttributes()));    }    @Override    public &lt;T&gt; ListenableFuture&lt;T&gt; submitListenable(Callable&lt;T&gt; task) {        return super.submitListenable(new ContextAwareCallable(task, RequestContextHolder.currentRequestAttributes()));    }}public class ContextAwareCallable&lt;T&gt; implements Callable&lt;T&gt; {    private Callable&lt;T&gt; task;    private RequestAttributes context;    public ContextAwareCallable(Callable&lt;T&gt; task, RequestAttributes context) {        this.task = task;        this.context = context;    }    @Override    public T call() throws Exception {        if (context != null) {            RequestContextHolder.setRequestAttributes(context);        }        try {            return task.call();        } finally {            RequestContextHolder.resetRequestAttributes();        }    }}@Configurationpublic class ExecutorConfig extends AsyncConfigurerSupport {    @Override    @Bean    public Executor getAsyncExecutor() {        return new ContextAwarePoolExecutor();    }}</code></pre><p> __ 结果并不可行，似乎是因为版本更新，这个方法已经行不通了。 __</p><p>随后不甘心的点击<code>RequestContextHolder</code>里面的代码查看。<br>发现RequestContextHodler里有两个方法：</p><pre><code>   public static void setRequestAttributes(RequestAttributes attributes) {        setRequestAttributes(attributes, false);    }    public static void setRequestAttributes(RequestAttributes attributes, boolean inheritable) {        if (attributes == null) {            resetRequestAttributes();        }        else {            if (inheritable) {                inheritableRequestAttributesHolder.set(attributes);                requestAttributesHolder.remove();            }            else {                requestAttributesHolder.set(attributes);                inheritableRequestAttributesHolder.remove();            }        }    }</code></pre><p>可以看到,其中setRequestAttributes(RequestAttributes attributes, boolean inheritable)是取不一样的AttributesHolder.<br>于是我尝试将代码改成</p><pre><code>public class ContextAwareCallable&lt;T&gt; implements Callable&lt;T&gt; {    private Callable&lt;T&gt; task;    private RequestAttributes context;    public ContextAwareCallable(Callable&lt;T&gt; task, RequestAttributes context) {        this.task = task;        this.context = context;    }    @Override    public T call() throws Exception {        if (context != null) {            RequestContextHolder.setRequestAttributes(context, true);        }        try {            return task.call();        } finally {            RequestContextHolder.resetRequestAttributes();        }    }}</code></pre><p>重启测试… …<br>结果依然是失败的.<br>之后,我又注意到</p><pre><code>try {    return task.call();} finally {    RequestContextHolder.resetRequestAttributes();}</code></pre><p>在finally中调用了<code>RequestContextHolder.resetRequestAttributes();</code>.<br>其在RequestContextHolder中对应的源码是:</p><pre><code>public static void resetRequestAttributes() {    requestAttributesHolder.remove();    inheritableRequestAttributesHolder.remove();}</code></pre><p>直接将RequestAttributesHolder给清了. 怒从心头起,恶向胆边生,不清了!<br>将之注释掉.</p><pre><code>public class ContextAwareCallable&lt;T&gt; implements Callable&lt;T&gt; {    private Callable&lt;T&gt; task;    private RequestAttributes context;    public ContextAwareCallable(Callable&lt;T&gt; task, RequestAttributes context) {        this.task = task;        this.context = context;    }    @Override    public T call() throws Exception {        if (context != null) {            RequestContextHolder.setRequestAttributes(context, true);        }        try {            return task.call();        } finally {            // RequestContextHolder.resetRequestAttributes();        }    }}  </code></pre><p>重启测试… …<br>成了!</p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><pre><code>public class ContextAwarePoolExecutor extends ThreadPoolTaskExecutor {    @Override    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {        return super.submit(new ContextAwareCallable(task, RequestContextHolder.currentRequestAttributes()));    }    @Override    public &lt;T&gt; ListenableFuture&lt;T&gt; submitListenable(Callable&lt;T&gt; task) {        return super.submitListenable(new ContextAwareCallable(task, RequestContextHolder.currentRequestAttributes()));    }}public class ContextAwareCallable&lt;T&gt; implements Callable&lt;T&gt; {    private Callable&lt;T&gt; task;    private RequestAttributes context;    public ContextAwareCallable(Callable&lt;T&gt; task, RequestAttributes context) {        this.task = task;        this.context = context;    }    @Override    public T call() throws Exception {        if (context != null) {            RequestContextHolder.setRequestAttributes(context, true);        }        try {            return task.call();        } finally {            // RequestContextHolder.resetRequestAttributes();        }    }}@Configurationpublic class ExecutorConfig extends AsyncConfigurerSupport {    @Override    @Bean    public Executor getAsyncExecutor() {        return new ContextAwarePoolExecutor();    }}</code></pre><p>__ 该解决过程仅解决了@Async注释的方法调用到了@RequestScope修饰的对象.并没有测试过是否会出现其他问题.仅保存为自己复习所用. __</p><hr><p>2019年8月10日13:01:00<br>最近老大看了一下spring文档,跟我说了一下我最后注释的那个reset方法,感觉还是要放开. 目前还没有改动,等到实际改了再更新.</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
